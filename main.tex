%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------

\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{hyperref}

\usepackage{minted} % Code listing with reasonable good highlighting
\usepackage{bussproofs}   % For typing judgments
\usepackage[no-math]{fontspec}
\setmonofont[Scale=MatchLowercase]{Apple Symbols} % Unicode mono font

\usepackage[dvipsnames]{xcolor}  		% Color package
\definecolor{dgreen}{rgb}{0.,0.6,0.}    % Deep green
\usepackage{caption}
\usepackage{todonotes}	% todos

% Figures with border
\usepackage{float}
%\floatstyle{boxed} 
\restylefloat{figure}

\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{fancyvrb}

% Definitions for unicode characters not included
\usepackage{newunicodechar}                   
\newunicodechar{ᶜ}{$^c$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ᵗ}{$^t$}
\newunicodechar{ˢ}{$^s$}

\usepackage{pifont}
\newunicodechar{✗}{\ding{55}}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathpartir} % typing rules

\theoremstyle{plain}
\newtheorem{definition}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{cor}{Corollary}
\newtheorem{req}{Requirement}

\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusiveo license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Generic diff3 for Algebraic Datatypes}
\subtitle{Subtitle Text, if any}

\authorinfo{Marco Vassena}
           {Chalmers University}
           {vassena@chalmers.se}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}
\todo{190 words: too long? Should I aim for 150-170?}
  The UNIX \texttt{diff3} program automatically merges two the text
  files, given a common base version, comparing them line by line and
  raising conflicts when the changes are irreconcilable.
  %
  The program ignores the actual structure of the data stored in the
  files, hence it generates spurious conflicts, that need to be
  manually resolved.
  %
  In this paper we present a state-based, three-way, persistent,
  data-type generic \texttt{diff3} algorithm whose increased precision
  reduces the number of false conflicts raised and improves its
  merging capabilities.
  %
  We have implemented the algorithm in Agda, a proof assistant with
  dependent types, and developed a model to reason about diffing and
  merging.
  %
  \todo{Too many details? More motivation?}
  We have established that the algorithm fulfills its specification
  and proved that it is correct with respect to some safety
  properties.
  %
  Furthermore we have identified the minimal conditions under which
  the merging algorithm raises a conflict and established a structural
  invariant preserved.
  %
  We have implemented our algorithm in Haskell in order to make our results
  practical and employed the latest type-system features to retain the
  same level of type safety of full-blown dependent types.
  \todo{Abstract Conclusion?}
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}
Version control systems (VCS) such as Git \cite{Git} and Mercurial \cite{Mercurial}
are used in the software industry, as well as in the open source community and by researchers all over the world to develop software.
These tools track all the changes in the source code throughout its development, making it possible to quickly roll back to any previous version. Furthermore developers can simultaneously work on the same project and use a VCS to merge their changes together.
VCS provides these features by means of two algorithms, called \texttt{diff} and \texttt{diff3}.
The former detects changes in source code files and it is used to track their history, while the latter merges independent changes made to the code base, allowing simultaneous development.
These algorithms are line-based, they compare files line by line, and can be used not only on software artifacts, but with any text-based file. 
Unfortunately their fixed-granularity limit their precision when detecting changes and deteriorate their merging capabilities. In this paper we develop a data-type generic version of the \texttt{diff} and \texttt{diff3} algorithms, that improve their precision and applicability.

\paragraph{Example}
We show the shortcomings of the line-based \texttt{diff} and \texttt{diff3} algorithms by means of an example.
The Comma Separated Values file format (CSV) is a simple text-based encoding of data stored in tables \cite{csv}.
In a CSV file every line represents a row of the table and within each row commas separate values in different columns.
For instance the file \texttt{a.csv} encodes a $3 \times 3$ table containing numbers from 1 to 9.
\begin{figure}[!h]
\centering
\begin{minipage}{.15\textwidth}
{  \centering
  \begin{verbatim}
  $ cat a.csv
  1,2,3
  4,5,6
  7,8,9
  \end{verbatim}\par
}
\end{minipage}%
\begin{minipage}{.15\textwidth}
{  \centering
  \begin{tabular}{ | c | c | c | }
    \hline
    1 & 2 & 3 \\ \hline
    4 & 5 & 6 \\ \hline
    7 & 8 & 9  \\ \hline
  \end{tabular}\par
}
\end{minipage}%
\end{figure}

Imagine that two users are simultaneously working on this table.
The first user adds a column filled with zero and saves the new table in \texttt{b.csv}:
\begin{figure}[h]
\centering
\begin{minipage}{.15\textwidth}
  \centering
\begin{Verbatim}[commandchars=\\\{\}]
  $ cat b.csv
  \textcolor{blue}{0},1,2,3
  \textcolor{blue}{0},4,5,6
  \textcolor{blue}{0},7,8,9
\end{Verbatim}
\end{minipage}%$
\begin{minipage}{.15\textwidth}
  \centering
  \begin{tabular}{ | c | c | c | c | }
    \hline
    \textcolor{blue}{0} & 1 & 2 & 3 \\ \hline
    \textcolor{blue}{0} & 4 & 5 & 6 \\ \hline
    \textcolor{blue}{0} & 7 & 8 & 9  \\ \hline
  \end{tabular}
\end{minipage}%
\end{figure} 

The second user changes some values in the third column and saves the new table in  \texttt{c.csv}:
\begin{figure}[h]
\centering
\begin{minipage}{.15\textwidth}
  \centering
  \begin{Verbatim}[commandchars=\\\{\}]
  $ cat c.csv
  1,2,3
  4,5,\textcolor{magenta}{9}
  7,8,\textcolor{magenta}{15}
  \end{Verbatim}
\end{minipage}% $
\begin{minipage}{.15\textwidth}
  \centering
  \begin{tabular}{ | c | c | c | }
    \hline
    1 & 2 & 3 \\ \hline
    4 & 5 & \textcolor{magenta}{9} \\ \hline
    7 & 8 & \textcolor{magenta}{15} \\ \hline
  \end{tabular}
\end{minipage}%
\end{figure}

The two users would like to synchronize their work now and decide to use 
\texttt{diff3} to merge their versions. They have modified \emph{indipendent} parts of the table, therefore they are confident that it is should be possible to automatically merge the changes, without incurring in a conflict.
Unfortunately \texttt{diff3} is a line-based algorithm therefore it compares files line by line, without considering the actual structure of the data stored in the files. As a result the algorithm fails to merge the two tables and raises spurious conflicts.

In particular \texttt{diff3} employs the \emph{three-way-merge} technique to compare and merge the corresponding lines of three files. The following table shows the result of applying this technique to the previous tables:
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\texttt{b} & \texttt{a} & \texttt{c} & \texttt{diff3 b a c} \\ \hline
\texttt{\textcolor{blue}{0},1,2,3} & \texttt{1,2,3} & \texttt{1,2,3} & \textcolor{dgreen}{\texttt{0,1,2,3}} \\ \hline
\texttt{\textcolor{blue}{0},4,5,6} & \texttt{4,5,6} & \texttt{4,5,\textcolor{magenta}{9}} & \textcolor{red}{✗}  \\ \hline
\texttt{\textcolor{blue}{0},7,8,9} & \texttt{7,8,9} & \texttt{7,8,\textcolor{magenta}{15}} & \textcolor{red}{✗} \\ \hline
\end{tabular}
\end{center}
A merge is possible when there is at most one different version of the same line, as it happens in the first row.
A conflict is instead triggered when the same line is different in all the three versions, which is the case in the second and third row.


\paragraph{Discussion}
The main limitation of \texttt{diff3} and \texttt{diff} is that they are  coarse-grained, because they operate on data representation with a fixed precision consisting of one line of text, therefore disregarding completely any information about the actual structure of the data.
If \texttt{diff} and \texttt{diff3} were aware of the table structure, consisting of columns and rows, then \texttt{diff} could exactly represent the differences in each version and \texttt{diff3} could automatically merge them, as the users expected:
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\textcolor{blue}{0} & 1 & 2 & 3 \\ \hline
\textcolor{blue}{0} & 4 & 5 & \textcolor{magenta}{9} \\ \hline
\textcolor{blue}{0} & 7 & 8 & \textcolor{magenta}{15} \\ \hline
\end{tabular}
\end{center}

% Obviously we do not want to implement format specific \texttt{diff} and \texttt{diff3} algorithms, since this would hinder reusability, but instead
% they manipulate data directly, assuming that parsers and serializers for it are available. Furthermore we would like our algorithms to be as reusable as possible, with data of any possible shape.

\subsection{Contributions}
In this paper we make the following contributions:
\begin{itemize}
\item In section \ref{subsec:edit-script} we define a type-safe edit script data 
      type that supports \emph{delete}, \emph{insert} and \emph{update} edits and 
      that represents the differences between two objects. In section 
      \ref{subsec:diff-algo} we give the formal specifications of a \texttt{diff} 
      algorithm in terms of the edit script data type.
\item In section \ref{subsec:merge-semantics} we formalize the 
      \emph{three-way-merge} strategy and give a precise semantics of 
      \emph{mergeable} and \emph{conflicting} edits. We give 
      the formal specifications of a \texttt{diff3} algorithm in terms of our edit 
      semantics. 
\item In section \ref{subsec:diff3-algo} we show a data-type generic, three-way 
      \texttt{diff3} algorithm that satisfy our specifications and we study its 
      formal properties in section \ref{sec:properties}.
\todo{Haskell implementation?}
\end{itemize}
We have implemented these algorithms using generic programming techniques in Agda \cite{agda}, a programming language with dependent types and a proof assistant. 
Dependent types are particularly convenient in this setting to idiomatically encode the pre-conditions and post-conditions of our algorithms and ultimately verify their properties.
The source code containing the \texttt{diff} and \texttt{diff3} algorithms, their properties and formal proofs are available online\footnote{TODO create separate repo just for this}. 
For the sake of presentation we have simplified the code presented in this paper, for instance by 
hiding implicit arguments and universe levels.

\section{Universe}
In order to implement data type generic algorithms we need a generic
representation of algebraic data types.
%
The universe used in this paper consists of typed heterogeneous rose
trees, a combination of mutually recursive heterogeneous lists and
trees whose \emph{nodes} correspond to data type constructors and
their children to their fields.
\begin{minted}{agda}
  data HTree : Set → Set where
    Node : F as a → HList as → HTree a

  data HList : List Set → Set where
    [] : HList []
   _∷_ : HTree a → HList as → HList (a ∷ as)
\end{minted}
	The type \texttt{F as a} denotes the constructor of an algebraic data
	type of type \texttt{a} that takes arguments of types determined by the list 
	\texttt{as}.
        %
        This representation is type-safe because the constructor
        \texttt{Node} requires the same types \texttt{as} in the
        fields types and in the list of subtrees, hence it forms a
        well-typed application of a constructor to its arguments.
        %
	We will show in section \ref{sec:haskell} how to instantiate \texttt{F} with concrete 
        data types. In the model we will just leave it abstract as a module parameter.
\begin{minted}{agda}
module Diff3 (F : List Set → Set → Set) where
\end{minted}
	
        \paragraph{Example} 
        The list \texttt{[1,2]} can be encoded in this universe as: 
\begin{Verbatim}[commandchars=\\\{\}]
hs : HList [List Int]
hs = Node (\textcolor{blue}{::}) [Node \textcolor{magenta}{1} [], Node (\textcolor{blue}{::}) [Node \textcolor{magenta}{2} [], Node \textcolor{blue}{[]} []]]
\end{Verbatim}
        Where \texttt{(\textcolor{blue}{::}) : F [Int, List Int] (List Int)}
        and \texttt{\textcolor{blue}{[]} : F [] (List Int)} are the reification of respectively the cons constructor and the
        empty list constructor, specialized without loss of generality to the type \texttt{List Int}.
        Similarly in our examples we will automatically lift numbers to node constructors, that is
        \texttt{\textcolor{magenta}{1}, \textcolor{magenta}{2} : F [] [Int]}.

	In the following we will use two auxiliary functions to append and split 
	heterogeneous lists:
\begin{minted}{agda}
_+++_ : HList as → HList bs → HList (as ++ bs)
hsplit : HList (as ++ bs) → HList as × HList bs
\end{minted}
	
\section{Generic diff}
	Our \texttt{diff3} algorithm relies on a \texttt{diff} algorithm used 
        as a subroutine to quickly compare the input objects and merge them.
	The algorithm finds the differences between two heterogeneous lists given 
	as input producing an edit script, whose edit operations progressively 
	transform one into the other.

	\subsection{Edit Operations}
	Single edits are defined over \emph{values}, which denote either the presence or 
	the absence of a node.
        At first we might try to define them as a maybe value:
\begin{minted}{agda}
Val : List Set → Set → Set
Val as a = Maybe (F as a)
\end{minted}
        In the type \texttt{Val as a} the parameters \texttt{as} and \texttt{a} 
        witness the possible presence of a node \texttt{F as a}, that given objects 
        of types \texttt{as} will produce an object of type \texttt{a}.
        The drawback of this encoding is that \texttt{as} and \texttt{a} are 
        valid input and output approximations only if a node is in fact present.
        An indexed data type on the other hand can give a much more accurate
        approximation:
\begin{minted}{agda}
data Val : List Set → List Set → Set where
  ⊥ : Val [] []
  ⟨_⟩ : F as a → Val as [ a ] 
\end{minted}
        The data type \texttt{Val as bs} is indexed by two lists \texttt{as} and 
        \texttt{bs} that assume only certain values, depending on the presence
        of a node. This definition ensures that for any value \texttt{Val as bs}, 
        the lists \texttt{as} and \texttt{bs} always accurately approximate inputs 
        and outputs regardless of the presence of a node.
	Namely an empty value will consume no input and produce nothing, hence
        both lists are empty.
        A non-empty value contains a node \texttt{F as a} which consumes 
        objects of types \texttt{as} and produces a single object of type \texttt{a}.

	The set of edit operations considered includes a no-operation, node 
	deletion, insertion and update.
\begin{minted}{agda}
data _⟿_ : Val as bs → Val cs ds → Set where
  Nop : ⊥ ⟿ ⊥
  Del : (α : F as a) → ⟨ α ⟩ ⟿ ⊥
  Ins : (α : F as a) → ⊥ ⟿ ⟨ α ⟩
  Upd : (α : F as a) (β : F bs a) → ⟨ α ⟩ ⟿ ⟨ β ⟩
\end{minted}
	Edits are indexed by two values, called respectively 
	\emph{source} and \emph{target} values. The \texttt{Nop} edit is 
	a no-operation that is used exclusively to \emph{align} edit scripts,
	therefore it maps the empty value into itself.
	The edit \texttt{Del α} deletes the node \texttt{α} from the source object, 
	thus it is mapped to \texttt{⊥}. Conversely the edit \texttt{Ins α} 
	inserts node \texttt{α} in the target object and therefore its source value 
	is 	\texttt{⊥}.
	Lastly \texttt{Upd α β} denotes the update of source node \texttt{α}
	to target node \texttt{β}, which concretely represents a 
	constructor change. 
	Note that there is no explicit copy edit: it is just a special case 
	of update, in which the source and target nodes happen to be the same.
	Edits whose source and target values are identical are 
	called \emph{identity} edits. Copy and no-operation fall into this
	category.
	
	\subsection{Edit Script}
        \label{subsec:edit-script}
	An edit script collects a finite number of edit operations, 
	while preserving type-safety. 
\begin{minted}{agda}
data ES : List Set → List Set → Set where
  [] : ES [] []
  _::_ : {v : Val as bs} {w : Val cs ds} → v ⟿ w → 
          ES (as ++ xs) (cs ++ ys) → ES (bs ++ xs) (ds ++ ys)
\end{minted}	
	An edit script of type \texttt{ES xs ys} transforms
	a \emph{source} object of type \texttt{HList xs} into
	a \emph{target} object of type \texttt{HList ys}. 
        The indexes of the edit script are used as stacks by respectively the 
        \emph{source} and \emph{target} values of each edit contained in the script.
        This encoding is type-safe because the input list of the \emph{source} and 
        \emph{target} values are present on top of respectively the input and output 
        stack of the remaining script and their output lists are 
        found on top of the stacks of the resulting script.

        \paragraph{Example}
        The following edit script encodes the differences between \texttt{[1,2,3]} 
        and \texttt{[\textcolor{blue}{0},1,2,3]}, the first row of the tables 
        from the introduction:

\begin{Verbatim}[commandchars=\\\{\}]
e : ES [List Int] [List Int]
e = [\textcolor{blue}{Ins (::)} , \textcolor{blue}{Ins 0}, Upd (::) (::), Upd 1 1 ... Upd [] []]
\end{Verbatim}

	The following function retrieves the source object from an edit 
        script:			
\begin{minted}{agda}
⟪_⟫ : ES as bs → HList as
⟪ [] ⟫ = []
⟪ Nop ∷ e ⟫ = ⟪ e ⟫
⟪ Del α ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
⟪ Ins α ∷ e ⟫ = ⟪ e ⟫
⟪ Upd α β ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
\end{minted}
	No-operations and insert edits do not affect the source object,
	because their source value is empty, therefore in these cases the source 
	function is simply called recursively.
	On the other hand delete and update edits alter a node of the
	source object by either removing it or changing it.
	In these two cases such node is output as part of the source object.
	The source function is called recursively on the rest of the edit 
	script producing a list, whose prefix correspond to the subtrees of the
	top node. Using the function \texttt{hsplit} the list is decomposed 
	accordingly in two parts, which are then assembled appropriately.
	
	Dually we define a function that retrieves the target object.
	Since it is analogous to the previous we give only its signature:
	
\begin{minted}{agda}
⟦_⟧ : ES as bs → HList bs
\end{minted}

\subsection{Diff Algorithm}
\label{subsec:diff-algo}
The \texttt{diff} algorithm detects differences between
two objects and has the the following signature:
\begin{minted}{agda}
diff : HList as → HList bs → ES as bs
\end{minted}
Our model abstracts over the specific \texttt{diff} algorithm used:
the results proved are valid for a class of diffing algorithms that
satisfy some basic requirements.

\begin{req}[\texttt{diff} specifications]
  \label{req:diff-specs}
  A \texttt{diff} algorithm is correct if and only if for any list
  \texttt{x} and \texttt{y}
  \center{\texttt{e = diff x y ⇔ ⟪ e ⟫ ≡ ∧ ⟦ e ⟧ ≡ y}}
\end{req}
%
This correctness criterion demands that the edit script computed by
\texttt{diff} transform exactly the source object \texttt{x} into the
target object \texttt{y}.  (In the specifications \texttt{≡} denotes
propositional equality.)
%
The advantage of reasoning by such specification is that we are not
bound to a particular \texttt{diff} algorithm when studying the
properties of \texttt{diff3}, so that arbitrary diffing techniques can
be used.
%
The following data type serves to this purpose: \texttt{Diff x y e} is
the proof that the edit script \texttt{e} is the result of diffing
lists \texttt{x} and \texttt{y}.
\begin{minted}{agda}
data Diff : HList xs → HList ys → ES xs ys → Set where
  End : Diff [] [] []
  Nop : Diff x y e → Diff x y (Nop ∷ e)
  Del : Diff (x₁ +++ x₂) y e → Diff (Node α x₁ ∷ x₂ ) y (Del α ∷ e)
  Ins : Diff x (y₁ +++ y₂) e → Diff x (Node β y₁ ∷ y₂) (Ins β ∷ e)
  Upd : Diff (x₁ +++ x₂) (y₁ +++ y₂) e → 
        Diff (Node α x₁ ∷ x₂) (Node β y₁ ∷ y₂) (Upd α β ∷ e)
\end{minted}

We prove that \texttt{Diff x y e} complies with the specifications of
\texttt{diff} (Requirement \ref{req:diff-specs}), because \texttt{x}
and \texttt{y} are uniquely determined by respectively the source and
target function applied on \texttt{e}, as the following result shows.
\begin{prop}[\texttt{Diff} is correct]
\label{prop:diff-correct}
Let \texttt{x} and \texttt{y} be heterogeneous lists and \texttt{e} an edit script, then
\center{\texttt{Diff x y e ⇔ x ≡ ⟪ e ⟫ ∧ y ≡ ⟦ e ⟧}}
\end{prop}

	In our implementation the \texttt{diff} algorithm employed is a 
        generalization of that proposed by Lempsink et al.\ \cite{Lemp09},
        which will be discussed in section \ref{sec:related-work}.
        We remark that we have proved that it 
	complies with the \texttt{Diff} specification:
\begin{minted} {agda}
diff-suff :  (x : HList xs) (y : HList ys) → Diff x y (diff x y)
\end{minted}

\section{Generic diff$_3$}
	The \texttt{diff3} algorithm takes as input three objects, the original
	version called \emph{base} and two new replicas, and it outputs an
	edit script that combines the changes between them.
	However the algorithm does not work directly on the replicas, but relies
	on a \texttt{diff} algorithm to compute two edit scripts that describe
	the changes from base to each of the new versions.
	It then merges the edits contained in the two edit scripts and produce
	an edit script, whose \emph{source} is the base object and whose 
	\emph{target} is the merged object.
	Nevertheless not all edits can be automatically reconciled.
	In these cases a conflict is detected and reported to the user, who has
	to solve it manually.
		
	The merging technique employed in the \texttt{diff3} algorithm for
	algebraic data types consists in applying the three-way merge algorithm
	at the node level. 
	Informally the algorithm compares corresponding parts 
	of two objects and of their base version.
	When two parts disagree, the base version is examined:
	if all of them are different a conflict is detected, 
        otherwise the version that changed from base is chosen.
	
	To put this strategy on a formal footing we give precise definitions
	of corresponding parts and conflicts.
	On top of these we define a sound merging semantics.

	\subsection{Alignment}
        \label{subsec:alignment}
	We call two edit operations \emph{aligned} if they share the
        same \emph{source} value.
        %
        We naturally extend the notion of alignment to edit
        scripts.
        %
        Two edit scripts are \emph{aligned} if all their edits are
        pairwise aligned. The following data type denotes aligned edit
        scripts:
\begin{minted}{agda}
data _⋎_ : ES as bs → ES as cs → Set where
  nil : [] ⋎ []
  cons : (f : u ⟿ v) (g : u ⟿ w) → e₁ ⋎ e₂ → f ∷ e₁ ⋎ g ∷ e₂ 
\end{minted}
	The definition is recursive: two edit scripts are aligned if
        either they are both empty or their heads and their tails are
        both aligned.
        %
	Note that we do not need an auxiliary data type to encode edit
        alignment since this property can be enforced directly with
        their types.
        %
	For example the \texttt{cons} constructor accepts only aligned
        edits because it requires them to have the same source value
        \texttt{u}.
	
        Intuitively two edit scripts that have the same \emph{source}
        object can be aligned, because they share the same collection
        of \emph{source} nodes.
        %
        However insert edits might break alignment because they can
        occur at different point in the scripts.

        \paragraph{Example}
        Consider the list \texttt{x = [1]}, \texttt{y = [0,1]} and \texttt{z = [1,2]}.
        The edit script \texttt{e₁} and \texttt{e₂} represent the \texttt{diff} between \texttt{x} and
        respectively \texttt{y} and \texttt{z} \footnote{In this example \texttt{Cpy α} stands for \texttt{Upd α α}}.

\begin{minted}{agda}
e₁ e₂ : ES [ List Int ] [ List Int ]
e₁ = [Ins  (::), Ins  0, Cpy (::), Cpy 1, Cpy []]
e₂ = [Cpy (::), Cpy 1, Ins  (::), Ins  2, Cpy []] 
\end{minted}       

% \begin{minted}{agda}
% e₁ e₂ : ES [ List Int ] [ List Int ]
% e₁ = [Ins (::), Ins 1, Cpy (::), Cpy 1,                 Cpy []]
% e₂ = [                Cpy (::), Cpy 1, Ins (::), Ins 2, Cpy []] 
% \end{minted}       
        The two edits are not aligned because their first edits are not aligned, since \texttt{⊥ ≢ ⟨ :: ⟩}
        where \texttt{⊥} is the source value of \texttt{Ins (::)} in \texttt{e₁} and \texttt{⟨ :: ⟩} is
        the source value of \texttt{Cpy (::)} in \texttt{e₂}.

        Interestingly alignment can be recovered by inserting no-operation edits in 
        these points. 
\begin{minted}{agda}
e₁* = [Ins (::), Ins 0, Cpy (::), Cpy 1, Nop   , Nop , Cpy []]
e₂* = [Nop   , Nop , Cpy (::), Cpy 1, Ins (::), Ins 2, Cpy []] 
\end{minted}
        The relation \texttt{e ⊴ e*} denotes that the edit script
        \texttt{e*} extends \texttt{e} with a finite number of
        \texttt{Nop} edits.

        Note that the \texttt{Nop} edit change neither the
        \emph{source} nor the \emph{target} of the edit script,
        therefore it is an harmless extension.
        
\begin{prop}[Equivalent Extension]
Let \texttt{e} and \texttt{e*} be two edit scripts such that \texttt{e ⊴ e*}, then
\texttt{⟦ e ⟧ ≡ ⟦ e* ⟧} and \texttt{ ⟪ e ⟫ ≡ ⟪ e* ⟫}
\end{prop}

No-operations are automatically aligned with inserts because they both
share the empty value \texttt{⊥} as \emph{source} and furthermore they
may not introduce spurious conflicts because they are \emph{identity}
edits.
   
        \paragraph{Weak Alignment}
        Two edit scripts are \emph{weakly aligned} \texttt{e₁ \textasciitilde\ e₂} 
        if they admit extensions that are \emph{aligned}:
\begin{minted}{agda}
data _~_ (e₁ : ES xs ys) (e₂ : ES xs zs) : Set where
  WA : e₁ ⊴ e₁* → e₂ ⊴ e₂* → e₁* ⋎ e₂* → e₁ ~ e₂
\end{minted}

        We can now weakly align two edit scripts, that share the
        same \emph{source} object. The alignment procedure examines the scripts
        and extend either of them with no-operations, whenever one inserts a 
        node and the other does not. 
\begin{minted}{agda}
align : Diff x y e₁ → Diff x z e₂ → e₁ ~ e₂
\end{minted}

	\subsection{Merge Semantics}
        \label{subsec:merge-semantics}
	Our merge semantics is defined over aligned edits.
	Two aligned edits contain at most three distinct values: 
	one common source and two, 	possibly different, targets, which 
	are treated as corresponding parts.
	A merge can either fail raising a conflict or succeed producing
	an edit that combines both.
	
	\paragraph{Merge}
	The data type \texttt{f ⊔ g ↧ h} is the proof that merging the 
	aligned edits \texttt{f} and \texttt{g} succeeds producing the edit \texttt{h}.
	
\begin{minted} {agda}
data _⊔_↧_ : (v ⟿ a) → (v ⟿ b) → (v ⟿ c) → Set where
  Id₁ : (f : v ⟿ v) (g : v ⟿ w) → f ⊔ g ↧ g
  Id₂ : (f : v ⟿ w) (g : v ⟿ v) → f ⊔ g ↧ f
  Idem : (f : v ⟿ w) → f ⊔ f ↧ f
\end{minted}

	Observe that the type of the two input edits guarantees their
        alignment.
        %
        Furthermore determines only the \emph{target} value, hence the
        third merged edit retain the the same source value \texttt{v}.

	Each constructor represents a distinct axiom that justifies why
	the merge is possible and determines the merged edit.
	The rules \texttt{Id₁} and \texttt{Id₂} apply when 
	respectively the first and the second transformation is an \emph{identity} 
        edit.
	Similarly to the three-way merge algorithm, when one version is unchanged the other
        is chosen.
	The fact that merging is an \emph{idempotent} operation motivates the 
	third rule \texttt{Idem}.
	It applies when the same edit is performed independently in both versions.
	
	Note that this definition is particularly effective because it is 
	minimal and concise, as it does not mention specific
	edits, yet it is complete, because it can encode all the true concrete 
        merges.	

	\paragraph{Conflict}
	A conflict occurs when two edits perform irreconcilable changes.
	The following data type represents the possible conflicts that may arise
	from aligned edits.
	
\begin{minted}{agda}
data Conflict : Val as bs → Val cs ds → Val es fs → Set where
  DelUpd : (α : F as a) (β : F bs a) → Conflict ⟨ α ⟩ ⊥ ⟨ β ⟩
  UpdDel : (α : F as a) (β : F bs a) → Conflict ⟨ α ⟩ ⟨ β ⟩ ⊥ 
  InsIns : (α : F as a) (β : F bs b) → Conflict ⊥ ⟨ α ⟩ ⟨ β ⟩
  UpdUpd : (α : F as a) (β : F bs a) (γ : F cs a) →
             Conflict ⟨ α ⟩ ⟨ β ⟩ ⟨ γ ⟩    
\end{minted}

	In the type \texttt{Conflict u v w} the index \texttt{u} is
        the common source value, while indexes \texttt{v} and
        \texttt{w} are the target values of the edits.
        %
        Conflicts given by \texttt{InsIns} and \texttt{UpdUpd}
        represent conflicting insertions and updates, similar
        to those detected by line-based \texttt{diff3}, which
        encodes proper updates as a deletion followed by an insertion.
        %
        Those given by \texttt{UpdDel} and \texttt{DelUpd} are
        entirely new and stem from the fact that these two edits are
        in general irreconcilable.

	The data type \texttt{f ⊔ g ↥ c} denotes that the edits
        \texttt{f} and \texttt{g} cannot be merged and raise conflict
        \texttt{c}.

\begin{minted}{agda}
data _⊔_↥_ : (u ⟿ v) → (u ⟿ w) → Conflict u v w → Set where
  Cnf : (f : u ⟿ v) (g : u ⟿ w) → u ≢ v → v ≢ w  → u ≢ w → 
        (c : Conflict u v w) → f ⊔ g ↥ c
\end{minted}

	The three inequalities guarantee that all the values involved are different
        and ensure that the edits are actually incompatible and may not be merged 
        otherwise. For example if \texttt{u ≡ v} the first edit would be an
        \emph{identity} edit, which can always be merged by
        \texttt{Id₁}. Similarly if \texttt{u ≡ w} the second edit could be merged
        by \texttt{Id₂}. Lastly if \texttt{v ≡ w} the edits \texttt{f} and \texttt{g}
        would perform the same change and could be merged applying the \texttt{Idem}
        rule.
        Given these inequalities the corresponding conflict is uniquely determined,
        i.e. for any concrete choice of \texttt{u}, \texttt{v} and \texttt{w} that
        are all different, there is only a single conflict \texttt{c} that applies.
	As a result also the semantics of conflict is minimal, but still complete
        because it can encode all the true conflicts.

        \paragraph{Properties}
        We now show some fundamental properties of our merge semantics that
        will be handy in our formalization.
        %
        Firstly we prove that the semantics is sound, that is
        merge and conflicts are mutually exclusive.
        \begin{prop}[Mutually Exclusive]
          \label{prop:mutually-exclusive}
          Let \texttt{f}, \texttt{g}, \texttt{h} be aligned edits, such that
          \texttt{f ⊔ g ↧ h} then there exists no conflict \texttt{c} such that
          \texttt{f ⊔ g ↥ c}.
        \end{prop}
        Secondly we prove \emph{determinancy} of the semantics relations.
        \begin{prop}[Determinancy]
          \label{prop:determinancy}
        Let \texttt{f}, \texttt{g}, \texttt{h₁}, \texttt{h₂} be
        aligned edits, such that \texttt{f ⊔ g ↧ h₁} and \texttt{f ⊔ g
          ↧ h₂}, then \texttt{h₁ ≡ h₂}.
        %
        Similarly let \texttt{c₁} and \texttt{c₂} be conflicts, such
        that \texttt{f ⊔ g ↥ c₁} and \texttt{f ⊔ g ↥ c₂}, then
        \texttt{c₁ ≡ c₂}.
        \end{prop}

        Now that we have established that our semantics is sensible we
        lastly define a decision function that combines two edits.

	\paragraph{Merge Operator}
	The binary operator \texttt{⊔} merges two aligned edits.
        % 
        For every pair of edits \texttt{f} and \texttt{g}, it either
        finds a suitable edit \texttt{h} and provide a proof that
        \texttt{f ⊔ g ↧ h}, or detects a conflict \texttt{c}, with a
        proof that \texttt{f ⊔ g ↥ c}.
        
\begin{minted}{agda}
_⊔_ : (f : u ⟿ v) (g : u ⟿ w) →
        (∃ λ c → f ⊔ g ↥ c) ⊎ (∃ λ h → f ⊔ g ↧ h)
\end{minted}
	This operator is outlined in table \ref{table:merge}, where we have
        omitted the obvious inequalities in conflicts.

	\begin{table*}[t]
	\centering
	\begin{tabular}{| c | c | c |}
	\hline
	\texttt{f : u \textasciitilde> v} & \texttt{g : u \textasciitilde> w} &  \texttt{f ⊔ g} 
	\\ \hline
	\texttt{Nop} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ Nop g}} 
	\\ \hline
	\texttt{Upd α α} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ (Upd α α) g}} 
	\\ \hline
	\texttt{f} & \texttt{Nop} & \textcolor{Green}{\texttt{Id₂ f Nop}} 
	\\ \hline
	\texttt{f} & \texttt{Upd α α} & \textcolor{Green}{\texttt{Id₂ f (Upd α α)}} 
	\\ \hline
	\texttt{Del α} & \texttt{Del α} & \textcolor{Green}{\texttt{Idem (Del α)}}
	\\ \hline
	\texttt{Del α} & \texttt{Upd α β} & \textcolor{Red}{\texttt{Cnf (Del α) (Upd α β) (DelUpd α β) }}
	\\ \hline
	\texttt{Upd α β} & \texttt{Del α} & \textcolor{Red}{\texttt{Cnf (Upd α β) (Del α) (UpdDel α β)}}
	\\ \hline
	\texttt{Ins α} & \texttt{Ins α} & \textcolor{Green}{\texttt{Idem (Ins α)}} 
	\\	\hline
	\texttt{Ins α} & \texttt{Ins β} & \textcolor{Red}{\texttt{Cnf (Ins α) (Ins β) (InsIns α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α β} & \textcolor{Green}{\texttt{Idem (Upd α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α γ} & \textcolor{Red}{\texttt{Cnf (Upd α β) (Upd α γ) (UpdUpd α β γ)}}
	\\ \hline
	\end{tabular}
	
	\captionsetup{singlelinecheck=false, justification=centering}

	\caption{Implementation of merge operator. \\
	 \texttt{f ⊔ g :} \textcolor{Red}{\texttt{f ⊔ g ↥ c}} \texttt{⊎} \textcolor{Green}{\texttt{f ⊔ g ↧ h}}}	 
	\label{table:merge}
	\end{table*}

	\paragraph{Merged Edit Script}
	Just like we defined a merge operator for aligned edits, we need to 
	define a similar operator for aligned edit scripts.
	However since single merges may fail this operator cannot return 
	the same well-typed edit script, that we have defined before.
	Therefore we introduce an alternative edit script, which is only partially 
	well-typed and that can include conflicts.
\begin{minted}{agda}
data ES₃ : List Set → Set where
  [] : ES₃ []
  _∷_ : {u : Val as bs} → u ⟿ v → ES₃ (as ++ xs) → ES₃ (bs ++ xs)
  _∷ᶜ_ : {u : Val as bs} → (c : Conflict u v w) → 
             ES₃ (as ++ xs) → ES₃ (bs ++ xs)
\end{minted}
	The data type is indexed only by the source type list and it is well-typed
	only with respect to it. Furthermore it provides an additional constructor
	for conflicts. 

        \subsection{Diff$_3$ Algorithm}
        \label{subsec:diff3-algo}

	The merge operator for edit scripts takes two aligned edit scripts and
	applies the merge operator \texttt{⊔} previously defined to
	each pair of aligned edits. It builds a merged edit script choosing a 
	suitable constructor depending on the outcome of each single merge.

\begin{minted}{agda}
merge₃ : {e₁ : ES as bs} {e₂ : ES as cs} → e₁ ⋎ e₂ → ES₃ as
merge₃ nil = []
merge₃ (cons f g p) with f ⊔ g
merge₃ (cons f g p) | inj₁ (c , _) = c ∷ᶜ merge₃ p
merge₃ (cons f g p) | inj₂ (h , _) = h ∷  merge₃ p
\end{minted}
	To improve readability we will use the following infix
        operator:
\begin{minted}{agda}
_⊔₃_ (e₁ : ES as bs) (e₂ : ES as cs) {{p : e₁ ⋎ e₂}} → ES₃ as
_⊔₃_  _ _ {{p}} = merge₃ p
\end{minted}
	The alignment proof is passed  as an instance argument, i.e. a
        special  type  of  implicit arguments  that  is  automatically
        resolved at call-sites \cite{Devriese11}.

        In order to reason about merging we encode the specifications
        of the merge operator in data type \texttt{Merge₃}:

% \begin{figure*}[t!]
% \centering
\begin{minted}{agda}
data Merge₃ : ES xs ys → Es xs zs → ES₃ xs → Set where
  nil : Merge₃ [] [] []
  merge : f ⊔ g ↧ h → Merge₃ e₁ e₂ e₃ → 
                   Merge₃ (f ∷ e₁) (g ∷ e₂) (h ∷ e₃)
  conflict : f ⊔ g ↥ c → Merge₃ e₁ e₂ e₃ → 
                    Merge₃ (f ∷ e₁) (g ∷ e₂) (c ∷ᶜ e₃)
\end{minted}
% \caption{Merge operator specification}
% \label{fig:merge3}
% \end{figure*}

        We now prove that our merge operator fulfills its requirements.
\begin{prop}[\texttt{⊔₃} is correct]
\label{prop:merge3-correct}
Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts such that,
\texttt{e₁ ⋎ e₂}, then:
\center{\texttt{e₃ ≡ e₁ ⊔₃ e₂ ⇔ Merge₃ e₁ e₂ e₃}}
\end{prop}
\begin{proof}
The if direction follows by induction on \texttt{e₁ ⋎ e₂}.
The iff direction follows by induction on \texttt{Merge₃ e₁ e₂ e₃} and 
relies on properties \ref{prop:mutually-exclusive} and \ref{prop:determinancy}.
\end{proof}
        
        Now that we have shown that the merge operator is in a
        one-to-one relationship with the specification data type, we
        will use the latter to reason more conveniently about its
        properties.

	\paragraph{Diff3}
	We finally give a generic \texttt{diff₃} algorithm for
        heterogeneous lists.
        %
        We follow the conventional interface, in which the second
        argument is considered \emph{base}:
\begin{minted}{agda}
diff₃ : HList ys → HList xs → HList zs → ES₃ xs
diff₃ y x z with align (diff-suff x y) (diff-suff x z)
diff₃ y x z | WA _ _ p = merge₃ p
\end{minted}
	
	The \texttt{diff} algorithm is called implicitly by
        \texttt{diff-suf}; the edit scripts so obtained are aligned
        via extension using \texttt{align}, from which the alignment
        proof \texttt{p} is extracted and used to finally merge the
        scripts with \texttt{merge₃}.  Note that the call to
        \texttt{align} is valid because \texttt{diff-suff} is invoked
        with the same \texttt{x} as first argument.

        \paragraph{Type Checking}
	Even though merging might succeed without triggering any
        conflict the merged edit script might be invalid, i.e.\ it will
        not produce a well-typed object as \emph{target}.
        %
        The reason is that the merge operator \texttt{⊔₃} merges edits
        \emph{pointwise}, therefore the script obtained by joining two
        well-typed edit script may not be well-typed.  Consider for
        instance the following edit scripts:
\begin{minted}{agda}
e₁ e₂ : ES [] [List Int]
e₁ = [Ins [], Nop]
e₂ = [Nop, Ins []]
\end{minted}
        Merging the two edits with \texttt{e₁ ⊔₃ e₂} yields a conflict
        free, yet ill-typed edit script:
\begin{minted}{agda}
e₃ : ES₃ []
e₃ = [Ins [], Ins []]
\end{minted}
        The problem is that the first insert produces a constructor
        that does not take any arguments, yet the tail of the script
        yields another empty list as argument.
        
        The merged edit script must be type-checked to ensure that it
        actually produces a well-typed merged \emph{target} object.
        %
	The typing judgment \texttt{e ⇓ as} states that the edit
        script \texttt{e} is well typed and produces a list of type
        \texttt{HList as}.  The typing rules are straightforward:
	\begin{mathpar}
          \inferrule
          {}
          {\texttt{[] ⇓ []}}
          \and
          \inferrule
          {\texttt{f : v \textasciitilde> w} \\ 
           \texttt{w : F cs ds} \\
           \texttt{e ⇓ cs ++ ys}}
          {\texttt{f ∷ e ⇓ (ds ++ ys)}}
        \end{mathpar}

	A trivial inference algorithm can be easily deduced from the typing rules.
	Moreover note that the conflict cons constructor (\texttt{∷ᶜ}) is not 
	mentioned in the typing rules, therefore edit scripts containing
	conflicts are ill-typed.		
	Edit scripts of type \texttt{ES₃} can be converted to \texttt{ES}, if they
	are well typed:
\begin{minted}{agda}
⌜_⌝  : (e : ES₃ xs) → {{q : e ⇓ ys}} → ES xs ys
\end{minted}

\section{Properties}
\label{sec:properties}
In this section we present several properties of our merge algorithm,
all of which have been verified in Agda using the model presented in
this paper.  
%
In the following we will write \texttt{f ∈ e} to denote that edit
\texttt{f} occurs in script \texttt{e}.
%
Furthermore We generalize membership to conflicts \texttt{c ∈ e} and
to nodes in heterogeneous lists \texttt{α ∈ hs}.
  
    \subsection{Conflict}  
    In order to reason about complex merge operations we have studied
    what are the minimal conditions that will trigger a conflict.
    %
    Merging two scripts will result in a conflict if they contain at
    least a pair of aligned edits that may not be merged.  
    %
    The type \texttt{e₁ ⊔₃ e₂ ↥ c} denotes that aligned edit scripts
    \texttt{e₁} and \texttt{e₂} will raise conflict \texttt{c} if
    merged and precisely captures these circumstances.

\begin{minted}{agda}
data _⊔₃_↥_ : ES xs ys → ES xs zs → Conflict u v w → Set where
  here :  f ⊔ g ↥ c → (f ∷ e₁) ⊔₃ (g ∷ e₂) ↥ c
  there : e₁ ⊔₃ e₂ ↥ c → (f ∷ e₁) ⊔₃ (g ∷ e₂) ↥ c
\end{minted}

    % In order to show that these are truly the minimal conditions to get a conflict,
    % we define a data type that denotes that a merged edit script contains a 
    % conflict. 

% \begin{minted}{agda}
% data _∈ᶜ_ (c : Conflict u v w) : ES₃ xs → Set where
%   here : c ∈ᶜ (c ∷ᶜ e)
%   there : c ∈ᶜ e → c ∈ᶜ f ∷ e
%   thereᶜ : c ∈ᶜ e → c ∈ᶜ (c' ∷ᶜ e)
% \end{minted}

    The following theorem shows that a conflict occurs in a merged script
    if and only if there are two aligned conflicting edits in the input scripts.
    
\begin{thm}[Conflict Conditions]
  Let \texttt{e₁} and \texttt{e₂} be two aligned edit scripts
  and let \texttt{e₃ = e₁ ⊔₃ e₂}, then \texttt{c ∈ e₃} if and only if
  \texttt{e₁ ⊔₃ e₂ ↥ c}.
\end{thm}

    % the presence of a conflict in a merged
    % edit script can be explained by the condition \texttt{e₁ ⊔₃ e₂ ↥ c}, i.e.\
    % that \texttt{e₁} and \texttt{e₂} contain two conflicting edits.


% \begin{minted}{agda}
%     Merge₃ e₁ e₂ e₃    ∧    c ∈ᶜ e₃    ⇒    e₁ , e₂ ↥ c
% \end{minted}
%     The proof follows immediately by induction.
%     Conversely we show that \texttt{e₁ , e₂ ↥ c} implies the presence
%     of a conflict in their merged edit script.
% \begin{minted}{agda}
%     Merge₃ e₁ e₂ e₃    ∧    e₁ , e₂ ↥ c     ⇒    c ∈ᶜ e₃
% \end{minted}
%     The proof also follow from induction. Note that we can discharge the paradoxical
%     base case in which the same edits are merged (\texttt{f ⊔ g ↧ h}) in 
%     \texttt{Merge₃ e₁ e₂ e₃} and not (\texttt{f ⊔ g ↥ c}) in \texttt{e₁ , e₂ ↥ c},
%     because these two cases are mutually exclusive.    

    \subsection{Safety}
    The safety properties discussed in this section act as a sanity
    check, ensuring that \texttt{diff} and \texttt{diff3} behave
    properly.
    %
    Firstly, we show \emph{data origin}, which ensures that every source
    and target node found in an edit script belong respectively to the
    source and target object diffed.  
    %
    Secondly, we show the converse property \emph{data retention}, which 
    guarantees that every node found in source and target object is
    processed in the diff and mapped in the edit script.
    %
    We start with some auxiliary definitions and lemmas.
    % Firstly we give some auxiliary definitions that will be used to state and prove
    % this properties.
%     \paragraph{Membership}
%     The type \texttt{α ∈ hs} denotes that the node \texttt{α} is present
%     in the list of trees \texttt{hs}.

% \begin{minted}{agda}
% data _∈_ : F xs a → HList ys → Set where
%   here : (α : F as a) → α ∈ Node α hs₁ ∷ hs₂
%   there : α ∈ (hs₁ +++ hs₂) → α ∈ Node β hs₁ ∷ hs₂
% \end{minted}

%     A similar data type denotes the presence of an edit in a script.

% \begin{minted}{agda}
% data _∈ₑ_ : v ⟿ w → ES xs ys → Set where
%   here : (f : v ⟿ w) → f ∈ₑ f ∷ e
%   there : f ∈ₑ e → f ∈ₑ g ∷ e
% \end{minted}

    % Lastly the judgment \texttt{e ⊢ₑ u ⟿ v} denotes that
    % the script \texttt{e} contains some edit of type \texttt{u ⟿ v}.
\begin{definition}[Edit Mapping]
An edit script \texttt{e} maps source value \texttt{u} into
target value \texttt{v}, written \texttt{e ⊢ u ⟿ v}, if and
only if there is an edit \texttt{f : u ⟿ v} such that \texttt{f ∈ e}.
\end{definition}

% I think I will skip this one and directly state the more interesting one
% \begin{minted}{agda}
%    ∀   f : ⟨ α ⟩ ⟿ v  .  f ∈ₑ e   ⇒   α ∈ ⟪ e ⟫
%    ∀   f : v ⟿ ⟨ α ⟩  .  f ∈ₑ e   ⇒   α ∈ ⟦ e ⟧
% \end{minted}

The following property shows that in an edit script a source (target)
node is correctly part of the source (target) object.
%
In other words the source function \texttt{⟪\_⟫} and target function
\texttt{⟦\_⟧} do not forget any node.
\begin{prop}[\texttt{⟪\_⟫} and \texttt{⟦\_⟧} are correct]
\label{prop:source-target-cmp}
Given an edit script \texttt{e} and a node \texttt{α} then.
If \texttt{e ⊢ₑ ⟨ α ⟩ ⟿ v} then \texttt{α ∈ ⟪ e ⟫}.
Similarly if \texttt{e ⊢ₑ v ⟿ ⟨ α ⟩} then \texttt{α ∈ ⟦ e ⟧}.
\end{prop}

We now formally state the \emph{data origin} property.
\todo{Here I am assuming a diff that satisfies our specification. Is it clear?}
\begin{cor}[Data Origin]
Let \texttt{x} and \texttt{y} be two heterogeneous lists, let \texttt{e = diff x y}
and let \texttt{α} be a node.
If \texttt{e ⊢ₑ ⟨ α ⟩ ⟿ v} then \texttt{α ∈ x}. Similarly if \texttt{e ⊢ₑ v ⟿ ⟨ α ⟩}
then \texttt{α ∈ y}.
\end{cor}    
\begin{proof}
  It follows directly from Requirement \ref{req:diff-specs} and Proposition
  \ref{prop:diff-correct} (requirements and specifications of
  \texttt{diff}) and Proposition \ref{prop:source-target-cmp}.
\end{proof}

We now formally state the \emph{data retention} property.
\begin{prop}[Data Retention]
\label{prop:data-retention}
  Let \texttt{x} and \texttt{y} be two heterogeneous lists, let
  \texttt{e = diff x y} and let \texttt{α} be a node.
%
  If \texttt{α ∈ x} then there is a target value \texttt{v} such that
  \texttt{e ⊢ₑ ⟨ α ⟩ ⟿ v}.
%
  Similarly if \texttt{α ∈ y} then there is a source value \texttt{v} such that
  \texttt{e ⊢ₑ v ⟿ ⟨ α ⟩}.
\end{prop}
\begin{proof}
  It follows from Requirement \ref{req:diff-specs} and Proposition
  \ref{prop:diff-correct} (requirements and specifications of
  \texttt{diff}) and by induction on \texttt{α ∈ x}.
\end{proof}
 
  We give now similar safety properties for our \texttt{diff₃} algorithm.
  We firstly discuss \emph{edit origin}, a generalization of \emph{data origin}
  that ensures that every edit present in the merged script comes from either 
  of the input scripts. We then conclude with  \emph{persistence}, an important 
  theorem that guarantees that no changes of either version are ignored when
  the scripts are merged.

\begin{prop}[Edit Origin]
Let \texttt{e₁}, \texttt{e₂}, \texttt{e₃} be scripts such that
\texttt{e₁ ⋎ e₂} and \texttt{e₃ = e₁ ⊔₃ e₂}. Let \texttt{f} be an edit.
If \texttt{f ∈ e₃} then either \texttt{f ∈ e₁} or \texttt{f ∈ e₂}.
\end{prop}
\begin{proof}
  It follows directly from Property \ref{prop:merge3-correct}
  (correctness of \texttt{⊔₃}) and by induction.
\end{proof}

  We now formally state and prove that our merge algorithm is \emph{persistent}.
  This property is very important because conflicts are triggered by changes,
  hence a non-persistent algorithm could back-out changes to avoid raising
  conflicts.

    % \paragraph{Persistence}
    % The converse property asserts that an edit present in one of the input
    % edit scripts will be found in the merged edit script, given that it does
    % perform a change and that the output script does not contain conflicts.
    % The first hypothesis is needed because identity edits can be silently 
    % ignored in the merge semantics by either \texttt{Id₁} or
    % \texttt{Id₂}.
    % On the other hand the second prerequisite is essential, because 
    % our algorithm is \emph{persistent}, i.e.\ it refuses to back out changes 
    % made by incompatible edits, but triggers an appropriate conflict instead.

    % Firstly an edit does perform a change if it is not an identity edit, or, in 
    % other words if the source and the target values are different.
				
\begin{thm}[Persistence]
Let \texttt{e₁}, \texttt{e₂}, \texttt{e₃} be scripts such that
\texttt{e₁ ⋎ e₂} and \texttt{e₃ = e₁ ⊔₃ e₂}. Let \texttt{f} be an edit
of type \texttt{u ⟿ v} such that \texttt{u ≢ v} and \texttt{f ∈ e₁}.
Then either \texttt{f ∈ e₃} or there is a conflict \texttt{c} such that
\texttt{e₁ ⊔₃ e₂ ↑ c}.
\end{thm}
\begin{proof}
  The proof is by induction on \texttt{Merge₃ e₁ e₂ e₃} (from Property
  \ref{prop:merge3-correct}) and \texttt{f ∈ₑ e₁}.
    % 
    In the base case edit \texttt{f} is merged with some other edit
    \texttt{g}, then either \texttt{f ⊔ g ↥ c} or \texttt{f ⊔ g ↧ h}.
    %
    In the former case we are done because \texttt{f} raises a
    conflict.  In the latter case we proceed by case analysis on
    \texttt{f ⊔ g ↧ h}.
    %
    The merged edit \texttt{h} is either \texttt{f} (case \texttt{Id₂}
    or \texttt{Idem}), or \texttt{g} (\texttt{Id₁}). In the first case
    we are done, because \texttt{f} occurs in the merged script.
    %
    The second case is contradictory because we assumed \texttt{u ≢
      v}.
\end{proof}        

    The theorem holds also when the edit belongs to the other script and
    the proof is entirely symmetrical.
   		
    \subsection{Maximality}
    Another interesting property of our merge algorithm is
    \emph{maximality}, which guarantees that whenever it is possible
    to reconcile two edits from the input scripts, then the merged
    edit must be included in the merged script.
    %
    Theorem \ref{thm:max} shows that every successful merge is
    \emph{maximal}.

    \paragraph{Example} 
    Consider scripts \texttt{e₁*} and \texttt{e₂*} from section
    \ref{subsec:alignment}.
    %
    The merged edit \texttt{e₁* ⊔₃ e₂* = [Ins (::), Ins 0, Cpy (::),
      Cpy 1, Ins (::), Ins 2 , Cpy []]}, is maximal because it
    contains all the edits obtained by merging them pairwise.
    %
    \begin{thm}[Maximality]
      \label{thm:max}
      Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts
      such that \texttt{e₁ ⋎ e₂}, \texttt{e₃ = e₁ ⊔₃ e₂} and
      \texttt{e₃} does not contain any conflict. Then \texttt{e₃} is
      maximal with respect to \texttt{e₁} and \texttt{e₂}.
    \end{thm}

    \subsection{Structural  Invariants}
    An edit script describes how to transform the source object into
    the target object, by traversing it in \emph{depth-first order}
    and mapping source nodes into target nodes.
    %
    Interestingly the embedding preserves the depth-first order: if a
    source node comes before another then the mapping of the first
    will come before the mapping of the second.    
    %
    However nodes are not only mapped (updated) from the source to the
    target, but they may also be inserted and removed, therefore the
    structural invariant must be adjusted to take these edits into
    account.
    %
    Intuitively the order is preserved because nodes that 
    are mapped first in a script precede those that are mapped later.
    %
    We start by generalizing depth-first ordering to list of trees and
    giving a basic ordering to edits in a script.
    %
    % The structural invariant property relies on 
    % by showing how the former implies the latter we deduce
    % the structural invariant.
    

    \paragraph{Depth-First Order}
    A pre-order depth-first traversal consists of firstly visiting the current node 
    and then traversing recursively its subtrees from the leftmost to the rightmost.
    The traversal induces an ordering on the nodes, so that those that
    are visited sooner come before those that are processed later.
    Since edit scripts work with list of trees, we have not to generalize the order accordingly.
    
    The type \texttt{hs ⊢ α ⊏ β} denotes that, in the list of trees \texttt{hs}, 
    the node \texttt{α} comes before the node \texttt{β}, according to the
    depth first traversal.

\begin{minted}{agda}
data _⊢_⊏_ : Hist xs → F as a → F bs b → Set where
  here : β ∈ (hs₁ +++ hs₂) → Node α hs₁ ∷ hs₂ ⊢ α ⊏ β
  there : (hs₁ +++ hs₂) ⊢ α ⊏ β → Node γ hs₁ ∷ hs₂ ⊢ α ⊏ β
\end{minted}

    Intuitively the list is used as a stack, so that after visiting
    each node its children, yet to be traversed, are pushed on the stuck.
    Note that those trees will be visited before those already on the stuck,
    hence following correctly the depth-first traversal.

    \paragraph{Edit Order}
    Since edit scripts are a flat list-like data structure, we simply
    order edits according to their position in the script.

\begin{definition}[Edit Order]
Given an edit script \texttt{e} and two edits \texttt{f} and \texttt{g}, we write
\texttt{e ⊢ₑ f ⊏ g} if and only if \texttt{f} precedes \texttt{g} in \texttt{e}.
\end{definition}

\paragraph{Order Invariant}
Before stating the main theorem relies on two fundamental properties:
that the target (source) function and \texttt{diff} are
\emph{order-preserving} (OP).
%
Property \ref{prop:order-preserving-target-fun} guarantees that the
relative order of edits in a script corresponds to the depth-first
order of their target (source) nodes in the target (source) objects.
%
Property \ref{prop:order-preserving-embedding} ensures that if in the
target (source) object a node precedes another, then in the diff
script the first node is produced by an edit that comes before the
edit that produces the second.

\begin{prop}[\texttt{⟦\_⟧} is OP]
\label{prop:order-preserving-target-fun}
Let \texttt{e} be an edit script and \texttt{f} and \texttt{g} edits
of type \texttt{v ⟿ ⟨ α ⟩} and \texttt{w ⟿ ⟨ β ⟩}, such that
\texttt{e ⊢ f ⊏ g}, then \texttt{⟦ e ⟧ ⊢ α ⊏ β}.
\end{prop}
  We omit the symmetrical property for \emph{source} nodes and objects.

\begin{prop}[Embedding is OP]
\label{prop:order-preserving-embedding}
Let \texttt{x} and \texttt{y} be heterogeneous lists and let 
\texttt{e} be an edit script such that \texttt{e = diff x y}.
Let also \texttt{α} and \texttt{β} be nodes such that \texttt{y ⊢ α ⊏ β}.
Then there are edits \texttt{f : u ⟿ ⟨ α ⟩} and \texttt{g : v ⟿ ⟨ β ⟩}
such that \texttt{e ⊢ f ⊏ g}.
\end{prop}
\begin{proof}
  The proof relies on Requirement \ref{req:diff-specs} and Proposition
  \ref{prop:diff-correct} (requirements and specifications of
  \texttt{diff}).
  %
  By induction on \texttt{y ⊢ α ⊏ β} we locate \texttt{f : u ⟿ ⟨ α ⟩}
  in \texttt{e}. 
  %
  By Proposition \ref{prop:data-retention} it follows that there
  exists \texttt{g : v ⟿ ⟨ β ⟩} in the tail of \texttt{e}.
\end{proof}
We again omit the corresponding property for \emph{source} nodes and object.

    % We now have all the lemmas to prove the \emph{order invariant}
    % theorem, which ensures that the edit script data type preserves
    % the depth-first order of the source (target) objects.
    %
We now prove our main theorem, which ensures that
\texttt{diff} preserves the relative order of nodes in the
source (target) objects.
%
Since nodes may also be deleted the property sees also these cases,
namely if node \texttt{α} precedes \texttt{β} in the source object of
script \texttt{e}, then one of the following holds:
    \begin{itemize}
    \item Node \texttt{α} is deleted in \texttt{e};
    \item Node \texttt{β} is deleted in \texttt{e};
    \item Node \texttt{α} is mapped to some node \texttt{γ} and node
      \texttt{β} is mapped to some node \texttt{φ}, such that node
      \texttt{γ} comes before node \texttt{φ} in the target object.
    \end{itemize}
%
    We show only the theorem about the \emph{source} object, because
    the other is symmetrical.
\begin{thm}[\texttt{diff} is OP]
  Let \texttt{x} and \texttt{y} be heterogeneous lists and \texttt{e}
  an edit script, such that \texttt{e = diff x y}. Let also \texttt{α}
  and \texttt{β} be nodes such that \texttt{x ⊢ α ⊏ β} then either
  \texttt{e ⊢ ⟨ α ⟩ ⟿ ⊥} or \texttt{e ⊢ ⟨ β ⟩ ⟿ ⊥} or there exists nodes
  \texttt{γ} and \texttt{φ} such that \texttt{e ⊢ ⟨ α ⟩ ⟿ ⟨ γ ⟩},
  \texttt{e ⊢ ⟨ β ⟩ ⟿ ⟨ φ ⟩} and \texttt{y ⊢ γ ⊏ φ}.
\end{thm}
\begin{proof}
  By Proposition \ref{prop:order-preserving-embedding} there are edits
  \texttt{f : ⟨ α ⟩ ⟿ u} and \texttt{g : ⟨ β ⟩ ⟿ v}, such that
  \texttt{e ⊢ f ⊏ g}.
  %
  By case analysis either \texttt{u = ⊥} or \texttt{v = ⊥} or \texttt{u = ⟨ γ ⟩}
  and \texttt{v = ⟨ Φ ⟩}. In the first (second) case \texttt{α} (\texttt{β}) is deleted and we are done.
  In the third case they are both updated, i.e.\ \texttt{e ⊢ ⟨ α ⟩ ⟿ ⟨ γ ⟩} and
  \texttt{e ⊢ ⟨ β ⟩ ⟿ ⟨ φ ⟩}.
  %
  By Proposition \ref{prop:order-preserving-target-fun} we deduce that
  \texttt{⟦ e ⟧ ⊢ γ ⊏ Φ} and by Requirement \ref{req:diff-specs} and
  Proposition \ref{prop:diff-correct} (requirements and specifications
  of \texttt{diff}) it follows that \texttt{y ⊢ γ ⊏ Φ}.
\end{proof}

We now generalize the \emph{order invariant} property to
\texttt{diff₃}, which guarantees that the relative order of edits in
each input script is preserved in the merged script.
%
Note that the property is restricted only to successful merges and
furthermore only to \emph{non-identity} edits, since they could 
ne be excluded in favor of proper changing edits otherwise.
%
The property holds intuitively because the merge algorithm does not
rearrange the input edits, but rather merge them pointwise, retaining
the original order in the merged script.
%
\begin{thm}[\texttt{diff₃} is OP]
  Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts such
  that \texttt{e₁ ⋎ e₂}, \texttt{e₃ = e₁ ⊔₃ e₂} and \texttt{e₃} does not
  contain conflicts.
%
  Let \texttt{f} and \texttt{g} be edits of type \texttt{u ⟿ v} and
  \texttt{w ⟿ z} such that \texttt{u ≢ v}, \texttt{w ≢ z} and
  \texttt{e₁ ⊢ f ⊏ g}, then \texttt{e₃ ⊢ₑ f ⊏ g}.
\end{thm}
  The theorem holds also with respect to the edits contained in \texttt{e₂}.

\section{Haskell}
\label{sec:haskell}
In this section we implement our generic algorithm in Haskell.  The
main reason to use Haskell over Agda is performance. 
%
Even though it does not feature full-fledged dependent types, the
Glasgow Haskell Compiler (GHC) \cite{GHC}, the current
state-of-the-art, optimizing compiler for Haskell, provides several
extensions to the type system, which allow to partially simulate
dependently typed programming.  
%
We will point out the shortcomings compared to the original version.
%

\subsection{Data  Representation}
In our model we used the abstract representation \texttt{F as a}
for a constructor of the algebraic data type \texttt{a} which takes
arguments \texttt{as}.
%
In our implementation we encode it as a Generalized Algebraic
Data Type (GADT), indexed by a list of types and a target type.
%
Each constructor of the algebraic data type is represented separately
by one of its constructor, which instantiates the first index with
the type of its arguments and the second with the resulting type.
%
For instance we encode the list constructors:
\begin{minted}{haskell}
data ListF (as :: [ * ]) (a :: *) where
  Nil :: ListF '[] [a]
  Cons :: ListF '[a , [a]] [a]
\end{minted}
In Haskell lists are automatically lifted to the type level and they
both share the same syntax, hence we put a tick to distinguish lifted
lists, kind \texttt{[ * ]}, from the list type, kind \texttt{*}.
%
Primitive types such as integer are also encoded in a similar data
type, but since they may assume many values, they are all combined in
a single constructor and the original value is retained.
\begin{minted}{haskell}
data IntF xs a where
  I :: Int → IntF '[] Int
\end{minted}

\subsection{Diffing}
Since \texttt{diff3} relies on \texttt{diff} we define a type class
for types that can be diffed.

\begin{minted}{haskell}
class Typeable a => Diff a where
  type FamilyOf a :: [ * ] → * → *
  toHTree :: a → HTree a
  fromHTree :: HTree a → a
  (=?=) :: F xs a → F ys a → Maybe (xs :~: ys)
  distance :: F xs a → F ys a → Double
\end{minted}
\todo{Better name for FamilyOf. It is not per family but per type}
The associated type family \texttt{FamilyOf a} returns the concrete
data type that represents the constructors of \texttt{a}.
%
The type synonym \texttt{F} is used to improve readability of signatures:
\begin{minted}{haskell}
type F xs a = (FamilyOf a) xs a
\end{minted}
\todo{You can also do it with another type class parameter and functional 
dependencies but it is worse in end.}
%
Methods \texttt{toHTree} and \texttt{fromHTree} are inverse functions
that embed a value into and from the generic representation.
% 
The universe used in the implementation corresponds precisely to that
of the model, except that it requires a \texttt{Diff} instance for
every child of a node.

\begin{minted}{haskell}
data HList xs where
  HNil :: HList []
  HCons :: Diff a => HTree a → HList as → HList (a : as)

data HTree a where
  Node :: F as a → HList as → HTree a
\end{minted}

This definition automatically ensures that the whole family of mutually recursive 
types have a \texttt{Diff} instance.
%
The method \texttt{(=?=)} checks equality between constructors of the 
same data type, and if so it returns a proof that their field types
are equal.
%
The superclass \texttt{Typeable} provides methods to inspect and
compare types.
%
When merging, constructors can be compared by
\texttt{(=?=)} only after establishing that they are both constructors
of the same data type. 
%
We use the method \texttt{eqT} from the \texttt{Typeable} superclass
of \texttt{Diff} for that:
\begin{minted}{haskell}
(=??=) :: (Diff a, Diff b) => F xs a → F ys b → Maybe (a :~: b)
_ =??= _ = eqT
\end{minted}
Note that the arguments are ignored and used exclusively to fix which
types must be compared.

The method \texttt{distance} represents a user-customizable distance function
between nodes, used in the \texttt{diff} algorithm's cost model.

\paragraph{Example}
We conclude by giving the \texttt{Diff} type class instance for lists and integers.

\begin{minted}{haskell}
instance Diff a => Diff [a] where	
  type FamilyOf [a] = ListF

  Nil =?= Nil = Just Refl
  Cons =?= Cons = Just Refl
  _ =?= _ = Nothing

  toHTree [] = Node Nil HNil
  toHTree (x : xs) = Node Cons (HCons (toHTree x) hs)
    where hs = HCons (toHTree xs) HNil

  fromHTree (Node Nil HNil) = []
  fromHTree (Node Cons (HCons t (HCons ts HNil))) 
    = fromHTree x : fromHTree ts
\end{minted} 
%
Note that after defining the associated type \texttt{FamilyOf} to be \texttt{ListF},
we can match constructors \texttt{Nil} and \texttt{Cons} in the other
methods and that the instance is polymorphic.

\begin{minted}{haskell}
instance Diff Int where
  type FamilyOf Int = IntF

  (I x) =?= (I y) = if x == y then Just Refl else Nothing
  
  toHTree x = Node (I x) HNil
  
  fromHTree (Node (I x) HNil) = x
\end{minted}
When applied to primitive types, method \texttt{=?=} needs to check that the
actual value is equal.

\paragraph{Edit Script}
The edit script data type is similar to that of Agda, with the only difference
that edit operations are not encoded in a separate data type, but are
inlined in it.

\begin{minted}{haskell}
data ES xs ys where
  End :: ES [] []
  Ins :: Diff a => F xs a → ES ys (xs :++: zs) → ES ys (a ': zs)
  Del :: Diff a => F xs a → ES (xs :++: ys) zs → ES (a ': ys) zs
  Upd :: Diff a => F xs a → F ys a → ES (xs :++: zs) (ys :++: ws) 
      → ES (a ': zs) (a ': ws)
\end{minted}
The original version cannot be encoded as it is in Haskell, due to the
limitations of the datatype promotion mechanism \cite{Yorgey12} and
the absence of pi-types.  Symbol \texttt{:++:} denotes type-level
append.  
%
Since there is no separate edit data type, we do not include a
no-operation edit in the script. 
%
We then discuss how we recover alignment in the implementation.

\paragraph{Algorithm}
A \texttt{diff} algorithm takes as input two objects and outputs an
edit script that reports the differences between them.
%
In particular GNU \texttt{diff} finds a \emph{minimal length} edit
script, or equivalently the \emph{longest common subsequence} of its
inputs \cite{Berg00, PierceDiff3}, that is a script which 
copies as many lines as possible.
%
Our \texttt{diff} algorithm is mostly an extension of that of
Lempsink's et al.\ therefore we present here only the principal
differences.  
%

\paragraph{Cost Model}
The original \texttt{diff} algorithm produces edit scripts
that contain only delete, insert and copy operations.
%
The original cost model is straightforward and assign cost 1 to every
edit, hence preferring copy edits over an equivalent insert and delete.
%
In this paper we have generalized copy to update, therefore we have to
adjust the cost model accordingly.

\begin{minted}{haskell}
cost : ES as bs → Dobule
cost (Del x e) = 1 + cost e
cost (Ins y e) = 1 + cost e
cost (Upd x y e) = distance x y + cost e 
cost End = 0
\end{minted}

The function \texttt{distance} computes the cost of an update between
constructors of the same type and it is expected to be a
\emph{metric}.

\begin{definition}[Metric]
\label{par:Metric}
A metric on a set A is a function
d : (A × A) → ${\rm I\!R}$ such that $\forall$ x, y, z $\in$ A:
	\begin{align*}
		d(x, y) &\geq 0 \quad &\mbox{\emph{{(non-negativity)}}}\\ 
		d(x, y) &= 0 \Leftrightarrow x = y \quad &\mbox{\emph{(coincidence axiom)}} \\		
		d(x, y) &= d(y, x) \quad &\mbox{\emph{(symmetry)}}\\
		d(x, z) &\leq d(x, y) + d(y, z) \quad &\mbox{\emph{(triangle inequality})}
	\end{align*}
	
\end{definition}
A reasonable distance function for algebraic
data type constructors is the \emph{discrete distance}:
	\[ d(x, y) = 
		\begin{cases} 
			0 \quad &\mbox{if } x = y \\
			1 \quad &\mbox {otherwise}		
		\end{cases} \]	
%

The binary operator \texttt{\_⨅\_} selects the edit script that minimizes \texttt{cost}.
\begin{minted}{agda}
(⨅) : ES as bs → ES as bs → ES as bs
e₁ ⨅ e₂ = if cost e₁ ≤ cost e₂ then e₁ else e₂
\end{minted}

We show a short, yet naive, version of the \texttt{diff} algorithm for simplicity,
furthermore we extend list syntax to heterogeneous lists for clarity:
\begin{minted}{haskell}
diff : DList as → DList bs → ES as bs
diff [] [] = End
diff [] (Node β ys₁ ∷ ys₂) = Ins β $ diff [] (ys₁ +++ ys₂)
diff (Node α xs₁ ∷ xs₂) [] = Del α $ diff (xs₁ +++ xs₂) []
diff (Node α xs₁ ∷ xs₂) (Node β ys₁ ∷ ys₂) =
  let d = Del α $ diff (xs₁ +++ xs₂) (Node β ys₁ ∷ ys₂) 
      i = Ins β $ diff (Node α xs₁ ∷ xs₂) (ys₁ +++ ys₂) in
    case α =??= β of
      Nothing → d ⨅ i
      Just Refl → d ⨅ i ⨅ u
        where u = Upd α β $ diff (xs₁ +++ xs₂) (ys₁ +++ ys₂)
\end{minted}
In the first case both input lists and the script is completed with
\texttt{End}.
%
In the second and third case one of the two lists is empty, hence the
algorithm inserts (deletes) each remaining node from the other list.
%
The third case, when both lists are non-empty, is the most
interesting.
%
Either the first node can be deleted, or the second node can be
inserted, or, if the nodes have the same target type, checked using
\texttt{=??=}, the first node can be updated with the second.
%
In each case the rest of the edit script is computed recursively,
prepending to either list the children of a node.
%
Lastly the script that minimizes the cost function is selected 
using \texttt{⨅}.
%
This version of the algorithm is naive because it is very inefficient,
since it contains several recursive calls that perform the same
sub-computations multiple times.
%
In our implementation we have employed memoization to achieve
practical performance \cite{Lemp09}.

We conclude with the entry point of our data type generic diff algorithm.
\begin{minted}{haskell}
gdiff : (Diff a, Diff b) => a → b → ES '[ a ] '[ b ]
gdiff x y = diff [ toHTree x ] [ toHTree y ] 
\end{minted}
The objects to be diffed are converted to the generic tree
representation and inserted in a singleton heterogeneous list, which
are then compared using \texttt{diff}.

\subsection{Merging}
Merging consists in diffing the base version with respect to each
new version, which produces two edit scripts that are combined
following the three-way merge technique. The merge may fail either
due to some conflict or because it generates an ill-typed 
script. 

\paragraph{Conflict}
The conflict data type encodes why it is not possible two merge two edits.

\begin{minted}{haskell}
data Conflict where
  InsIns :: (Diff a, Diff b) => F xs a → F ys b → Conflict
  UpdDel :: Diff a => F xs a → F ys a → Conflict
  DelUpd :: Diff a => F xs a → F ys a → Conflict
  UpdUpd :: Diff a => F xs a → F ys a → F zs a → Conflict
\end{minted}

Its type is much simpler compared to the model because of the
limitation in the data promotion mechanism, which prevents GADTs from
being indexed from other GADTs, in particular it is not indexed by the
base and new values.

\paragraph{Merged Script}
The \texttt{ES3 xs} data type represents a merged edit script, which
may contain conflicts.
\begin{minted}{haskell}
data ES3 xs where
  End3 :: ES3 '[] 
  Cnf3 :: Conflict → ES3 xs → ES3 ys
  Ins3 :: Diff a => F xs a → ES3 ys → ES3 ys
  Del3 :: Diff a => F xs a → ES3 (xs :++: ys) → ES3 (a ': ys) 
  Upd3 :: Diff a => F xs a → F ys a 
         → ES3 (xs :++: zs) → ES3 (a ': zs) 
\end{minted}
The script might be ill-typed with respect to the output list,
since nothing is enforced about the output types.
%
However the script is guaranteed to be well-typed with respect to the
source list, simplifying the type checking phase, which then has to
check the output types only.
%
The only exception is the constructor \texttt{Cnf3}, which does not
retain enough type information to maintain this property.
%
Likely this is not an issue: a script containing a conflict
is already ill-typed, according to the rules given in \ref{subsec:diff3-algo}.
%

\paragraph{Alignment}
Due to the lack of proper dependent types we cannot guarantee that
merge is called only on aligned scripts, therefore this condition is
checked at run-time.
%
The following auxiliary functions checks this condition and throws an
error otherwise.
\begin{minted}{haskell}
aligned :: (Diff a, Diff b) => F xs a → F ys b → (xs :~: ys , a :~: b)
aligned a b =
  case a =??= b of
    Just Refl →  
      case a =?= b of
        Just Refl → (Refl, Refl)
        _ → error "Scripts not aligned"
\end{minted}
Note that this check bears also some type equality, essential to
make the merge algorithm type check.

\paragraph{Algorithm}
Since no alignment proof is available, the merge algorithm needs to
check alignment every time two edits with a non-empty source value
needs to be merged.
As an example consider the update versus update case:
\begin{minted}{haskell}
merge3 :: ES xs ys → ES xs zs → ES3 xs
merge3 (Upd o x e1) (Upd o' y e2) =
  case aligned o o' of
    (Refl, Refl) →
      case (o =?= x, o' =?= y, x =?= y) of
        (Just (Refl, Refl), _, _) → Upd3 o y (merge3 e1 e2) -- Id1
        (_, Just (Refl, Refl), _) → Upd3 o x (merge3 e1 e2) -- Id2
        (_, _, Just (Refl, Refl)) → Upd3 o x (merge3 e1 e2) -- Idem
        (_, _, _) → Cnf3 (UpdUpd o x y) (merge3 e1 e2)
\end{minted}
Even though in the signature the two scripts share the same source list
\texttt{xs}, the two nodes \texttt{o} and \texttt{o'} might represent
different constructors with distinct arguments and types:
the alignment check guarantees that this is not the case.
%
The merging algorithm checks then whether either the first or the
second edit are actual copies or whether both of them update the nodes
in the same way, leading to a merge, or otherwise to an update
conflict.
%

\paragraph{Type Checking}
In our implementation the type checking phase either
yields a well-typed edit script or a list of type errors and conflicts
of the script. We omit its implementation for brevity:
\begin{minted}{haskell}
tyCheck :: ES3 xs → Either [Conflict] (WES xs)
\end{minted}
The auxiliary data type \texttt{WES} represents a well-typed edit script 
with source list \texttt{xs}.
\begin{minted}{haskell}
data WES xs where
  WES :: ES xs ys → WES xs
\end{minted}
Note that we need it, because we have to existentially quantify over the output
list \texttt{ys}.

We conclude by giving the interface of a data type generic \texttt{diff3} algorithm.
\begin{minted}{haskell}
gdiff3 :: Diff a => a → a → a → Either [Conflict] (ES '[ a ] '[ a ])
gdiff3 x o y = 
  let e = merge3 (diff o x) (diff o y) in
    case tyCheck e of 
     Left cs → Left cs
     Right (WES e') → hasRightTarget e'
\end{minted}
The new versions are diffed with the original version and their edit
scripts merged.  
%
Our formal model guarantees that scripts generated from the same source 
object are aligned, therefore we are ensured that \texttt{merge3} will not crash.
%
Conflicts are reported directly, while if the merged script is
well-typed we have to check that it does in fact generate an object of the
correct type.  The function \texttt{hasRightTarget}, omitted, takes
care of that.
 
\subsection{Example}
Interactive session with initial example revised.

\section{Discussion and Related Work}
\label{sec:related-work}
Research in the field of change detection and merge has produced a
variety of tools that address these problems.  Many focus on XML
files, such as LaDiff \cite{Chawathe96}, MH-Diff \cite{Chawathe97} and
3DM \cite{Lind01, Lind04, Lind05}.  We refer to Peters for a
comprehensive survey \cite{PetersSurvey}.
%
Other works address file and data synchronization, which raises
problems similar to those discussed in this paper. Relevant examples
include Unison, a file synchronizer \cite{Pierce98, UnisonSpec};
Harmony, a synchronizer for heterogeneous data
\cite{HarmonyOverview,Pierce07} and an algebra for file
synchronization \cite{Ramsey01}.
%
Lastly some mergers are tailored exclusively on software artifacts
\cite{Westfechtel91, Mens02, Apel11}. 

\paragraph{Ordered and Unordered Data} 
The merge algorithm presented in this paper works on algebraic data
types, which are strongly typed, tree-like, ordered objects. File
systems are usually hierarchical, but not inherently ordered, while
XML trees can also be unordered.
%
Schemas are used in Harmony to identify specific
conflicts (\emph{schema domain conflicts}), which would break their
structural invariants \cite{Pierce07}.
%
They play a role similar to types in this work, which we use to
type-check edit scripts.
%
Chawathe et al.\ assume that nodes have unique identifiers
\cite{Chawathe96}, which greatly simplifies the change detection
phase.
%
This assumption is inappropriate in our context because data formats
do not usually mark their content, furthermore even XML trees
might not have identifiers in their nodes.
	
\paragraph{Alignment and Data Structures} 
Alignment of corresponding parts plays a central role in when merging
two objects. 
%
In this work the alignment is \emph{global} and mainly determined by
\texttt{diff} \todo{Discuss alignment and diff in the Haskell
  section?} which computes the embedding of the source into the target
object, by minimizing an appropriate cost model.
%
GNU \texttt{diff3} aligns lines of texts dividing them in stable and
unstable \emph{chunks} based on the longest common subsequences
computed by \texttt{diff} \cite{PierceDiff3}.  
%
Overlapping equal lines are matched and fused in stable chunks,
leaving possibly conflicting chunks between them.
%
This technique works well when lines are mostly unique such as in
software artifacts.
%
We doubt that this technique would give good results in our context.
%
Firstly the basic values to be aligned are unlikely to be unique,
increasing the chances of misalignment.
%
Secondly such an aligner would not take into account the tree-like
structure of the data, possibly missing important matching.
%
Our aligner retains the structured nature of the data by preserving
the relative order of the nodes and strives to generate a proper
embedding by matching pairs of nodes and preferring updates
to a sequence of delete and insert.
%
The \emph{alignment} strategy has a profound impact when merging data
structures.
%
Harmony employs a \emph{local} strategy, that associates subtrees by
name, therefore it is able to merge correctly unordered collections
such as records and sets.
%
Our algorithm struggle with unordered data structures, 
because it will treat them as structured.
%
On the other hand Harmony performs poorly with lists, because
it \emph{align} them by absolute position.
%
For example merging \texttt{[1, 3]} with \texttt{[2]} and base 
\texttt{[1, 2]} surprisingly it gives \texttt{[2, 3]}, instead of
\texttt{[3]} as we do.
%
Chawathe and Molina reduce the change detection problem to the problem
of computing a minimum-cost edge cover of a bipartite graph
\cite{Chawathe96}.
%
Since this problem is NP-hard they employ an heuristic, consisting of
pruning rules, to find a \emph{minimal} edge cover.
			
\paragraph{Edit Operations} 
Edit operations are very important in a diffing algorithm, because
they determine how precisely changes in data can be detected, 
hence affecting the merging phase.
%
GNU diff employs insert, delete and copy in scripts only and updates
are imprecisely encoded as a delete followed by an insert.  Our
algorithm detects updates explicitly reducing the number of false
conflicts and raising more specific and informative true conflicts
(\texttt{UpdUpd}, \texttt{UpdDel}, \texttt{DelUpd}).
%
Some synchronizers employ also a \emph{move} edit operation
\cite{Lind04, Chawathe96, Chawathe97}.
In our algorithm and in Ramsey's \cite{Ramsey01}, move edits
are encoded by delete and insert, bearing the same 
drawbacks of an imprecise representation.
Move can improve the quality of diffs only if it is detected
with a fair confidence, therefore Lindholm takes into
account the \emph{context} of a node in order to improve the precision.
%
With respect to our work we remark that move edits would weaken 
the structural invariants guarantees and would probably 
complicate reasoning \cite{Ramsey01}.
	
\paragraph{Formal Model}
The semantics of merging algorithms employed in version control
systems, with the notable exception of Darcs \cite{HomoPatchTheory,
  CategoryPatchTheory} is not formalized, but it is usually understood
empirically, leading to severe misconceptions \cite{PierceDiff3}.
%
For instance it is in general hard to predict the outcome of complex
merges and determine whether a conflict is indeed due to or the
consequence of a bug.
%
Furthermore, even when merges are successful, they might produce
unexpected results, for instance duplicating lines or changing their
order.
%
This situation calls for a formalization of such merging algorithms.
%
Unison \cite{UnisonSpec} is an example of a file synchronizer
automatically derived from a formal model \cite{Pierce98}.
%
In this paper we have presented several properties of our algorithms,
inspired by the work from Pierce et al.\ in Harmony
\cite{HarmonyOverview}.
%
Ramsey and Csirmaz proposes an algebraic approach to file
synchronization \cite{Ramsey01}. 
%
Differently from our work their synchronizer is
\emph{operation-based}, rather than \emph{state-based}, i.e.\ it does
not rely uniquely on the current states of the replicas, but it
requires to track the operations that changed them.
%
They give a proof system for a simple filesystem algebra,
and prove that it is sound and complete.
%
% The model is based on a relation between sequences of commands that
% ensures that a sequence safely approximates another and conflictless
% synchronization is possible if there is a sequence at least as good as
%both.
%
However the system is quite large, for only five operations it
consists of about fifty laws, to the point that it requires automatic
techniques to prove it sound.
%
On the other hand our model is instead concise and straightforward
to analyze.
%
% The 3DM tool devised by Lindholm does not include a mechanically
% verified model and moreover the general merge rules have been derived
% analyzing the expected result of use cases \cite{Lind04}.  His change
% model is based on \emph{content} and \emph{structural change}. The
% changes in each version are combined into a change set and can be
% merged only if the set is \emph{consistent}, i.e.  unambiguously
% determine at most one parent, predecessor and successor for each node.
% Conflicts are divided in core conflicts and optional conflicts and are
% overall consistent with those listed in \ref{subsec:Merge}, except for
% the delete/edit conflict, which is optional, whereas in this thesis is
% not. It is not explained under which circumstances these changes could
% be considered compatible.  The lack of a formal model raises some
% doubts about the properties claimed for the merge.  First of all the
% merge is considered symmetric, but later it is admitted that appends
% of nodes originated from different trees may be accepted in either
% order. This kind of implementation details are actually relevant from
% the user point of view and have so far fostered the need for formal,
% unambiguous models. In this thesis inserts compete for matching
% positions and may trigger conflicts if incompatible.  Secondly the
% fourth merge rule explicitly requires that changes in either versions
% to be included in the merged tree, however the fact that updates in
% deleted trees are optionally considered conflicts contradicts this
% rule and weaken the property about preservation of edits.

\section{Conclusion}
\label{sec:conclusion}

% \appendix
% \section{Appendix Title}

% This is the text of the appendix, if you need one.

% \acks

% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.
\bibliography{svc}

% \softraggedright


% \end{thebibliography}

\listoftodos

\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices


%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex -shell-escape
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End: 

