%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------

\documentclass{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{hyperref}


% \DeclareTextCommand{\nobreakspace}{T1}{\leavevmode\nobreak\ }
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{microtype}

\usepackage{minted} % Code listing with reasonable good highlighting
%\usepackage{bussproofs}   % For typing judgments
\usepackage[no-math]{fontspec}
\setmainfont{Times New Roman}
\setmonofont[Scale=MatchLowercase]{Apple Symbols} % Unicode mono font

\usepackage{array}
\setlength{\extrarowheight}{1.5pt}

\usepackage[dvipsnames]{xcolor}  		% Color package
\definecolor{dgreen}{rgb}{0.,0.6,0.}    % Deep green
\usepackage{caption}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny,disable]{todonotes}	% todos

% Figures with border
\usepackage{float}
%\floatstyle{boxed} 
\restylefloat{figure}

\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{fancyvrb}

% Definitions for unicode characters not included
\usepackage{newunicodechar}                   
\newunicodechar{ᶜ}{$^c$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ᵗ}{$^t$}
\newunicodechar{ˢ}{$^s$}

\usepackage{pifont}
\newunicodechar{✗}{\ding{55}}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathpartir} % typing rules

\theoremstyle{plain}
\newtheorem{definition}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{cor}{Corollary}
\newtheorem{req}{Requirement}

\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}

% Drawings
\usepackage{tikz}
\usepackage{tikz-qtree}

\newcommand{\nil}{\textcolor{blue}{\texttt{[]}}}
\newcommand{\cons}{\texttt{(\textcolor{blue}{∷})}}
\newcommand{\num}[1]{\textcolor{magenta}{\texttt{#1}}}

\usepackage{graphicx}
\graphicspath{ {images/} }

% % Balancing in the bibliography
% \usepackage{lastpage}
% \makeatletter
%     \def\balanceissued{unbalanced}%flag to indicate if \balance has been used
%     \let\oldbibitem\bibitem
%     \def\bibitem{%
%         \ifnum\thepage=\lastpage@lastpage%
%             \expandafter\ifx\expandafter\relax\balanceissued\relax\else%
%                 \balance%
%                 \gdef\balanceissued{\relax}\fi%
%             \else\fi%
%         \oldbibitem}
% \makeatother

\usepackage{flushend}
%\usepackage{balance}

\begin{document}
\toappear{}
\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

% \vspace{-2mm}
% \conferenceinfo{TyDe'16} {September 18 2016, Nara, Japan}
% \copyrightyear{2016} 
% \copyrightdata{978-1-4503-4435-7/16/09} 
% \doi{2976022.2976026}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusiveo license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Generic Diff3 for Algebraic Datatypes}
%\subtitle{Subtitle Text, if any}

\authorinfo{Marco Vassena}
           {Chalmers University, Sweden}
           {vassena@chalmers.se}

\maketitle

\begin{abstract}
  %
  Many version control systems, including Git and Mercurial, rely on
  \texttt{diff3} to merge different revisions of the same file.
  %
  More precisely, \texttt{diff3} automatically merges two text files
  given a common base version, comparing them line by line and raising
  conflicts when the changes made are irreconcilable.
  %
  The program ignores the actual structure of the data stored in the
  files, hence it might generate spurious conflicts, which must be
  manually resolved by the user.
  %
  In this paper, we present a state-based, three-way, persistent,
  data-type generic \texttt{diff3} algorithm whose increased precision
  in detecting changes reduces the number of false conflicts raised
  and improves its merging capabilities.
  %
  We have implemented the algorithm in Agda, a proof assistant with
  dependent types, and developed a model to reason about ``diffing''
  and merging.
  %
  We have formalized sanity properties and specifications of
  \texttt{diff3} and proved that our algorithm meets them.
  %
  Furthermore, we have identified the minimal conditions under which
  the merging algorithm raises a conflict and established a structural
  invariant preserved.
  %\todo{Improve conclusion?}
 %
  % We have implemented our algorithm in Haskell in order to make our results
  % practical and employed advanced type-system features to retain a 
  % fair amount of type safety.
  %\todo{Abstract Conclusion?}
\end{abstract}

\category{D.1.1}{Programming Techniques}{Applicative (Functional) Programming.}
%{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
Algorithms.\

\keywords
Diff3, Dependent types, Datatype-generic programming.

\section{Introduction}
\label{sec:intro}
Version control systems, such as Git \cite{Git} and Mercurial
\cite{Mercurial}, are used in the software industry, as well as in the
open source community and by researchers all over the world to develop
software.
%
These tools track all the changes in the source code throughout its
development, making it possible to quickly roll back to any previous
version and allow different developers to work separately on the same
project.
%
Version control systems provide these features by means of two
algorithms, called \texttt{diff} and \texttt{diff3}.
%
The former detects changes in source code files, while the latter
merges independent changes made to the code base, allowing
simultaneous development.
%
These algorithms are line-based, i.e.\ they compare files line by
line, therefore they can be used on any text-based file, not
exclusively on software artifacts.
%
Unfortunately, their line-granularity limits their precision when
detecting changes, which consequently deteriorates their merging
capabilities.
%
In this paper, we develop a fine-grained data-type generic version of
the \texttt{diff} and \texttt{diff3} algorithms, that improve their
applicability and whose increased precision in detecting changes
reduces the number of spurious conflicts raised and produces more
accurate true conflicts.

\paragraph{Example}
We show the shortcomings of line-based \texttt{diff} and
\texttt{diff3} algorithms by means of an example.  
%
The Comma Separated Values file format (CSV) is a simple text-based
encoding of data stored in tables. %b \cite{csv}.
%
In a CSV file, every line represents a row of the table and commas
separate values in different columns, within each row.
%
For instance, file \texttt{a.csv} encodes a $3 \times 3$ table
containing numbers from 1 to 9.
\begin{figure}[!h]
\centering
\begin{minipage}{.15\textwidth}
{  \centering
  \begin{verbatim}
  $ cat a.csv
  1,2,3
  4,5,6
  7,8,9
  \end{verbatim}\par
}
\end{minipage}%
\begin{minipage}{.15\textwidth}
{  \centering
  \begin{tabular}{ | c | c | c | }
    \hline
    1 & 2 & 3 \\ \hline
    4 & 5 & 6 \\ \hline
    7 & 8 & 9  \\ \hline
  \end{tabular}\par
}
\end{minipage}%
\end{figure}

Imagine that two users are simultaneously working on this table.
The first user adds a column filled with zero and saves the new table in \texttt{b.csv}:
\begin{figure}[h]
\centering
\begin{minipage}{.15\textwidth}
  \centering
\begin{Verbatim}[commandchars=\\\{\}]
  $ cat b.csv
  \textcolor{blue}{0},1,2,3
  \textcolor{blue}{0},4,5,6
  \textcolor{blue}{0},7,8,9
\end{Verbatim}
\end{minipage}%$
\begin{minipage}{.15\textwidth}
  \centering
  \begin{tabular}{ | c | c | c | c | }
    \hline
    \textcolor{blue}{0} & 1 & 2 & 3 \\ \hline
    \textcolor{blue}{0} & 4 & 5 & 6 \\ \hline
    \textcolor{blue}{0} & 7 & 8 & 9  \\ \hline
  \end{tabular}
\end{minipage}%
\end{figure} 

The second user changes some values in the third column and saves the new table in  \texttt{c.csv}:
\begin{figure}[h]
\centering
\begin{minipage}{.15\textwidth}
  \centering
  \begin{Verbatim}[commandchars=\\\{\}]
  $ cat c.csv
  1,2,3
  4,5,\textcolor{magenta}{9}
  7,8,\textcolor{magenta}{15}
  \end{Verbatim}
\end{minipage}% $
\begin{minipage}{.15\textwidth}
  \centering
  \begin{tabular}{ | c | c | c | }
    \hline
    1 & 2 & 3 \\ \hline
    4 & 5 & \textcolor{magenta}{9} \\ \hline
    7 & 8 & \textcolor{magenta}{15} \\ \hline
  \end{tabular}
\end{minipage}%
\end{figure}

The two users would like to synchronize their work now and decide to
use \texttt{diff3} to merge their versions.
%
They have modified \emph{independent} parts of the table, therefore
they are confident that it should be possible to automatically
merge the changes, without incurring a conflict.
%
Unfortunately, since \texttt{diff3} is a line-based algorithm, it
compares files line by line, without considering the actual structure
of the data stored in the files. 
%
As a result, the algorithm fails to merge the two tables and raises
spurious conflicts.
%
In particular, \texttt{diff3} employs the \emph{three-way-merge}
technique to compare and merge the corresponding lines of three files.
%
The following table shows the result of applying this technique to the
previous tables:
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\texttt{b} & \texttt{a} & \texttt{c} & \texttt{diff3 b a c} \\ \hline
\texttt{\textcolor{blue}{0},1,2,3} & \texttt{1,2,3} & \texttt{1,2,3} & \textcolor{dgreen}{\texttt{0,1,2,3}} \\ \hline
\texttt{\textcolor{blue}{0},4,5,6} & \texttt{4,5,6} & \texttt{4,5,\textcolor{magenta}{9}} & \textcolor{red}{✗}  \\ \hline
\texttt{\textcolor{blue}{0},7,8,9} & \texttt{7,8,9} & \texttt{7,8,\textcolor{magenta}{15}} & \textcolor{red}{✗} \\ \hline
\end{tabular}
\end{center}
If there is at most one different version of the same line, as it
happens in the first row, a merge is possible.
%
Instead, if the same line is different in all the three versions,
which is the case in the second and third row, a conflict is
triggered.
%


\paragraph{Discussion}
The main limitation of \texttt{diff} and \texttt{diff3} is that they
operate on data representation with a \emph{fixed} precision,
consisting of one line of text, therefore disregarding completely any
information about the actual structure of the data.
%
If they were aware of the table structure, consisting of columns and
rows, then \texttt{diff} could exactly represent the differences in
each version and \texttt{diff3} could automatically merge them, as the
users expected:
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\textcolor{blue}{0} & 1 & 2 & 3 \\ \hline
\textcolor{blue}{0} & 4 & 5 & \textcolor{magenta}{9} \\ \hline
\textcolor{blue}{0} & 7 & 8 & \textcolor{magenta}{15} \\ \hline
\end{tabular}
\end{center}

% Obviously we do not want to implement format specific \texttt{diff} and \texttt{diff3} algorithms, since this would hinder reusability, but instead
% they manipulate data directly, assuming that parsers and serializers for it are available. Furthermore we would like our algorithms to be as reusable as possible, with data of any possible shape.

\subsection{Contributions}
In this paper we make the following contributions:
\begin{itemize}
%In Section \ref{subsec:edit-script}, 
\item We define a type-safe edit script data 
      type that represents the differences between two objects, using
      \emph{delete}, \emph{insert} and \emph{update} edits.
      %
      We use the edit script data type to give formal specifications
      of a \texttt{diff} algorithm, making our results independent 
      from the specific algorithm used.
      % algorithm in terms of the edit script data type.
      % that  In Section 
%      \ref{subsec:diff-algo}, we give the 
%In Section \ref{subsec:merge-semantics}, 
    \item We formalize the \emph{three-way-merge} strategy and give a
      precise semantics of \emph{mergeable} and \emph{conflicting}
      edits. 
% We give the formal specifications of a \texttt{diff3}
%       algorithm in terms of our edit semantics.
%In Section \ref{subsec:diff3-algo}, we
    \item We implement a data type generic, three-way \texttt{diff3}
      algorithm, based on our merge and conflict semantics and study
      its formal properties.
% in Section \ref{sec:properties}.
\end{itemize}
We have implemented these algorithms using generic programming
techniques in Agda, a programming language with dependent types and a
proof assistant \cite{Bove09}.
%
Dependent types are particularly convenient in this setting to
idiomatically encode the pre-conditions and post-conditions of our
algorithms and ultimately verify their properties.
%
We have then put our model into practice by efficiently implementing
our algorithms in Haskell \cite{Marlow_haskell2010}.
%
% In Section \ref{sec:haskell}, we point out the shortcomings and
% compromises that we had to make when moving from a language with 
% dependent types to a less expressive one.
%
The source code containing \texttt{diff} and \texttt{diff3}
algorithms, their properties and formal proofs are available
online\footnote{https://github.com/marco-vassena/gdiff3}.  For the
sake of presentation, we have simplified the code presented in this
paper, for instance by hiding implicit arguments and universe levels.
%
This paper is organized as follows.
%
Section \ref{section:universe} describes the universe used by our
generic algorithms, Section \ref{sec:generic-diff} introduces the
basic definitions of edit and type-safe edit script, Section
\ref{sec:generic-diff3} introduces the semantics of merge and conflict
and gives a \texttt{diff3} algorithm based on it. Section
\ref{sec:properties} studies the formal properties of the algorithm
and Section \ref{sec:haskell} revisits the motivating example using
the contributions from the introduction.  Section
\ref{sec:related-work} gives related work and Section
\ref{sec:conclusion} concludes.

\section{Universe}
\label{section:universe}
Data type generic algorithms work on a generic representation of
algebraic data types.
%
The universe used in this paper consists of typed heterogeneous rose
trees, a combination of mutually recursive heterogeneous lists and
trees, whose \emph{nodes} correspond to data type constructors and
their children to their fields.

\paragraph{Constructors}
Type \texttt{C as a} denotes a constructor of an algebraic data type
of type \texttt{a}, that takes arguments of types given in list
\texttt{as}.
%
For instance constructor \texttt{True} is represented by type \texttt{C []
  Bool}, because it takes no arguments and produces a boolean
value.
%
Note that also polymorphic data types are supported by this
representation, for example, constructor \texttt{Just} is represented
by type \texttt{C [a] (Maybe a)} for any type \texttt{a}.
%
In the following, we will leave type \texttt{C as a} abstract, as a
module parameter, together with a decidable heterogeneous equality
operator\footnote{In Agda, \texttt{Set} is the kind of simple types
  and \texttt{List Set} is the type of a list containing simple
  types.}.

\begin{minted}{agda}
module Diff3 (C : List Set → Set → Set) 
              (_≟_ : (α : C as a) (β : C bs b) → Dec (α ≅ β)) where
\end{minted}
In Section \ref{sec:haskell}, we show how to concretely implement this
representation.

\paragraph{Well-Typed Rose Trees}
Data type \texttt{HTree a} is a tree-like data structure that
represents a value of an algebraic data type of type \texttt{a}.
\begin{minted}{agda}
  data HTree : Set → Set where
    Node : C as a → HList as → HTree a
\end{minted}
%
Data type \texttt{HList as} collects the children of a node, i.e. the
arguments of constructor \texttt{C as a}, each encoded as a typed
tree.
%
\begin{minted}{agda}
  data HList : List Set → Set where
    [] : HList []
   _∷_ : HTree a → HList as → HList (a ∷ as)
\end{minted}
%
This representation is type-safe because the constructor
\texttt{C} and the heterogeneous list share the same index
\texttt{as}, therefore denoting a well-typed application of a
constructor to its arguments.
% 

\paragraph{Example}
List \texttt{[1,2]} is encoded in this universe as:
\begin{Verbatim}[commandchars=\\\{\}]
ht : HTree (List Int)
ht = Node \cons [Node \num{1} [], Node \cons [Node \num{2} [], Node \nil []]]
\end{Verbatim}
Terms\texttt{ }\cons \texttt{ : C [Int, List Int] (List Int)}
and\texttt{ }\nil \texttt{ : C [] (List Int)} denote the cons
constructor and the empty list constructor respectively, specialized
without loss of generality to \texttt{List Int}.
%
In our examples we automatically lift numbers to node constructors,
that is \num{1}, \num{2} \texttt{ : C [] Int}.
%
We graphically depict objects encoded in this universe as trees:

\begin{figure}[h]
\centering
\Tree
[.{\cons}
   [.{\num{1}} ]
   [.{\cons} [.{\num{2}} ] [.{\nil} ]]
]
\end{figure}
	
% \todo{Move later?}
% In the following we will use two auxiliary functions to append and
% split heterogeneous lists:
% \begin{minted}{agda}
% _+++_ : HList as → HList bs → HList (as ++ bs)
% \end{minted}
	
\section{Generic diff}
\label{sec:generic-diff}
Our \texttt{diff3} algorithm relies on a \texttt{diff} algorithm, used
as a subroutine to compare the input objects and merge them.
%
The algorithm detects differences between two heterogeneous lists
given as input producing an edit script, whose edit operations
progressively transform one into the other.
%
More precisely, an edit script is a list of edits, that either insert,
delete, or replace nodes of the input objects.
%
We firstly describe a simply typed version of edit and edit script
data types and then refine them to guarantee type-safety.

\subsection{Edit Operations}
An edit operation is a mapping \texttt{u ⟼ v}, where \texttt{u} and
\texttt{v} are called \emph{source} and \emph{target} value
respectively.
%
A value is an optional node, i.e.  \texttt{Value as a = Maybe (C as
  a)}. 
%
For brevity, we write \texttt{∅} for an empty value and \texttt{⟨ α ⟩}
for a value containing node \texttt{α}.
% 
All the possible combinations of source and target value state, i.e.\
empty and non-empty, form four different edit operations.
\begin{minted}{agda}
data _⟼_ : Value as a → Value bs a → Set where
  Nop : ∅ ⟼ ∅
  Del : (α : C as a) → ⟨ α ⟩ ⟼ ∅
  Ins : (α : C as a) → ∅ ⟼ ⟨ α ⟩
  Upd : (α : C as a) (β : C bs a) → ⟨ α ⟩ ⟼ ⟨ β ⟩
\end{minted}
The \texttt{Nop} edit is a no-operation, that will be
used in Section \ref{subsec:alignment}, to \emph{align} edit scripts.
%
Edit \texttt{Del α} deletes node \texttt{α} ---since it lacks a target
node, it is mapped to the empty value \texttt{∅},
%
Similarly, edit \texttt{Ins α} inserts node \texttt{α}, which
lacks a source node, hence it has the empty value \texttt{∅} 
as source value.
%
Edit \texttt{Upd α β} updates source node \texttt{α} with target node
\texttt{β}.
%
It concretely represents a constructor change, because \texttt{α} and
\texttt{β} belong to the \emph{same} type \texttt{a}, but take possibly
different arguments \texttt{as} and \texttt{bs}.
%
Note that there is no explicit copy edit: it is just a special case of
update, in which the source and target nodes happen to be the same.
%
Edits that have the same \emph{source} and \emph{target} value are
called \emph{identity} edits---they have type \texttt{v
  ⟼ v}.
%
Node copy and no-operation fall into this category.
%
Even though the edit data type, as it is here defined, is not space
efficient, because it might store the same node twice, it is more
suitable for reasoning and leads to a more elegant merge and conflict
semantics.
%
% \todo{An implementation should take care of this. Do we?}
	
\subsection{Untyped Edit Script}
\label{subsec:edit-script}
An edit script is a finite list of edit operations, that describe how
to transform a \emph{source} object into a \emph{target} object.
%
\begin{minted}{agda}
data ES : Set where
  [] : ES
  _::_ : v ⟼ w → ES → ES
\end{minted}	
%
More precisely, the script processes the nodes of the objects by
traversing them in \emph{depth-first pre-order}.
%
Note however that we do not transform plain trees, but rather
\emph{lists} of trees, which are used as \emph{stacks} of unprocessed
nodes, pushed and popped according to the edit operations contained in
the script.
%
We work with lists of trees because certain edits, when applied to
nodes in a tree, will intrinsically result in multiple trees.
%
For instance, deleting the root node of tree \texttt{ht}, from Section
\ref{section:universe}, produces two trees (\texttt{Node
  \textcolor{magenta}{1} []} and \texttt{Node (\textcolor{blue}{::})
  [Node \textcolor{magenta}{2} [], Node \textcolor{blue}{[]} []]}):

\begin{figure}[h!]
\centering
  \begin{minipage}{.15\textwidth}
  \centering
    \Tree
    [.{\num{1}} ]
  \end{minipage}%
% 
\begin{minipage}{.15\textwidth}
  \centering
    \Tree
    [.{\cons} [.{\num{2}} ]     
    [.{\nil} ]]
\end{minipage}%
\end{figure}

%
Informally, a delete (insert) edit pops the root of the tree from the
top of the \emph{source} (\emph{target}) stack and pushes its children
instead.
%
An update behaves as a simultaneous delete and insert and a
no-operation leaves both stacks unchanged.
%
\paragraph{Example}
The following script encodes the differences between two lists of
integers, namely \texttt{[0]} and \texttt{[1,2]}:
\begin{Verbatim}[commandchars=\\\{\}]
e : ES
e = [Upd \cons \cons, Upd \num{0} \num{1}, Ins \cons, Ins \num{2}, Upd \nil \nil]
\end{Verbatim}
The \emph{source} and \emph{target} stacks initially contain a single
element each, i.e. the tree representation of \texttt{[0]} and
\texttt{[1,2]} respectively.
\begin{figure}[h!]
\centering
[
  \begin{minipage}{.15\textwidth}
  \centering
    \Tree
    [.{\cons} [.{\num{0}} ]     
    [.{\nil} ]]
  \end{minipage}%
%
] \hspace{.10\textwidth} [ 
\begin{minipage}{.15\textwidth}
  \centering
\Tree
[.{\cons}
   [.{\num{1}} ]
   [.{\cons} [.{\num{2}} ] [.{\nil} ]]
]
\end{minipage}%
]
\end{figure}

The first edit (\texttt{Upd \cons\ \cons}) pops the root node of the
top tree in each stack and pushes their children, producing the
following stacks:
\begin{figure}[h!]
\centering
[
  \begin{minipage}{.075\textwidth}
  \centering
    \Tree
    [.{\num{0}} ]
  \end{minipage}%
,
  \begin{minipage}{.075\textwidth}
    \centering
    \Tree [.{\nil} ]
  \end{minipage}%
] \hspace{.075\textwidth} [ 
  \begin{minipage}{.075\textwidth}
  \centering
    \Tree [.{\num{1}} ]
  \end{minipage}%
,
  \begin{minipage}{.075\textwidth}
  \centering
     \Tree [.{\cons} [.{\num{2}} ] [.{\nil} ]]
  \end{minipage}%
]
\end{figure}

Observe that the next node to be consumed in each stack is the root
node of the leftmost children ---nodes are processed in
\emph{depth-first pre-order}.
%
The following edits progressively consume the remaining nodes, until
the stacks are both empty.

%
In principle, it should be possible to define functions that retrieve
the source and target objects from a script, by replaying the edit
script and \emph{inverting} the process that we have just described.
%
The type of these functions should take an edit script and produce an
heterogeneous list, representing the stack of trees, that is \texttt{ES →
  HList ?}.
%
Unfortunately, we run into problems: what type should we put instead of
the question mark?
%
Crucially, an untyped edit script does not guarantee that its
operations will produce well-typed trees and not even that they can be
performed at all.
%
For instance, the top of the stack might contain trees of the wrong
type, that do not match those of the constructor at hand, or an edit
might try to pop trees from an empty stack.
%
Consider, for example, edit script \texttt{[Ins (\textcolor{blue}{::})
  , Ins \textcolor{magenta}{0}]}, which generates a target list
containing an ill-typed tree, whose root node lacks a second child:
\begin{figure}[!h]
\centering
\Tree
[.\texttt{(\textcolor{blue}{::})}
   [.\texttt{\textcolor{magenta}{0}} ]
]
\end{figure}

%
Preventing invalid operations, such as a pop from an empty stack, and
maintaining invariants is the bread and butter of dependently-typed
programming, as we proceed to show in the next section.

\subsection{Type-Safe Edit Script}
In order to make edit scripts type-safe, we refine the \texttt{Value}
data type to correctly track the type of the trees popped and pushed
on a stack with its indexes.
%
Then, we make \texttt{ES} an indexed data type and take advantage of
the the annotations on scripts and values to ensure type-safety.

\paragraph{Value}
Given a source (target) value of type \texttt{Value as a}, an edit
will pop trees of types \texttt{as} from the source (target) stack and
push a tree of type \texttt{a} instead, if and only if a node is in
fact present, otherwise the corresponding stack will be left
unchanged.
%
Contrary to the previous version of \texttt{Value as a}, the following
indexed data type correctly approximate inputs and outputs,
\emph{regardless} of the presence of the node.
\begin{minted}{agda}
data Value : List Set → List Set → Set where
  ∅ : Value [] []
  ⟨_⟩ : C as a → Value as [ a ] 
\end{minted}
Observe that also the second index is a list and that both of them are
empty for the empty value.
%

\paragraph{Edit Script}
The edit script data type is still a list of edits, but now it is
indexed with two lists of types, used to restrict the shape of the
source and target stacks that may be processed by each edit operation.
%
\begin{minted}{agda}
data ES : List Set → List Set → Set where
  [] : ES [] []
  _::_ : {v : Value as bs} {w : Value cs ds} → v ⟼ w → 
          ES (as ++ xs) (cs ++ ys) → ES (bs ++ xs) (ds ++ ys)
\end{minted}	
An edit script of type \texttt{ES xs ys} transforms a \emph{source}
list of type \texttt{HList xs} into a \emph{target} list of type
\texttt{HList ys}.  
%
The cons constructor takes an edit, whose source (target) value
consumes trees of type \texttt{as} (\texttt{cs}) and yields trees of
type \texttt{bs} (\texttt{ds}).
%
The rest of the script is indexed by lists that have prefix
\texttt{as} and \texttt{cs}, hence ensuring that it will be possible
to pop trees of the right type from its source and target object
respectively, and replace them by constructing and pushing well-typed
trees of types \texttt{bs} and \texttt{ds}.
%
Note that this invariant holds regardless of the specific edit at
hand, precisely because we have refined the type of \texttt{Value}.
%
For example if edit \texttt{v ⟼ w} is a no-operation, nodes \texttt{v}
and \texttt{w} are \texttt{∅}, hence lists \texttt{as}, \texttt{bs},
\texttt{cs} and \texttt{ds} are all empty: nothing is popped and
nothing is pushed (\texttt{[] ++ xs = xs} and \texttt{[] ++ ys = ys})
on the source and target lists.
%
If the edit is a delete, i.e. \texttt{⟨ α ⟩ ⟼ ∅}, with \texttt{α : C
  as a}, the target stack is left unchanged, while \texttt{as} are
popped from the source stack (\texttt{as ++ xs}) and a new tree
constructed with \texttt{α} is pushed (\texttt{[ a ] ++ xs}).
%
Insert and update work in a similar fashion, therefore we omit further
details.

%
With more precise types, we can define \emph{source} function
\texttt{⟪\_⟫}, which retrieves the source object from an edit script:

\begin{minted}{agda}
⟪_⟫ : ES as bs → HList as
⟪ [] ⟫ = []
⟪ Nop ∷ e ⟫ = ⟪ e ⟫
⟪ Del α ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
⟪ Ins α ∷ e ⟫ = ⟪ e ⟫
⟪ Upd α β ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
\end{minted}
%
Source nodes are present in delete and update edits ---the other cases
are trivial.
% 
Function \texttt{hsplit : HList (as ++ bs) → HList as × HList bs}
splits an heterogeneous list in two parts according to its type and it
is used to \emph{pop} the arguments (\texttt{hs₁}) of the source
constructor (\texttt{α}), from the rest of the list.
%
Note that the type of the cons constructor guarantees that the tree
\texttt{Node α hs₁} is well-typed.
%
Dually, we define the \emph{target} function, whose implementation is
analogous and thus omitted:
\begin{minted}{agda}
⟦_⟧ : ES as bs → HList bs
\end{minted}

\begin{figure*}[!t]
\centering
\includegraphics[scale=.25]{embedding2}
\caption{The embedding induced by \texttt{[Upd \cons \cons, Upd \num{0} \num{1}, Ins \cons, Ins \num{2}, Upd \nil \nil]}}
\label{fig:embedding}
\end{figure*}

\paragraph{Discussion}
Invalid scripts, such as \texttt{[Ins \cons , Ins \num{0}]}, are now
ill-typed.
%
In particular, edit \texttt{Ins \cons} cannot be
prepended to script \texttt{[Ins \num{0}] : ES [] [Int]},
because the target index has not the right shape, i.e. \texttt{[Int] ≠
  [Int, List Int] ++ ys}.
%
Well-formed edit scripts, such as that of the previous example can
still be constructed.
\begin{Verbatim}[commandchars=\\\{\}]
e : ES [List Int] [List Int]
e = [Upd \cons \cons, Upd \num{0} \num{1}, Ins \cons, Ins \num{2}, Upd \nil \nil]
\end{Verbatim}
Figure \ref{fig:embedding} shows that script \texttt{e} embeds nodes of 
the source object \texttt{[0]} into those of the target object \texttt{[1,2]}.
%
Finding a ``good'' embedding is the goal of \texttt{diff}.

\subsection{Diff Algorithm}
\label{subsec:diff-algo}
Our \texttt{diff3} algorithm does not merge objects directly, but like
its text-based counterpart, relies on a \texttt{diff} algorithm
as a subroutine to detect changes between them.
%
More precisely, a \texttt{diff} algorithm takes two objects and produces
an edit script that describes the differences between them, which is
then used to compute the merged object by \texttt{diff3}.
%
We remark that our \texttt{diff3} algorithm and its formal guarantees,
do not rely on a specific \texttt{diff} algorithm, but rather are
valid with any function of type \texttt{diff : HList as → HList bs →
  ES as bs} that fulfills the following basic requirement.

\begin{req}[\texttt{diff} specifications]
  \label{req:diff-specs}
  A \texttt{diff} algorithm is correct if and only if for any list
  \texttt{x} and \texttt{y} \center{\texttt{e = diff x y ⇔ x ≡ ⟪ e ⟫ ∧
      y ≡ ⟦ e ⟧}}
\end{req}
%
This correctness criterion requires \texttt{diff} to produce a script
that transforms exactly the source object \texttt{x} into the target
object \texttt{y}.  (In the specifications \texttt{≡} denotes
propositional equality.)
%
Note that the specification is very permissive: it does not require 
the edit script to be minimal, not even ``small''.
%
Even though we expect our \texttt{diff3} algorithm to perform better
with high-quality \texttt{diff}s ---they will probably capture changes
more precisely, the advantage of reasoning by such specification is
that our results are still valid with virtually any \emph{sensible}
\texttt{diff} algorithm.
%
% The following data type serves to this purpose: \texttt{Diff x y e} is
% the proof that the edit script \texttt{e} is the result of diffing
% lists \texttt{x} and \texttt{y}.
% \begin{minted}{agda}
% data Diff : HList xs → HList ys → ES xs ys → Set where
%   End : Diff [] [] []
%   Nop : Diff x y e → Diff x y (Nop ∷ e)
%   Del : Diff (x₁ +++ x₂) y e → Diff (Node α x₁ ∷ x₂ ) y (Del α ∷ e)
%   Ins : Diff x (y₁ +++ y₂) e → Diff x (Node β y₁ ∷ y₂) (Ins β ∷ e)
%   Upd : Diff (x₁ +++ x₂) (y₁ +++ y₂) e → 
%         Diff (Node α x₁ ∷ x₂) (Node β y₁ ∷ y₂) (Upd α β ∷ e)
% \end{minted}
% We prove that \texttt{Diff x y e} complies with the specifications of
% \texttt{diff} (Requirement \ref{req:diff-specs}), because \texttt{x}
% and \texttt{y} are uniquely determined by respectively the source and
% target function applied on \texttt{e}, as the following result shows.
% \begin{prop}[\texttt{Diff} is correct]
% \label{prop:diff-correct}
% Let \texttt{x} and \texttt{y} be heterogeneous lists and \texttt{e} an edit script, then
% \center{\texttt{Diff x y e ⇔ x ≡ ⟪ e ⟫ ∧ y ≡ ⟦ e ⟧}}
% \end{prop}
In our implementation we employ a generalization of Lempsink's
\texttt{diff} algorithm \cite{Lemp09}, which we have proved to meet
Requirement \ref{req:diff-specs}.
% \begin{minted} {agda}
% diff-suff :  (x : HList xs) (y : HList ys) → Diff x y (diff x y)
% \end{minted}

\section{Generic diff3}
\label{sec:generic-diff3}
The \texttt{diff3} algorithm takes as input three objects, the
original version called \emph{base} and two new replicas, and it
outputs an edit script that combines the changes between them.
%
However, the algorithm does not work directly on the replicas, but
relies on a \texttt{diff} algorithm to compute two edit scripts that
describe the changes from base to each of the new versions.
%
It then generates an edit script by merging the edits contained in
edit scripts: the \emph{source} of the merged script is the base
object and the \emph{target} is the merged object.
%
Nevertheless, edits cannot always be automatically reconciled.  When
this happens, a conflict is detected and reported to the user, who has
to manually merge the conflicting changes.
%
% \todo{More discussion about different design choices, persistent etc
%   ...}		
% \todo{Remark that the three-way technique is attractive and we simply
%   want to apply it to structured data. Maybe in intro?}
%
The merging strategy employed in our \texttt{diff3} algorithm for
algebraic data types consists in applying the \emph{three-way merge}
technique at the node level.
%
Informally, the algorithm compares corresponding parts of two objects
and of their base version, when two parts disagree, the base version
is examined: a conflict is detected if each version is different,
otherwise the version that changed from base is chosen.
	
To put this strategy on a formal footing, we give precise definitions
of corresponding parts of objects and conflicts, on top of which, we
define a sound merging semantics.

\subsection{Alignment}
\label{subsec:alignment}
%
\emph{Alignment} is a relation used to pinpoint the corresponding
parts of two objects, which should be merged together.
%
Merging unrelated parts is likely to fail, resulting in spurious
conflicts, or produce unexpected results, therefore alignment affects
immensely the precision and reliability of \texttt{diff3}.
%
In this framework, \emph{edits} are suitable candidates to identify
these parts, because they relate source values that belong to the same
object (\emph{base}), with target values that belong to different
replicas, which are to be merged.
%
More formally, we define \emph{alignment} as follows.
\begin{definition}[Edit and Script Alignment]
\mbox{}
\label{def:align}
\begin{itemize}
  \item Two edit operations are aligned, if and only if they have the same source value.
  \item Two edit scripts are aligned, if and only if their edits are
    pairwise aligned.
\end{itemize}
\end{definition}
Note that Definition \ref{def:align} aligns edits according to their
source \emph{values}, rather than nodes, so that insert and
no-operations may also be aligned: any two edits of type \texttt{u ⟼
  v} and \texttt{u ⟼ w} are aligned.
%	
Intuitively, two edit scripts that have the same \emph{source} object
can be aligned, because they share the same collection of
\emph{source} nodes.
%
However, insert edits may break alignment, because they can occur at
any point in the scripts, introducing \emph{empty} values.

\paragraph{Example}
Consider the lists \texttt{x = [1]}, \texttt{y = [0,1]} and \texttt{z
  = [1,2]}.
%
Edit scripts \texttt{e₁} and \texttt{e₂} represent the \texttt{diff}
between \texttt{x} and \texttt{y} and \texttt{z}
respectively\footnote{In this example \texttt{Cpy α} stands for \texttt{Upd α α}}.
\begin{minted}{agda}
e₁ e₂ : ES [ List Int ] [ List Int ]
e₁ = [Ins  (::), Ins  0, Cpy (::), Cpy 1, Cpy []]
e₂ = [Cpy (::), Cpy 1, Ins  (::), Ins  2, Cpy []] 
\end{minted}       
%
% \begin{minted}{agda}
% e₁ e₂ : ES [ List Int ] [ List Int ]
% e₁ = [Ins (::), Ins 1, Cpy (::), Cpy 1,                 Cpy []]
% e₂ = [                Cpy (::), Cpy 1, Ins (::), Ins 2, Cpy []] 
% \end{minted}       
The edit scripts \texttt{e₁} and \texttt{e₂} are \emph{not} aligned, because
their first edits are not, namely \texttt{∅ ≢ ⟨ :: ⟩}, where
\texttt{∅} is the source value of \texttt{Ins (::)} in \texttt{e₁} and
\texttt{⟨ :: ⟩} is the source value of \texttt{Cpy (::)} in
\texttt{e₂}.

Interestingly, alignment can be recovered by inserting no-operation
edits in these points.
\begin{minted}{agda}
e₁* = [Ins (::), Ins 0, Cpy (::), Cpy 1, Nop   , Nop , Cpy []]
e₂* = [Nop   , Nop , Cpy (::), Cpy 1, Ins (::), Ins 2, Cpy []] 
\end{minted}

In the following, we use notation \texttt{e ⊑ e*} to denote that edit
script \texttt{e*} extends script \texttt{e} with a finite number of
\texttt{Nop} edits.
%
Observe that, \texttt{Nop} edits changes neither the \emph{source} nor the
\emph{target} of the edit script, therefore it is an harmless
extension.
\begin{prop}[Equivalent Extension]
  If \texttt{e ⊑ e*}, then it holds that \texttt{⟦ e ⟧ ≡ ⟦ e* ⟧} and
  \texttt{⟪ e ⟫ ≡ ⟪ e* ⟫}
\end{prop}

Proposition \ref{prop:align-ext} guarantees that we can always
align scripts that have the same source object, by extending them
with no-operations.
%
As a result, we can systematically apply this technique in
\texttt{diff3}.
%
\begin{prop}[Alignment via Extension]
\label{prop:align-ext}
  Let \texttt{e₁ = diff x y} and \texttt{e₂ = diff x z}, then there
  exists edit scripts \texttt{e₁*} and \texttt{e₂*}, such that
  \texttt{e₁ ⊑ e₁*}, \texttt{e₂ ⊑ e₂*}, and \texttt{e₁*} and
  \texttt{e₂*} are aligned.
\end{prop}
Adding no-operations operations to align scripts is effective, because
\texttt{Nop} always aligns with \texttt{Ins} --- they both have the
empty value \texttt{∅} as source.
%
Furthermore, it is also innocuous, because no-operations cannot
introduce new conflicts, since they are \emph{identity} edits.


%         \paragraph{Weak Alignment}\todo{Drop weak alignment, give only Proposition}
%         Two edit scripts are \emph{weakly aligned} \texttt{e₁ \textasciitilde\ e₂} 
%         if they admit extensions that are \emph{aligned}:
% \begin{minted}{agda}
% data _~_ (e₁ : ES xs ys) (e₂ : ES xs zs) : Set where
%   WA : e₁ ⊴ e₁* → e₂ ⊴ e₂* → e₁* ⋎ e₂* → e₁ ~ e₂
% \end{minted}

%         We can now weakly align two edit scripts, that share the
%         same \emph{source} object. The alignment procedure examines the scripts
%         and extend either of them with no-operations, whenever one inserts a 
%         node and the other does not. 
% \begin{minted}{agda}
% align : Diff x y e₁ → Diff x z e₂ → e₁ ~ e₂
% \end{minted}

\subsection{Semantics of Merge and Conflict}
\label{subsec:merge-semantics}
We formalize the three-way merge technique, by defining a sound
semantics of merge and conflict over aligned edits.
%
Two aligned edits contain at most three distinct values: one common
source and two, possibly different, targets, which are treated as
corresponding parts.  
%
If no more than two of them are different, it is possible to merge the
edits, producing an edit that combines both.
%
However, if the values are all different, then there is no edit that
comprises both edits: any edit would leave out at least one of them.
%
When this happens, three-way merge refuses to back out any edit, but
fails and triggers a conflict instead.
%
This property is called \emph{persistence} and will be discussed in
more detail in Section \ref{subsec:persistence}.
%

	
\paragraph{Merge}
Data type \texttt{f ⊔ g ↧ h} represents the semantics of merge:
it is the proof that merging aligned edits \texttt{f} and \texttt{g}
succeeds, producing the edit \texttt{h}.
\begin{minted} {agda}
data _⊔_↧_ : (v ⟼ a) → (v ⟼ b) → (v ⟼ c) → Set where
  Id₁ : (f : v ⟼ v) (g : v ⟼ w) → f ⊔ g ↧ g
  Id₂ : (f : v ⟼ w) (g : v ⟼ v) → f ⊔ g ↧ f
  Idem : (f : v ⟼ w) → f ⊔ f ↧ f
\end{minted}
Observe that the type of the three edits in the declaration guarantees
that this judgment is defined only on aligned edits and that also the
resulting edit must share the same source value.
%
Each constructor represents a distinct axiom that justifies why the
merge is possible and determines the merged target value, i.e.
instantiates \texttt{c} with either \texttt{a} or \texttt{b}.
%
Rules \texttt{Id₁} and \texttt{Id₂} apply when respectively the
first and the second transformation is an \emph{identity} edit.
%
Similarly to the three-way merge algorithm, when one version is
unchanged the other is chosen.
%
The fact that merging is an \emph{idempotent} operation motivates the
third rule (\texttt{Idem}): it applies when the same edit is performed
independently on the same source value.
%
This merging semantics is compelling because it is minimal, it
contains only three axioms, yet complete because it can encode every
true merge, even though it does not mention any specific edit.

\paragraph{Conflict}
A conflict occurs when two edits perform irreconcilable changes.  
%
Data type \texttt{Conflict u v w} represents the cause of
a conflict, that may arise from merging aligned edits \texttt{u ⟼ v}
and \texttt{u ⟼ w}.
%
We omit the full declaration for brevity, but we briefly describe its
constructors.
%
Conflicts \texttt{InsIns β γ} and \texttt{UpdUpd α β γ}, of type
\texttt{Conflict ∅ ⟨ α ⟩ ⟨ β ⟩} and \texttt{Conflict ⟨ α ⟩ ⟨ β ⟩ ⟨ γ
  ⟩}, denote conflicting insertions and updates respectively.
%
They resemble those detected by line-based \texttt{diff3}, which
encodes proper updates as a deletion followed by an insertion.
%
Conflict \texttt{DelUpd α β} of type \texttt{Conflict ⟨ α ⟩ ∅ ⟨ β ⟩},
is a new form of conflict, that stems from the fact that these two
edits are in general irreconcilable ---conflict \texttt{UpdDel α β} is analogous.
%
Data type \texttt{f ⊔ g ↥ c} represents the semantics of conflict: it
is the proof that edits \texttt{f} and \texttt{g} cannot be merged and
raise conflict \texttt{c}.
\begin{minted}{agda}
data _⊔_↥_ : (u ⟼ v) → (u ⟼ w) → Conflict u v w → Set where
  Cnf : (f : u ⟼ v) (g : u ⟼ w) → u ≢ v → v ≢ w  → u ≢ w → 
        (c : Conflict u v w) → f ⊔ g ↥ c
\end{minted}
The three inequalities attest that all the values involved are
different from each other, ensuring that the edits are actually
incompatible and may not be merged otherwise. 
%
If \texttt{u ≡ v} the first edit would be an \emph{identity} edit,
which can always be merged by \texttt{Id₁}. Similarly if \texttt{u ≡
  w} the second edit could be merged by \texttt{Id₂}. Lastly if
\texttt{v ≡ w} the edits \texttt{f} and \texttt{g} would perform the
same change and could be merged applying the \texttt{Idem} rule.
%
Given these inequalities the corresponding conflict is uniquely
determined, i.e. for any concrete choice of \texttt{u}, \texttt{v} and
\texttt{w} that are all different, the conflict \texttt{c} is uniquely
determined.
%
As a result, also the semantics of conflict is minimal, because it
contains only one axiom, yet complete, because it can encode all true
conflicts.

\paragraph{Properties}
We now show some fundamental properties of the semantics of merge and
conflict, which are useful in our formalization.
        %
Firstly, we prove that the semantics is sound, i.e.\ merge and
conflict are \emph{mutually exclusive}.
\begin{prop}[Mutually Exclusive]
  \label{prop:mutually-exclusive}
  If \texttt{f ⊔ g ↧ h}, then there exists no conflict \texttt{c} such
  that \texttt{f ⊔ g ↥ c}.
\end{prop}
Secondly we prove \emph{determinancy} of the semantics relations.
\begin{prop}[Determinancy]
\mbox{}
\label{prop:determinancy}
\begin{itemize}
\item If \texttt{f ⊔ g ↧ h₁} and \texttt{f ⊔ g ↧ h₂}, then \texttt{h₁
    ≡ h₂}.
%
\item  If \texttt{f ⊔ g ↥ c₁} and \texttt{f ⊔ g ↥ c₂}, then \texttt{c₁ ≡ c₂}.
\end{itemize}
\end{prop}
Now that we have established that our semantics is sensible we define
a function to merge edits.

\paragraph{Merge Operator}
For every pair of aligned edits \texttt{f} and \texttt{g}, binary
operator \texttt{⊔} either provides a suitable edit \texttt{h} and
provide a proof that \texttt{f ⊔ g ↧ h}, or detects a conflict
\texttt{c}, with a proof that \texttt{f ⊔ g ↥ c}.
        
\begin{minted}{agda}
_⊔_ : (f : u ⟼ v) (g : u ⟼ w) →
        (∃ λ c → f ⊔ g ↥ c) ⊎ (∃ λ h → f ⊔ g ↧ h)
\end{minted}
Operator \texttt{⊔} is outlined in Table \ref{table:merge}, where we
have omitted the obvious inequalities in conflicts.
%
Operator \texttt{⊔₃} merges \emph{aligned} edit scripts\footnote{We
  extend edit script with a special constructor \_::ᶜ\_ for
  conflicts}, by applying operator \texttt{⊔} pairwise, i.e.\
\texttt{e₁ ⊔₃ e₂ = zipWith (⊔) e₁ e₂}.
 
%

	\begin{table*}[t!]
	\centering
	\begin{tabular}{| c | c | c |}
	\hline
	\texttt{f : u \textasciitilde> v} & \texttt{g : u \textasciitilde> w} &  \texttt{f ⊔ g} 
	\\ \hline
	\texttt{Nop} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ Nop g}} 
	\\ \hline
	\texttt{Upd α α} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ (Upd α α) g}} 
	\\ \hline
	\texttt{f} & \texttt{Nop} & \textcolor{Green}{\texttt{Id₂ f Nop}} 
	\\ \hline
	\texttt{f} & \texttt{Upd α α} & \textcolor{Green}{\texttt{Id₂ f (Upd α α)}} 
	\\ \hline
	\texttt{Del α} & \texttt{Del α} & \textcolor{Green}{\texttt{Idem (Del α)}}
	\\ \hline
	\texttt{Del α} & \texttt{Upd α β} & \textcolor{Red}{\texttt{Cnf (Del α) (Upd α β) (DelUpd α β) }}
	\\ \hline
	\texttt{Upd α β} & \texttt{Del α} & \textcolor{Red}{\texttt{Cnf (Upd α β) (Del α) (UpdDel α β)}}
	\\ \hline
	\texttt{Ins α} & \texttt{Ins α} & \textcolor{Green}{\texttt{Idem (Ins α)}} 
	\\	\hline
	\texttt{Ins α} & \texttt{Ins β} & \textcolor{Red}{\texttt{Cnf (Ins α) (Ins β) (InsIns α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α β} & \textcolor{Green}{\texttt{Idem (Upd α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α γ} & \textcolor{Red}{\texttt{Cnf (Upd α β) (Upd α γ) (UpdUpd α β γ)}}
	\\ \hline
	\end{tabular}
	
	\captionsetup{singlelinecheck=false, justification=centering}

	\caption{Implementation of merge operator. \\
	 \texttt{f ⊔ g :} \textcolor{Red}{\texttt{f ⊔ g ↥ c}} \texttt{⊎} \textcolor{Green}{\texttt{f ⊔ g ↧ h}}}	 
	\label{table:merge}
	\end{table*}

% 	\paragraph{Merged Edit Script}
% 	Just like we defined a merge operator for aligned edits, we need to 
% 	define a similar operator for aligned edit scripts.
% 	However, since single merges may fail this operator cannot return 
% 	the same well-typed edit script, that we have defined before.
% 	Therefore, we introduce an alternative edit script, which is only partially 
% 	well-typed and that can include conflicts.
% \begin{minted}{agda}
% data ES₃ : List Set → Set where
%   [] : ES₃ []
%   _∷_ : {u : Val as bs} → u ⟼ v → ES₃ (as ++ xs) → ES₃ (bs ++ xs)
%   _∷ᶜ_ : {u : Val as bs} → (c : Conflict u v w) → 
%              ES₃ (as ++ xs) → ES₃ (bs ++ xs)
% \end{minted}
% 	The data type is indexed only by the source type list and it is well-typed
% 	only with respect to it. Furthermore, it provides an additional constructor
% 	for conflicts. 

        \subsection{Diff3 Algorithm}
        \label{subsec:diff3-algo}
% 	The merge operator for edit scripts takes two aligned edit scripts and
% 	applies the merge operator \texttt{⊔} previously defined to
% 	each pair of aligned edits. It builds a merged edit script choosing a 
% 	suitable constructor depending on the outcome of each single merge.
%         \todo{Define this as zipWith (⊔) e1 e2}
% \begin{minted}{agda}
% merge₃ : {e₁ : ES as bs} {e₂ : ES as cs} → e₁ ⋎ e₂ → ES₃ as
% merge₃ nil = []
% merge₃ (cons f g p) with f ⊔ g
% merge₃ (cons f g p) | inj₁ (c , _) = c ∷ᶜ merge₃ p
% merge₃ (cons f g p) | inj₂ (h , _) = h ∷  merge₃ p
% \end{minted}
% 	To improve readability we will use the following infix
%         operator:
% \begin{minted}{agda}
% _⊔₃_ (e₁ : ES as bs) (e₂ : ES as cs) {{p : e₁ ⋎ e₂}} → ES₃ as
% _⊔₃_  _ _ {{p}} = merge₃ p
% \end{minted}
% 	The alignment proof is passed  as an instance argument, i.e. a
%         special  type  of  implicit arguments  that  is  automatically
%         resolved at call-sites \cite{Devriese11}.

%         In order to reason about merging, we encode the specifications
%         of the merge operator in data type \texttt{Merge₃}:

% % \begin{figure*}[t!]
% % \centering
% \todo{Drop Merge3}
% \begin{minted}{agda}
% data Merge₃ : ES xs ys → Es xs zs → ES₃ xs → Set where
%   nil : Merge₃ [] [] []
%   merge : f ⊔ g ↧ h → Merge₃ e₁ e₂ e₃ → 
%                    Merge₃ (f ∷ e₁) (g ∷ e₂) (h ∷ e₃)
%   conflict : f ⊔ g ↥ c → Merge₃ e₁ e₂ e₃ → 
%                     Merge₃ (f ∷ e₁) (g ∷ e₂) (c ∷ᶜ e₃)
% \end{minted}
% \caption{Merge operator specification}
% \label{fig:merge3}
% \end{figure*}

%         We now prove that our merge operator fulfills its requirements.
% \begin{prop}[\texttt{⊔₃} is correct]
% \label{prop:merge3-correct}
% Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts such that,
% \texttt{e₁ ⋎ e₂}, then:
% \center{\texttt{e₃ ≡ e₁ ⊔₃ e₂ ⇔ Merge₃ e₁ e₂ e₃}}
% \end{prop}
% \begin{proof}
% The if direction follows by induction on \texttt{e₁ ⋎ e₂}.
% The iff direction follows by induction on \texttt{Merge₃ e₁ e₂ e₃} and 
% relies on properties \ref{prop:mutually-exclusive} and \ref{prop:determinancy}.
% \end{proof}
        
        % Now that we have shown that the merge operator is in a
        % one-to-one relationship with the specification data type, we
        % will use the latter to reason more conveniently about its
        % properties.

	% \paragraph{Diff3}
	We conclude this Section giving a generic \texttt{diff₃}
        algorithm for typed trees.
        %
        % We follow the conventional interface, in which the second
        % argument is considered \emph{base}:
\begin{minted}{agda}
diff₃ : HTree a → HTree a → HTree a → Conflicts ⊎ HTree a
diff₃ y x z with align (diff [ x ] [ y ]) (diff [ x ] [ z ])
... | (e₁* , e₂*) = typecheck (e₁* ⊔₃ e₂*)
\end{minted}
	Following the conventional interface, the second argument
        \texttt{x} is considered the \emph{base} version, therefore it
        is diffed against \texttt{y} and \texttt{z}, using a
        \texttt{diff} algorithm that meets Requirement
        \ref{req:diff-specs}.
        %
        Function \texttt{align} aligns the edit scripts obtained by
        diffing the base version with the new versions, extending them
        with \texttt{Nop} operations.
        %
        The call to this function is \emph{sound}, because those edit
        scripts share the same \emph{source} list \texttt{[ x ]}.
        %
        Edit scripts \texttt{e₁*} and \texttt{e₂*} are aligned by
        Proposition \ref{prop:align-ext} and are merged by operator
        \texttt{⊔₃}.
        %
        We now proceed to explain the non-standard function
        \texttt{typecheck}.
        %
        
\paragraph{Type Checking}
A merged edit script must be type-checked to ensure that it actually
produces a \emph{target} object, that is well-typed.
%
Clearly, a conflict makes a script ill-typed, because the \emph{target}
value is undefined.
%
Surprisingly enough a conflict-free edit script may still be
ill-typed.
%
This is counter-intuitive because the two input edit scripts are
singularly well-typed and one might expect that, without conflicts,
their fusion should also be well-typed.
%

\paragraph{Example} Consider for instance the following \emph{aligned}
edit scripts:
\begin{minted}{agda}
e₁ e₂ : ES [] [List Int]
e₁ = [Ins [], Nop]
e₂ = [Nop, Ins []]
\end{minted}
The merge operator \texttt{e₁ ⊔₃ e₂} yields script \texttt{[Ins [],
  Ins []]}, which is conflict-free, yet ill-typed, because the first
insert produces a constructor that does not take any arguments, but
the tail of the script yields another empty list as argument.
%
The culprit is that operator \texttt{⊔₃} merges edits \emph{pairwise},
therefore the whole merged script may alternatively follow either of
the input scripts.
%
There is no guarantee that this pattern actually retains type-safety:
the script must be explicitly type-checked!
%
The typing judgment \texttt{e ⇓ as} states that the edit script
\texttt{e} is well typed and produces a list of type \texttt{HList
  as}.
%
The typing rules are straightforward and a trivial inference algorithm
can be read off them.
\begin{mathpar}
          \inferrule
          {}
          {\texttt{[] ⇓ []}}
          \and
          \inferrule
          {\texttt{f : v ⟼ w} \\ 
           \texttt{w : C cs ds} \\
           \texttt{e ⇓ cs ++ ys}}
          {\texttt{f ∷ e ⇓ (ds ++ ys)}}
\end{mathpar}
%
% Note
% Even though merging might succeed without triggering any conflict the
% merged edit script might be invalid, i.e.\ it will not produce a
% well-typed object as \emph{target}.
%         %
        
%   Moreover note that the conflict cons constructor (\texttt{∷ᶜ})
% is not mentioned in the typing rules, therefore edit scripts
% containing conflicts are ill-typed.  Edit scripts of type \texttt{ES₃}
% can be converted to \texttt{ES}, if they are well typed:
% \begin{minted}{agda}
% ⌜_⌝  : (e : ES₃ xs) → {{q : e ⇓ ys}} → ES xs ys
% \end{minted}

\paragraph{Discussion}
While \texttt{diff} is type-safe, i.e.\ it always produces a
well-typed edit script, it is quite disappointing that we cannot make
\texttt{diff3} type-safe, not even in absence of conflicts and with
dependent-types available.
%
The problem becomes evident in the type of the merge operator
\texttt{⊔₃ : ES xs ys -> ES xs zs -> ES xs ?}, what type should we put
instead of the question mark?
%
If \texttt{ys ≡ zs}, like inside \texttt{diff3}, the question is
trivial, but otherwise there is no ``right'' type.
%
An arbitrary choice, that is either \texttt{ys} or \texttt{zs}, is
unsatisfactory, because it makes the algorithm asymmetric: we would
expect \texttt{e₁ ⊔₃ e₂} to produce the same result as \texttt{e₂ ⊔₃
  e₁}, but the two scripts have even different types!
%
An existential type, i.e. \texttt{∃ ws . ES xs ws} is too ``general''.
In order to add an edit, say \texttt{Ins α}, with \texttt{α : C as a},
list \texttt{ws} should have prefix \texttt{as}, i.e.\ \texttt{ws ≡ as
  ++ ws'}, but \texttt{ws} is just \emph{some} list.
%
Unfortunately, we acknowledge that our \texttt{diff3} algorithm may
fail in yet another way, besides proper conflicts, that is by
producing an ill-typed script.

\section{Properties}
\label{sec:properties}
%
The multitude of works in change detection and data reconciliation
\cite{Pierce98, Ramsey01, UnisonSpec, PetersSurvey, Pierce07, Mens02,
  Chawathe96} shows that a variety of different design choices are
possible, when implementing diffing and merging algorithms, each
leading to fundamental differences and tread-offs between precision,
performance and reliability.
%
In this section we present and motivate our design choices, while in
Section \ref{sec:related-work}, we discuss and compare them with
possible alternatives.
%
We show that our algorithms meet these choices, by defining properties
that clearly describe their semantics.
%
We remark that we have formalized and mechanically verified these
properties in Agda, using the model presented in this paper.
%
In the following, we will write \texttt{f ∈ e} and \texttt{c ∈ e} to
denote that edit \texttt{f} and conflict \texttt{c} occurs in script
\texttt{e} respectively and \texttt{α ∈ hs} if node \texttt{α}
occurs in list \texttt{hs}.
%
Furthermore, we consider only edit-related conflicts \texttt{c :
  Conflict u v w}.
  
\subsection{Conflict Conditions}
The semantics of widespread merging algorithms, such as GNU
\texttt{diff3} is not mathematically formalized, but it is rather
understood empirically, and sometimes even largely misunderstood, due
to incorrect intuitions \cite{PierceDiff3}.
%
As a result, users often struggle to predict the outcome of complex
merge operations and end up facing unexpected conflicts.
%
The following property document precisely sufficient and necessary
conditions, that will trigger a conflict in a merge.
%
\begin{thm}[Conflict Conditions]
\label{thm:conflict-conds}
  Given objects \texttt{o}, \texttt{x}, \texttt{y}, 
  then \texttt{diff3 x o y} raises a conflict \texttt{c} if and only if
  there are two aligned edits \texttt{f} and \texttt{g}, such that
  \texttt{f ∈ (diff o x)}, \texttt{g ∈ (diff o y)}, and \texttt{f ⊔ g ↥ c}.
\end{thm}
Informally, Theorem \ref{thm:conflict-conds} asserts that merging
results in a conflict uniquely if there are two edits that are
\emph{aligned} and \emph{conflicting}.
%
The conflict and merge semantics, described in Section
\ref{subsec:merge-semantics} makes Theorem very intuitive and easy to
prove, but this does not diminish its importance.
%
For instance, a direct consequence of Theorem \ref{thm:conflict-conds}
is a sound \emph{locality} principle for \texttt{diff3}, which
guarantees that modifying independent, i.e. \emph{unaligned}, parts,
will not trigger any conflict.
%
Note that the same principle in GNU \texttt{diff3}, has been only
recently clarified and precisely formalized \cite{PierceDiff3}.

\subsection{Sanity Conditions}
The properties discussed in this section act as sanity conditions,
ensuring that \texttt{diff} and \texttt{diff3} behave properly.
%
Firstly, the \emph{data origin} property ensures that \texttt{diff}
processes every node of the input objects and only those, i.e.\ it
does not ``make up'' nodes.
%
Intuitively nodes are atomic blocks that cannot be modified, but
either inserted, replaced or discarded as a whole, ensuring users that
their data may not corrupted in the diffing process.
%
Secondly, the \emph{edit origin} property gives further guarantees
about the semantics of merge, namely that there is at least one script
accountable for every edit found in a merged script ---both scripts
may bear the same change independently (axiom \texttt{Idem}).
%
%
%We start with some auxiliary definitions and lemmas.
% Firstly we give some auxiliary definitions that will be used to
% state and prove
% this properties.
%     \paragraph{Membership}
%     The type \texttt{α ∈ hs} denotes that the node \texttt{α} is present
%     in the list of trees \texttt{hs}.

% \begin{minted}{agda}
% data _∈_ : C xs a → HList ys → Set where
%   here : (α : C as a) → α ∈ Node α hs₁ ∷ hs₂
%   there : α ∈ (hs₁ +++ hs₂) → α ∈ Node β hs₁ ∷ hs₂
% \end{minted}
%     A similar data type denotes the presence of an edit in a script.
% \begin{minted}{agda}
% data _∈ₑ_ : v ⟼ w → ES xs ys → Set where
%   here : (f : v ⟼ w) → f ∈ₑ f ∷ e
%   there : f ∈ₑ e → f ∈ₑ g ∷ e
% \end{minted}
    % Lastly the judgment \texttt{e ⊢ₑ u ⟼ v} denotes that
    % the script \texttt{e} contains some edit of type \texttt{u ⟼ v}.
% \% begin{definition}[Edit Mapping]
% An edit script \texttt{e} maps source value \texttt{u} into
% target value \texttt{v}, written \texttt{e ⊢ u ⟼ v}, if and
% only if there is an edit \texttt{f : u ⟼ v} such that \texttt{f ∈ e}.
% \end{definition}

% I think I will skip this one and directly state the more interesting one
% \begin{minted}{agda}
%    ∀   f : ⟨ α ⟩ ⟼ v  .  f ∈ₑ e   ⇒   α ∈ ⟪ e ⟫
%    ∀   f : v ⟼ ⟨ α ⟩  .  f ∈ₑ e   ⇒   α ∈ ⟦ e ⟧
% \end{minted}

% The following property shows that in an edit script a source (target)
% node is correctly part of the source (target) object.
% %
% In other words the source function \texttt{⟪\_⟫} and target function
% \texttt{⟦\_⟧} do not forget any node.
% \begin{prop}[\texttt{⟪\_⟫} and \texttt{⟦\_⟧} are correct]
% \label{prop:source-target-cmp}
% Given an edit script \texttt{e} and a node \texttt{α} then.
% If \texttt{e ⊢ ⟨ α ⟩ ⟼ v} then \texttt{α ∈ ⟪ e ⟫}.
% Similarly if \texttt{e ⊢ v ⟼ ⟨ α ⟩} then \texttt{α ∈ ⟦ e ⟧}.
% \end{prop}
We now formally state the \emph{data origin} and \emph{edit origin} property.
\begin{prop}[Data and Edit Origin]
\label{prop:sanity}
Let \texttt{α} be a node and \texttt{e = diff x y}:
\begin{itemize}
\item \texttt{α ∈ x} iff there exits \texttt{f : ⟨ α ⟩ ⟼ v}, such that
  \texttt{f ∈ e}.
\item \texttt{α ∈ y} iff there exits \texttt{f : v ⟼ ⟨ α ⟩}, such that
  \texttt{f ∈ e}.
\item If \texttt{f ∈ (e₁ ⊔₃ e₂)} then either \texttt{f ∈ e₁} or
  \texttt{f ∈ e₂}.
\end{itemize}
\end{prop}

% \begin{proof}
%   It follows directly from Requirement \ref{req:diff-specs} and Proposition
%   \ref{prop:diff-correct} (requirements and specifications of
%   \texttt{diff}) and Proposition \ref{prop:source-target-cmp}.
% \end{proof}

% We now formally state the \emph{data retention} property.
% \begin{prop}[Data Retention]
% \label{prop:data-retention}
%   Let \texttt{x} and \texttt{y} be two heterogeneous lists, let
%   \texttt{e = diff x y} and let \texttt{α} be a node.
% %
%   If \texttt{α ∈ x} then there is a target value \texttt{v} such that
%   \texttt{e ⊢ ⟨ α ⟩ ⟼ v}.
% %
%   Similarly if \texttt{α ∈ y} then there is a source value \texttt{v} such that
%   \texttt{e ⊢ v ⟼ ⟨ α ⟩}.
% \end{prop}
% \begin{proof}
%   It follows from Requirement \ref{req:diff-specs} and Proposition
%   \ref{prop:diff-correct} (requirements and specifications of
%   \texttt{diff}) and by induction on \texttt{α ∈ x}.
% \end{proof}
 
% We give now similar safety properties for our \texttt{diff₃}
% algorithm.
% We firstly discuss \emph{edit origin}, a generalization of
% \emph{data origin}
% that ensures that every edit present in the merged script comes from
% either
% of the input scripts.

Unfortunately, the properties proved in Proposition \ref{prop:sanity}
are not enough to characterize a useful merge algorithm.
%
Crucially, \emph{edit origin} asserts that, if an edit is presented in
the merged script, then it is part of either the input scripts, but it
does not guarantee that any edit from the input scripts will actually
end up in the merged script.
%
A merge operator that merely returns an empty script (i.e.\ \texttt{e₁ ⊔₃ e₂
  = []}) would satisfy this property, but clearly it not very useful.
%
Proposition \ref{prop:maximality} proves \emph{maximality}, which
forces the merge operator to yield every edit that can be obtained
by merging aligned edits from the input scripts.

\begin{prop}[Maximality]
  \label{prop:maximality}
  For every pair of aligned edit scripts \texttt{f} and \texttt{g},
  such that \texttt{f ∈ e₁}, \texttt{g ∈ e₂}, if \texttt{f ⊔ g ↧ h}
  then \texttt{h ∈ (e₁ ⊔₃ e₂)}.
\end{prop}

\subsection{Persistence}
\label{subsec:persistence}
Persistence is a property that establishes how conflicting edits,
e.g.\ \texttt{∅ ⟼ ⟨ \textcolor{magenta}{1} ⟩} and \texttt{∅ ⟼ ⟨
  \textcolor{magenta}{2} ⟩}, should be handled during merging.
%
Persistence promises to \emph{never} back out user's changes, hence it
gives up \emph{convergence}, i.e.\ the guarantee to produce a merged
object, and raises a conflict when it is not possible to soundly merge
edits \cite{Pierce07}.
%
Inspired by GNU \texttt{diff3}, we have opted for \emph{persistence}
over convergence: Theorem \ref{thm:persistence} proves that
\texttt{⊔₃} is persistent.

% We now formally state and prove that our merge algorithm is
% \emph{persistent}.  This property is very important because conflicts
% are triggered by changes, hence a non-persistent algorithm could
% back-out changes to avoid raising conflicts.

    % \paragraph{Persistence}
    % The converse property asserts that an edit present in one of the input
    % edit scripts will be found in the merged edit script, given that it does
    % perform a change and that the output script does not contain conflicts.
    % The first hypothesis is needed because identity edits can be silently 
    % ignored in the merge semantics by either \texttt{Id₁} or
    % \texttt{Id₂}.
    % On the other hand the second prerequisite is essential, because 
    % our algorithm is \emph{persistent}, i.e.\ it refuses to back out changes 
    % made by incompatible edits, but triggers an appropriate conflict instead.

    % Firstly an edit does perform a change if it is not an identity edit, or, in 
    % other words if the source and the target values are different.
				
\begin{thm}[Persistence]
\label{thm:persistence}
Let \texttt{e₃ = e₁ ⊔₃ e₂}, \texttt{f : u ⟼ v}, such that \texttt{u ≢
  v} and \texttt{f ∈ e₁} (\texttt{f ∈ e₂}), then either \texttt{f ∈
  e₃} or there exists a conflict \texttt{c} such that \texttt{c ∈ e₃}.
\end{thm}
Note that edit \texttt{f} represents a change edit because \texttt{u ≢
  v} ---it could have been an identity edit and overwritten by another
change edit due to axiom \texttt{Id₁} (\texttt{Id₂}) otherwise.
%
Persistence guarantees not to back out \texttt{f}, therefore either
\texttt{f} is part of the merged edit (\texttt{f ∈ e₃}), or it
triggers a conflict (\texttt{c ∈ e₃}).
%

% \begin{proof}
%   The proof is by induction on \texttt{Merge₃ e₁ e₂ e₃} (from Property
%   \ref{prop:merge3-correct}) and \texttt{f ∈ₑ e₁}.
%     % 
%     In the base case edit \texttt{f} is merged with some other edit
%     \texttt{g}, then either \texttt{f ⊔ g ↥ c} or \texttt{f ⊔ g ↧ h}.
%     %
%     In the former case we are done because \texttt{f} raises a
%     conflict.  In the latter case we proceed by case analysis on
%     \texttt{f ⊔ g ↧ h}.
%     %
%     The merged edit \texttt{h} is either \texttt{f} (case \texttt{Id₂}
%     or \texttt{Idem}), or \texttt{g} (\texttt{Id₁}). In the first case
%     we are done, because \texttt{f} occurs in the merged script.
%     %
%     The second case is contradictory because we assumed \texttt{u ≢
%       v}.
% \end{proof}        

%     The theorem holds also when the edit belongs to the other script and
%     the proof is entirely symmetrical.
   		
\subsection{Structural Invariant}
When diffing and merging tree-like data, it suddenly becomes difficult
to predict how edits may change its structure, especially if
compared with the ``flat'' structure of data handled by line-based
\texttt{diff3}.
%
In this section, we present a structural invariant, which retains some
order between nodes and their relative positions, thus characterizing
how the shape of structured data may change.
%    

\paragraph{Depth-First Pre-Order}
An edit script describes how to transform a source object into a
target object, by traversing the former in \emph{depth-first
  pre-order} and mapping its nodes into the nodes of the latter.
%
Interestingly, the embedding preserves depth-first pre-order: if a
source node comes before another then the mapping of the first will
come before the mapping of the second.
%
However, nodes are not only mapped (updated) from the source to the
target, but they may also be inserted and removed, therefore the
structural invariant must be adjusted to take these edits into
account.
%
Intuitively the order is preserved because nodes that are mapped first
in a script precede those that are mapped later ---since edit scripts
are a flat list-like data structure, we simply order edits according
to their position in the script.
% %
% A pre-order depth-first traversal consists of firstly visiting the
% current node and then traversing recursively its subtrees from the
% leftmost to the rightmost.  
% %
% The traversal induces an ordering on the nodes, so that those that are
% visited sooner come before those that are processed later.  Since edit
% scripts work with list of trees, we have to generalize the ordering
% accordingly.
    
% The type \texttt{hs ⊢ α ⊏ β} denotes that the node \texttt{α} comes
% before the node \texttt{β}, according to depth first traversal of the
% trees contained in the list of trees \texttt{hs}.  \todo{Probably drop
%   data type. Better notation?}
% \begin{minted}{agda}
% data _⊢_⊏_ : Hist xs → C as a → C bs b → Set where
%   here : β ∈ (hs₁ +++ hs₂) → Node α hs₁ ∷ hs₂ ⊢ α ⊏ β
%   there : (hs₁ +++ hs₂) ⊢ α ⊏ β → Node γ hs₁ ∷ hs₂ ⊢ α ⊏ β
% \end{minted}

% Intuitively the list is used as a stack, so that after visiting each
% node its children, yet to be traversed, are pushed on the stack.  Note
% that those trees will be visited before those already on the stack,
% hence following correctly the depth-first traversal.

% \begin{definition}[Edit Order]
% Given an edit script \texttt{e} and two edits \texttt{f} and \texttt{g}, we write
% \texttt{e ⊢ f ⊏ g} if and only if \texttt{f} precedes \texttt{g} in \texttt{e}.
% \end{definition}

% Before stating the main theorem relies on two fundamental properties:
% that the target (source) function and \texttt{diff} are
% \emph{order-preserving} (OP).
% %
% Property \ref{prop:order-preserving-target-fun} guarantees that the
% relative order of edits in a script corresponds to the depth-first
% order of their target (source) nodes in the target (source) objects.
% %
% Property \ref{prop:order-preserving-embedding} ensures that if in the
% target (source) object a node precedes another, then in the diff
% script the first node is produced by an edit that comes before the
% edit that produces the second.

% \begin{prop}[\texttt{⟦\_⟧} is OP]
% \label{prop:order-preserving-target-fun}
% Let \texttt{e} be an edit script and \texttt{f} and \texttt{g} edits
% of type \texttt{v ⟼ ⟨ α ⟩} and \texttt{w ⟼ ⟨ β ⟩}, such that
% \texttt{e ⊢ f ⊏ g}, then \texttt{⟦ e ⟧ ⊢ α ⊏ β}.
% \end{prop}
%   We omit the symmetrical property for \emph{source} nodes and objects.

% \begin{prop}[Embedding is OP]
% \label{prop:order-preserving-embedding}
% Let \texttt{x} and \texttt{y} be heterogeneous lists and let 
% \texttt{e} be an edit script such that \texttt{e = diff x y}.
% Let also \texttt{α} and \texttt{β} be nodes such that \texttt{y ⊢ α ⊏ β}.
% Then there are edits \texttt{f : u ⟼ ⟨ α ⟩} and \texttt{g : v ⟼ ⟨ β ⟩}
% such that \texttt{e ⊢ f ⊏ g}.
% \end{prop}
% \begin{proof}
%   The proof relies on Requirement \ref{req:diff-specs} and Proposition
%   \ref{prop:diff-correct} (requirements and specifications of
%   \texttt{diff}).
%   %
%   By induction on \texttt{y ⊢ α ⊏ β} we locate \texttt{f : u ⟼ ⟨ α ⟩}
%   in \texttt{e}. 
%   %
%   By Proposition \ref{prop:data-retention} it follows that there
%   exists \texttt{g : v ⟼ ⟨ β ⟩} in the tail of \texttt{e}.
% \end{proof}
% We again omit the dual property for \emph{source} nodes and object.

\paragraph{Order Invariant}
The order-invariant property ensures that \texttt{diff} preserves the
depth-first order of the source (target) objects:


% If \texttt{α} precedes \texttt{β} in the source object of script
% \texttt{e}, then one of the following holds:
%     \begin{itemize}
%     \item Node \texttt{α} is deleted in \texttt{e};
%     \item Node \texttt{β} is deleted in \texttt{e};
%     \item Node \texttt{α} is mapped to some node \texttt{γ} and node
%       \texttt{β} is mapped to some node \texttt{φ}, such that node
%       \texttt{γ} comes before node \texttt{φ} in the target object.
%     \end{itemize}

% We now prove our main theorem, which ensures that
% \texttt{diff} preserves the relative order of nodes in the
% source (target) objects.
% %
%
    % We show only the theorem about the \emph{source} object, because
    % the other is symmetrical.
\begin{thm}[\texttt{diff} is OP]
Let \texttt{e = diff x y} and nodes \texttt{α} and \texttt{β},
such that \texttt{α} precedes \texttt{β} in \texttt{x}.
Then one of the following holds.
\begin{itemize}
\item \texttt{⟨ α ⟩ ⟼ ∅} in \texttt{e}. %(\texttt{α} is deleted).
\item \texttt{⟨ β ⟩ ⟼ ∅} in \texttt{e}. %(\texttt{β} is deleted).
\item \texttt{∃ γ φ . ⟨ α ⟩ ⟼ ⟨ γ ⟩}, \texttt{⟨ β ⟩ ⟼ ⟨ φ ⟩} in
  \texttt{e} and \texttt{γ} precedes \texttt{φ} in \texttt{y}.
  % \texttt{e ⊢ ⟨ α ⟩ ⟼ ∅} or \texttt{e ⊢ ⟨ β ⟩ ⟼ ∅} or there exists
  % nodes \texttt{γ} and \texttt{φ} such that \texttt{e ⊢ ⟨ α ⟩ ⟼ ⟨ γ
  %   ⟩}, \texttt{e ⊢ ⟨ β ⟩ ⟼ ⟨ φ ⟩} and \texttt{y ⊢ γ ⊏ φ}.
\end{itemize}
\end{thm}
% \begin{proof}
%   By Proposition \ref{prop:order-preserving-embedding} there are edits
%   \texttt{f : ⟨ α ⟩ ⟼ u} and \texttt{g : ⟨ β ⟩ ⟼ v}, such that
%   \texttt{e ⊢ f ⊏ g}.
%   %
%   By case analysis either \texttt{u = ∅} or \texttt{v = ∅} or \texttt{u = ⟨ γ ⟩}
%   and \texttt{v = ⟨ Φ ⟩}. In the first (second) case \texttt{α} (\texttt{β}) is deleted and we are done.
%   In the third case they are both updated, i.e.\ \texttt{e ⊢ ⟨ α ⟩ ⟼ ⟨ γ ⟩} and
%   \texttt{e ⊢ ⟨ β ⟩ ⟼ ⟨ φ ⟩}.
%   %
%   By Proposition \ref{prop:order-preserving-target-fun} we deduce that
%   \texttt{⟦ e ⟧ ⊢ γ ⊏ Φ} and by Requirement \ref{req:diff-specs} and
%   Proposition \ref{prop:diff-correct} (requirements and specifications
%   of \texttt{diff}) it follows that \texttt{y ⊢ γ ⊏ Φ}.
% \end{proof}

% We now generalize the \emph{order invariant} property to
% \texttt{diff₃}, which guarantees that the relative order of edits in
% each input script is preserved in the merged script.
% %
% Note that the property is restricted only to successful merges and
% furthermore only to \emph{non-identity} edits, since they could 
% not be excluded in favor of proper changing edits otherwise.
% %
% The property holds intuitively because the merge algorithm does not
% rearrange the input edits, but rather merges them pointwise, retaining
% the original order in the merged script.
% %
% \todo{Better! Give me a take home message!}
% \begin{thm}[\texttt{diff₃} is OP]
%   Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts such
%   that \texttt{e₁ ⋎ e₂}, \texttt{e₃ = e₁ ⊔₃ e₂} and \texttt{e₃} does not
%   contain conflicts.
% %
%   Let \texttt{f} and \texttt{g} be edits of type \texttt{u ⟼ v} and
%   \texttt{w ⟼ z} such that \texttt{u ≢ v}, \texttt{w ≢ z} and
%   \texttt{e₁ ⊢ f ⊏ g}, then \texttt{e₃ ⊢ f ⊏ g}.
% \end{thm}
%   The theorem holds also with respect to the edits contained in \texttt{e₂}.

\section{Example Revised}
\label{sec:haskell}
In this section, we revisit the motivating example from Section
\ref{sec:intro} using our fine-grained merge algorithm and show that
it performs better than line-based \texttt{diff3}.
%
Furthermore, while presenting this example we show the API of the
Haskell library that implements our algorithm.
%
Haskell can only partially simulate dependently typed programming,
therefore the library cannot enforce certain invariant of the
original model, in particular \emph{aligmentent} of scripts, which are
instead checked at run-time.
%
On the other hand, the Haskell implementation has much better
performance, an essential requirement to make our algorithm practical.
%

\subsection{Data  Representation}
In our model, the abstract type \texttt{C as a} encodes a constructor
of algebraic data type \texttt{a}, that takes arguments \texttt{as}.
%
In the library, we implement this representation using
a Generalized Algebraic Data Type (GADT), indexed by a list of types
and a target type\footnote{Lists are automatically lifted to the type
  level and share the same term-syntax. A tick distinguishes lifted
  lists of kind \texttt{[ * ]}, e.g. \texttt{'[]}, from the type of
  homogeneous lists of kind \texttt{*}, e.g. \texttt{[]}.}.
%
Each data type constructor is represented by a different constructor,
which instantiates the first index with the type of its arguments and
the second with the resulting type.
%
\paragraph{Example}
For example, data type \texttt{ListC} encodes the list constructors:
\begin{minted}{haskell}
data ListC (as :: [ * ]) (a :: *) where
  Nil :: ListC '[] [a]
  Cons :: ListC '[a , [a]] [a]
\end{minted}
Constructor \texttt{Nil} represents the empty list constructor ---it
takes no argument (\texttt{'[]}) and yields a list of type
\texttt{[a]}.
%m
Constructor \texttt{Cons} represents the cons constructor, which
takes two arguments, the head of the list and the tail of the list
\texttt{'[a , [a]]} and yields a list of type \texttt{[a]}.
%
Observe that, \texttt{Nil} and \texttt{Cons} represent \emph{polymorphic}
constructors.
%

%
This representation encodes also primitive types, i.e.\ non algebraic
data types, such as \texttt{Int}.
%
Since they may assume many values, they are all combined in a single
constructor, whose index declares that it does not take any argument
(\texttt{'[]}), while, in reality, it stores the actual value.
\begin{minted}{haskell}
data IntC xs a where
  I :: Int → IntC '[] Int
\end{minted}
Thanks to polymorphism, these two encodings are sufficient for our to
revisit our initial example: we represent a CSV table as lists of
lists of integers.
\begin{minted}{haskell}
type Csv = [[Int]]
\end{minted} 

\subsection{Diffing}
Since \texttt{diff3} relies on \texttt{diff}, our library defines type
class \texttt{Diff a}, for types \texttt{a} that support diffing.

\begin{minted}{haskell}
class Typeable a => Diff a where
  type Encoding a :: [ * ] → * → *
  toHTree :: a → HTree a
  fromHTree :: HTree a → a
  (=?=) :: C xs a → C ys a → Maybe (xs :~: ys)
\end{minted}
%  distance :: C xs a → C ys a → Double
The associated type family \texttt{Encoding a} returns the concrete
data type that encodes the constructors of \texttt{a}.
%
The type synonym \texttt{C} is used to improve readability of signatures
and for consistency:
\begin{minted}{haskell}
type C xs a = (Encoding a) xs a
\end{minted}
% \todo{You can also do it with another type class parameter and functional 
% dependencies but it is worse in end.}
%
Methods \texttt{toHTree} and \texttt{fromHTree} are \emph{inverse}
functions that embed a value into and from the generic representation.
% 
% The universe used in the implementation corresponds precisely to that
% of the model, except that it requires a \texttt{Diff} instance for
% every child of a node.
%
% \begin{minted}{haskell}
% data HList xs where
%   HNil :: HList []
%   HCons :: Diff a => HTree a → HList as → HList (a : as)
%
% data HTree a where
%   Node :: C as a → HList as → HTree a
% \end{minted}
%
% This definition automatically ensures that the whole family of mutually recursive 
% types have a \texttt{Diff} instance.
%
Method \texttt{(=?=)} tests equality between constructors of the same
data type, and returns a proof that their field types are equal, if
this is the case. This operator is used both in the diff and merge
algorithms.
%
% The function \texttt{distance} computes the cost of an update between
% constructors of the same type and it is expected to be a
% \emph{metric}.

% \begin{definition}[Metric]
% \label{par:Metric}
% A metric on a set A is a function
% d : (A × A) → ${\rm I\!R}$ such that $\forall$ x, y, z $\in$ A:
% 	\begin{align*}
% 		d(x, y) &\geq 0 \quad &\mbox{\emph{{(non-negativity)}}}\\ 
% 		d(x, y) &= 0 \Leftrightarrow x = y \quad &\mbox{\emph{(coincidence axiom)}} \\		
% 		d(x, y) &= d(y, x) \quad &\mbox{\emph{(symmetry)}}\\
% 		d(x, z) &\leq d(x, y) + d(y, z) \quad &\mbox{\emph{(triangle inequality})}
% 	\end{align*}	
% \end{definition}

For instance, in \texttt{diff} it is used to compute the
\emph{discrete distance}, and find a minimal length edit script:
	\[ d(x, y) = 
		\begin{cases} 
			0 \quad &\mbox{if } x = y \\
			1 \quad &\mbox {otherwise}		
		\end{cases} \]	
%
Lastly, superclass \texttt{Typeable} provides methods to inspect
and compare types at run-time.
%
In \texttt{diff} and \texttt{diff3} algorithms, these methods are
needed to check whether two constructors are of the same data type and
to type-check a merged edit script respectively.

\paragraph{Example}
Diffing tables requires only two \texttt{Diff} instances, one for
integers and one for lists.
%
In fact given the \texttt{Diff} instance for the content type, we can
derive a \texttt{Diff} instance for lists of them, so that
\texttt{Diff [Int]} is derived from \texttt{Diff Int}, and
\texttt{Diff [[Int]]} from the previous one.

\begin{minted}{haskell}
instance Diff a => Diff [a] where	
  type Encoding [a] = ListC

  Nil =?= Nil = Just Refl
  Cons =?= Cons = Just Refl
  _ =?= _ = Nothing

  toHTree [] = Node Nil HNil
  toHTree (x : xs) = Node Cons (HCons (toHTree x) hs)
    where hs = HCons (toHTree xs) HNil

  fromHTree (Node Nil HNil) = []
  fromHTree (Node Cons (HCons t (HCons ts HNil))) 
    = fromHTree x : fromHTree ts
\end{minted} 
%
Note that when comparing primitive type ``constructors'', we have to
compare the actual value, to establish whether they represent in fact
the same one.
\begin{minted}{haskell}
instance Diff Int where
  type Encoding Int = IntC

  (I x) =?= (I y) = if x == y then Just Refl else Nothing
  
  toHTree x = Node (I x) HNil
  
  fromHTree (Node (I x) HNil) = x
\end{minted}
%
% Tables are just lists of lists of integers, so that the same list
% \texttt{Diff} instance is used twice, once to derive \texttt{Diff
%   [Int]} from \texttt{Diff Int} and then to automatically derive
% \texttt{Diff [[Int]]} from it.
%
% In both the instances we used \emph{discrete distance}, however
% depending on the specific domain more fine grained distance measure
% could be used to get more precise diffs.

\paragraph{Algorithm}
A  \texttt{diff} algorithm takes as input two objects and outputs an
edit script that reports the differences between them.
%
In particular, GNU \texttt{diff} finds a \emph{minimal length} edit
script, or equivalently the \emph{longest common subsequence} of its
inputs \cite{Berg00, PierceDiff3}, that is a script which 
copies as many lines as possible.
%
Our library detects differences between two values by means of function \texttt{gdiff}:
\begin{minted}{haskell}
gdiff :: (Diff a, Diff b) => a → b → ES '[ a ] '[ b ]
\end{minted}
%
Our \texttt{diff} algorithm is mostly an extension of that of
Lempsink's et al.\ therefore we omit it.
%
We only remark that we have adjusted the edit script length function,
in order to take into account update edits, whose cost is given by the
\emph{discrete distance} function, when computing its score.
%
% \begin{minted}{haskell}
% cost :: ES xs ys -> Int
% cost End = 0
% cost (Ins x e) = 1 + cost e
% cost (Del x e) = 1 + cost e
% cost (Upd x y e) = if x =?
% \end{minted}
%
Observe that using discrete distance, a single update edit is
preferred to a delete and a subsequent insert.
%
\paragraph{Patch}
Our library provides also a generic \texttt{patch} function, which corresponds
to the target function \texttt{⟦\_⟧} of the model.
\begin{minted}{haskell}
gpatch :: ES xs ys → HList ys
\end{minted}

We remark that contrary to that of Lempsink's \cite{Lemp09} the
function is total and furthermore it does not need the source object to
compute the target object, since the edit script alone contains all
the information necessary to reconstruct it.

\subsection{Merging}
Merging consists in diffing the base version with respect to each new
version, producing two edit scripts that are combined following the
three-way merge technique.
%
The merge may fail either due to some conflict or because it generates
an ill-typed script.
%
Our library merges objects in this way by means of function \texttt{gdiff3}:
\begin{minted}{haskell}
gdiff3 :: Diff a => a → a → a → Either [Conflict] (ES '[ a ] '[ a ])
gdiff3 x o y = typecheck $ merge e1 e2
  where e1 = gdiff [ toHTree o ] [ toHTree x ]
         e2 = gdiff [ toHTree o ] [ toHTree y ]
\end{minted}
The input objects are transformed into our generic encoding by
\texttt{toHTree} and diffed with respect to the original version.
%
For the sake of brevity, we lift list syntax to heterogeneous lists,
so that \texttt{[ toHTree o ] :: HList '[ a ]} is a singleton list
containing the \texttt{HTree a} representation of \texttt{o}.
%
Edit scripts \texttt{e₁} and \texttt{e₂} are merged by function
\texttt{merge}, which implements the merge operator \texttt{⊔₃}.
%
While in Agda we can exploit full-fledgeg dependent type to ensure
that \texttt{⊔₃} takes only \emph{aligned} edit scripts,
\texttt{merge} is less finely typed and must therefore
\emph{dynamically} check alignment of each pair of edits.
%

\paragraph{Example}
Variables \texttt{a}, \texttt{b} and \texttt{c} represent the tables
of the example from the introduction:
\begin{minted}{haskell}
a :: Csv
a = [[1,2,3],
      [4,5,6],
      [7,8,9]]

b :: Csv
b = map (0 :) a

c :: Csv
c = [[1,2,3],
      [4,5,9],
      [7,8,15]]
\end{minted}
Merging them using \texttt{gdiff3} succeeds and gives the expected table:
\begin{verbatim}
Main> let Right e = gdiff3 b a c
Main> gpatch e
[[0,1,2,3], [0,4,5,9], [0,7,8,15]]
\end{verbatim}



% \subsection{Example}
% Interactive session with initial example revised.

\section{Discussion and Related Work}
\label{sec:related-work}
Research in the field of change detection and merge has produced a
variety of tools that address these problems.  Many focus on XML
files, such as LaDiff \cite{Chawathe96}, MH-Diff \cite{Chawathe97} and
3DM \cite{Lind04, Lind05}.  We refer to Peters for a
comprehensive survey \cite{PetersSurvey}.
%
Other works address file and data synchronization, which raises
problems similar to those discussed in this paper. Relevant examples
include Unison, a file synchronizer \cite{Pierce98, UnisonSpec};
Harmony, a synchronizer for heterogeneous data
\cite{HarmonyOverview,Pierce07} and an algebra for file
synchronization \cite{Ramsey01}.
%
Lastly some mergers are tailored exclusively to software artifacts
\cite{Westfechtel91, Mens02, Apel11}. 

\paragraph{Diff}
Merging relies on a \texttt{diff} algorithm to detect changes between
objects, which are then to be merged according to some strategy.
%
Our \emph{edit script} is inspired by Lempsink's \cite{Lemp09}, but
employs a more general notion of \emph{edit}, a mapping between
values, which enables reasoning about merge and conflict.
%
% While Lempsink's \texttt{diff} algorithm finds a \emph{minimal length}
% edit script, ours uses a \emph{cost} measure, which is parametric in
% the \texttt{distance} function used to weight updates.  
%
We both employ similar trees and heterogeneous list, but our
constructor representation handles also \emph{polymorphic}
data types such as lists, while their approach requires 
to encode families of mutually recursive data-types
at once, furthermore, only with fully instantiated types.
Our representation is instead modular and reusable.

\paragraph{Ordered and Unordered Data} 
The merge algorithm presented in this paper works on algebraic data
types, which are strongly typed, tree-like, ordered objects. File
systems are usually hierarchical, but not inherently ordered, while
XML trees can also be unordered.
%
Schemas are used in Harmony to identify specific
conflicts (\emph{schema domain conflicts}), which would break their
structural invariant \cite{Pierce07}.
%
They play a role similar to types in this work, which we use to
type-check edit scripts.
%
Chawathe et al.\ assume that nodes have unique identifiers
\cite{Chawathe96}, which greatly simplifies the change detection
phase.
%
This assumption is inappropriate in our context because data formats
do not usually mark their content, furthermore even XML trees
might not have identifiers in their nodes.
	
\paragraph{Alignment and Data Structures} 
Alignment of corresponding parts plays a central role when merging
two objects. 
%
In this work the alignment is \emph{global} and mainly determined by
\texttt{diff},
% \todo{Discuss alignment and diff in the Haskell section?}
which computes the embedding of the source into the target object, by
minimizing an appropriate cost model.
%
GNU \texttt{diff3} aligns lines of texts dividing them in stable and
unstable \emph{chunks} based on the longest common subsequences
computed by \texttt{diff} \cite{PierceDiff3}.  
%
Overlapping equal lines are matched and fused in stable chunks,
leaving possibly conflicting chunks between them.
%
This technique works well when lines are mostly unique such as in
software artifacts.
%
We doubt that this technique would give good results in our context.
%
Firstly the basic values to be aligned are unlikely to be unique,
increasing the chances of misalignment.
%
Secondly such an aligner would not take into account the tree-like
structure of the data, possibly missing important matching.
%
Our aligner retains the structured nature of the data by preserving
the relative order of the nodes and strives to generate a proper
embedding by matching pairs of nodes and preferring updates
to a sequence of delete and insert.
%
The \emph{alignment} strategy has a profound impact when merging data
structures.
%
Harmony employs a \emph{local} strategy, that associates subtrees by
name, therefore it is able to merge correctly unordered collections
such as records and sets.
%
Our algorithm struggles with unordered data structures, 
because it treats them as structured.
%
On the other hand Harmony performs poorly with lists, because
it \emph{aligns} them by absolute position.
%
For example merging \texttt{[1, 3]} with \texttt{[2]} and base 
\texttt{[1, 2]} surprisingly gives \texttt{[2, 3]}, instead of
\texttt{[3]} as we do.
%
Chawathe and Molina reduce the change detection problem to the problem
of computing a minimum-cost edge cover of a bipartite graph
\cite{Chawathe96}.
%
Since this problem is NP-hard they employ an heuristic, consisting of
pruning rules, to find a \emph{minimal} edge cover.
			
\paragraph{Edit Operations} 
Edit operations are very important in a diffing algorithm, because
they determine how precisely changes in data can be detected, 
hence affecting the merging phase.
%
GNU diff employs insert, delete and copy in scripts only and updates
are imprecisely encoded as a delete followed by an insert.  Our
algorithm detects updates explicitly reducing the number of false
conflicts and raising more accurate and informative conflicts
(\texttt{UpdUpd}, \texttt{UpdDel}, \texttt{DelUpd}), that would be
missed otherwise.
%
Some synchronizers employ also a \emph{move} edit operation
\cite{Lind04, Chawathe96, Chawathe97}.
In our algorithm and in Ramsey's \cite{Ramsey01}, move edits
are encoded by delete and insert, bearing the same 
drawbacks of an imprecise representation.
Move can improve the quality of diffs only if it is detected
with a fair confidence, therefore Lindholm takes into
account the \emph{context} of a node in order to improve the precision.
%
With respect to our work we remark that move edits would weaken 
the structural invariants guarantees and would probably 
complicate reasoning \cite{Ramsey01}.
	
\paragraph{Formal Model}
The semantics of merging algorithms employed in version control
systems, with the notable exception of Darcs \cite{HomoPatchTheory,
  CategoryPatchTheory} is not formalized, but are usually understood
empirically, leading to severe misconceptions \cite{PierceDiff3}.
%
For instance it is in general hard to predict the outcome of complex
merges and determine whether a conflict is indeed true or the
consequence of a bug.
%
Furthermore, even when merges are successful, they might produce
unexpected results, for instance duplicating lines or changing their
order.
%
This situation calls for a formalization of such merging algorithms.
%
Unison \cite{UnisonSpec} is an example of a file synchronizer
automatically derived from a formal model \cite{Pierce98}.
%
In this paper we have presented several properties of our algorithms,
inspired by the work from Pierce et al.\ in Harmony
\cite{HarmonyOverview}.
%
Ramsey and Csirmaz propose an algebraic approach to file
synchronization \cite{Ramsey01}. 
%
Differently from our work their synchronizer is
\emph{operation-based}, rather than \emph{state-based}, i.e.\ it does
not rely uniquely on the current states of the replicas, but it
requires to track the operations that changed them.
%
They give a proof system for a simple filesystem algebra,
and prove that it is sound and complete.
%
% The model is based on a relation between sequences of commands that
% ensures that a sequence safely approximates another and conflictless
% synchronization is possible if there is a sequence at least as good as
%both.
%
However the system is quite large, for only five operations it
consists of about fifty laws, to the point that it requires automatic
techniques to prove it sound.
%
On the other hand our model is instead concise and straightforward
to analyze.
%
% The 3DM tool devised by Lindholm does not include a mechanically
% verified model and moreover the general merge rules have been derived
% analyzing the expected result of use cases \cite{Lind04}.  His change
% model is based on \emph{content} and \emph{structural change}. The
% changes in each version are combined into a change set and can be
% merged only if the set is \emph{consistent}, i.e.  unambiguously
% determine at most one parent, predecessor and successor for each node.
% Conflicts are divided in core conflicts and optional conflicts and are
% overall consistent with those listed in \ref{subsec:Merge}, except for
% the delete/edit conflict, which is optional, whereas in this thesis is
% not. It is not explained under which circumstances these changes could
% be considered compatible.  The lack of a formal model raises some
% doubts about the properties claimed for the merge.  First of all the
% merge is considered symmetric, but later it is admitted that appends
% of nodes originated from different trees may be accepted in either
% order. This kind of implementation details are actually relevant from
% the user point of view and have so far fostered the need for formal,
% unambiguous models. In this thesis inserts compete for matching
% positions and may trigger conflicts if incompatible.  Secondly the
% fourth merge rule explicitly requires that changes in either versions
% to be included in the merged tree, however the fact that updates in
% deleted trees are optionally considered conflicts contradicts this
% rule and weaken the property about preservation of edits.

\section{Conclusion and Future Work}
\label{sec:conclusion}
We present a state-based, three-way, persistent, data type generic
\texttt{diff3} algorithm for typed algebraic data type.
%
By employing more accurate edits we detect changes in data more
precisely, leading to more specific edit scripts and ultimately
reducing the number of spurious conflicts raised in merges and
improving the quality of automatic reconciliation.
%
We have formalized the semantics of merge and conflict in Agda and use
it to prove several properties about our algorithm, allowing users to
reason about complex merge operations.
%
% We have implemented an efficient version of our algorithm as an Haskell
% library.
%
We plan to perform a rigorous evaluation of our algorithm on real
world data as future work.
%


% We achieve a better precision in detecting changing 
% in the \emph{change-detection} phase by
% extending the 
%  the edits that describe changes in adata we achieve a 
% \appendix
% \section{Appendix Title}

% This is the text of the appendix, if you need one.

\acks{ This work was supported in part by SIGPLAN PAC funding.  I
  thank Wouter Swierstra and Alejandro Russo for comments that greatly
  improved the paper and the reviewers for their valuable feedback.  }
% Acknowledgments, if needed.

% The bibliography should be embedded for final submission.
\begin{thebibliography}{22}
\providecommand{\natexlab}[1]{#1}
\providecommand{\url}[1]{\texttt{#1}}
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{doi: #1}\else
  \providecommand{\doi}{doi: \begingroup \urlstyle{rm}\Url}\fi

\bibitem[Angiuli et~al.(2014)Angiuli, Morehouse, Licata, and
  Harper]{HomoPatchTheory}
C.~Angiuli, E.~Morehouse, D.~R. Licata, and R.~Harper.
\newblock Homotopical patch theory.
\newblock In \emph{Proceedings of the 19th ACM SIGPLAN International Conference
  on Functional Programming}, ICFP '14, pages 243--256, New York, NY, USA,
  2014. ACM.
\newblock ISBN 978-1-4503-2873-9.
\newblock \doi{10.1145/2628136.2628158}.
\newblock URL \url{http://doi.acm.org/10.1145/2628136.2628158}.

\bibitem[Apel et~al.(2011)Apel, Liebig, Brandl, Lengauer, and
  K\"{a}stner]{Apel11}
S.~Apel, J.~Liebig, B.~Brandl, C.~Lengauer, and C.~K\"{a}stner.
\newblock Semistructured merge: Rethinking merge in revision control systems.
\newblock In \emph{Proceedings of the 19th ACM SIGSOFT Symposium and the 13th
  European Conference on Foundations of Software Engineering}, ESEC/FSE '11,
  pages 190--200, New York, NY, USA, 2011. ACM.
\newblock ISBN 978-1-4503-0443-6.
\newblock \doi{10.1145/2025113.2025141}.
\newblock URL \url{http://doi.acm.org/10.1145/2025113.2025141}.

\bibitem[Balasubramaniam and Pierce(1998)]{Pierce98}
S.~Balasubramaniam and B.~C. Pierce.
\newblock What is a file synchronizer?
\newblock In \emph{Proceedings of the 4th Annual ACM/IEEE International
  Conference on Mobile Computing and Networking}, MobiCom '98, pages 98--108,
  New York, NY, USA, 1998. ACM.
\newblock ISBN 1-58113-035-X.
\newblock \doi{10.1145/288235.288261}.
\newblock URL \url{http://doi.acm.org/10.1145/288235.288261}.

\bibitem[Bergroth et~al.(2000)Bergroth, Hakonen, and Raita]{Berg00}
L.~Bergroth, H.~Hakonen, and T.~Raita.
\newblock A survey of longest common subsequence algorithms.
\newblock In \emph{Proceedings of the Seventh International Symposium on String
  Processing Information Retrieval (SPIRE'00)}, SPIRE '00, pages 39--,
  Washington, DC, USA, 2000. IEEE Computer Society.
\newblock ISBN 0-7695-0746-8.
\newblock URL \url{http://dl.acm.org/citation.cfm?id=829519.830817}.

\bibitem[Bove et~al.(2009)Bove, Dybjer, and Norell]{Bove09}
A.~Bove, P.~Dybjer, and U.~Norell.
\newblock A brief overview of agda --- a functional language with dependent
  types.
\newblock In \emph{Proceedings of the 22Nd International Conference on Theorem
  Proving in Higher Order Logics}, TPHOLs '09, pages 73--78, Berlin,
  Heidelberg, 2009. Springer-Verlag.
\newblock ISBN 978-3-642-03358-2.
\newblock \doi{10.1007/978-3-642-03359-9_6}.
\newblock URL \url{http://dx.doi.org/10.1007/978-3-642-03359-9_6}.

\bibitem[Chacon(2009)]{Git}
S.~Chacon.
\newblock \emph{Pro Git}.
\newblock Apress, Berkely, CA, USA, 1st edition, 2009.
\newblock ISBN 1430218339, 9781430218333.

\bibitem[Chawathe and Garcia-Molina(1997)]{Chawathe97}
S.~S. Chawathe and H.~Garcia-Molina.
\newblock Meaningful change detection in structured data.
\newblock \emph{SIGMOD Rec.}, 26\penalty0 (2):\penalty0 26--37, June 1997.
\newblock ISSN 0163-5808.
\newblock \doi{10.1145/253262.253266}.
\newblock URL \url{http://doi.acm.org/10.1145/253262.253266}.

\bibitem[Chawathe et~al.(1996)Chawathe, Rajaraman, Garcia-Molina, and
  Widom]{Chawathe96}
S.~S. Chawathe, A.~Rajaraman, H.~Garcia-Molina, and J.~Widom.
\newblock Change detection in hierarchically structured information.
\newblock \emph{SIGMOD Rec.}, 25\penalty0 (2):\penalty0 493--504, June 1996.
\newblock ISSN 0163-5808.
\newblock \doi{10.1145/235968.233366}.
\newblock URL \url{http://doi.acm.org/10.1145/235968.233366}.

\bibitem[Foster et~al.(2007)Foster, Greenwald, Kirkegaard, Pierce, and
  Schmitt]{Pierce07}
J.~N. Foster, M.~B. Greenwald, C.~Kirkegaard, B.~C. Pierce, and A.~Schmitt.
\newblock Exploiting schemas in data synchronization.
\newblock \emph{J. Comput. Syst. Sci.}, 73\penalty0 (4):\penalty0 669--689,
  June 2007.
\newblock ISSN 0022-0000.
\newblock \doi{10.1016/j.jcss.2006.10.024}.
\newblock URL \url{http://dx.doi.org/10.1016/j.jcss.2006.10.024}.

\bibitem[Khanna et~al.(2007)Khanna, Kunal, and Pierce]{PierceDiff3}
S.~Khanna, K.~Kunal, and B.~Pierce.
\newblock A formal investigation of diff3.
\newblock In V.~Arvind and S.~Prasad, editors, \emph{FSTTCS 2007: Foundations
  of Software Technology and Theoretical Computer Science}, volume 4855 of
  \emph{Lecture Notes in Computer Science}, pages 485--496. Springer Berlin
  Heidelberg, 2007.
\newblock ISBN 978-3-540-77049-7.
\newblock \doi{10.1007/978-3-540-77050-3_40}.
\newblock URL \url{http://dx.doi.org/10.1007/978-3-540-77050-3_40}.

\bibitem[Lempsink et~al.(2009)Lempsink, Leather, and L\"{o}h]{Lemp09}
E.~Lempsink, S.~Leather, and A.~L\"{o}h.
\newblock Type-safe diff for families of datatypes.
\newblock In \emph{Proceedings of the 2009 ACM SIGPLAN Workshop on Generic
  Programming}, WGP '09, pages 61--72, New York, NY, USA, 2009. ACM.
\newblock ISBN 978-1-60558-510-9.
\newblock \doi{10.1145/1596614.1596624}.
\newblock URL \url{http://doi.acm.org/10.1145/1596614.1596624}.

\bibitem[Lindholm(2004)]{Lind04}
T.~Lindholm.
\newblock A three-way merge for {XML} documents.
\newblock In \emph{Proceedings of the 2004 ACM Symposium on Document
  Engineering}, DocEng '04, pages 1--10, New York, NY, USA, 2004. ACM.
\newblock ISBN 1-58113-938-1.
\newblock \doi{10.1145/1030397.1030399}.
\newblock URL \url{http://doi.acm.org/10.1145/1030397.1030399}.

\bibitem[Lindholm and Rüger(2005)]{Lind05}
T.~Lindholm and T.~Rüger.
\newblock A fault-tolerant three-way merge for {XML} and {HTML}.
\newblock In \emph{Proceedings of the Ninth {IASTED} International Conference
  on Internet and Multimedia Systems and Applications}, pages 71--76, 2005.
\newblock URL \url{http://www.hiit.fi/files/fi/fc/papers/ctl-euroIMSA.pdf}.

\bibitem[Marlow(2010)]{Marlow_haskell2010}
S.~Marlow.
\newblock Haskell 2010 language report, 2010.

\bibitem[Mens(2002)]{Mens02}
T.~Mens.
\newblock A state-of-the-art survey on software merging.
\newblock \emph{IEEE Trans. Softw. Eng.}, 28\penalty0 (5):\penalty0 449--462,
  May 2002.
\newblock ISSN 0098-5589.
\newblock \doi{10.1109/TSE.2002.1000449}.
\newblock URL \url{http://dx.doi.org/10.1109/TSE.2002.1000449}.

\bibitem[Mimram and Di~Giusto(2013)]{CategoryPatchTheory}
S.~Mimram and C.~Di~Giusto.
\newblock A categorical theory of patches.
\newblock \emph{Electron. Notes Theor. Comput. Sci.}, 298:\penalty0 283--307,
  Nov. 2013.
\newblock ISSN 1571-0661.
\newblock \doi{10.1016/j.entcs.2013.09.018}.
\newblock URL \url{http://dx.doi.org/10.1016/j.entcs.2013.09.018}.

\bibitem[O'Sullivan(2009)]{Mercurial}
B.~O'Sullivan.
\newblock \emph{Mercurial - The Definitive Guide: Modern Software for
  Collaboration.}
\newblock O'Reilly, 2009.
\newblock ISBN 978-0-596-80067-3.

\bibitem[Peters(2005)]{PetersSurvey}
L.~Peters.
\newblock Change detection in {XML} trees: A survey, June 2005.

\bibitem[Pierce and Vouillon(2004)]{UnisonSpec}
B.~C. Pierce and J.~Vouillon.
\newblock What's in {U}nison? {A} formal specification and reference
  implementation of a file synchronizer.
\newblock Technical Report MS-CIS-03-36, Dept. of Computer and Information
  Science, University of Pennsylvania, 2004.

\bibitem[Pierce et~al.(2003)Pierce, Schmitt, and Greenwald]{HarmonyOverview}
B.~C. Pierce, A.~Schmitt, and M.~B. Greenwald.
\newblock Bringing {H}armony to optimism: {A} synchronization framework for
  heterogeneous tree-structured data.
\newblock Technical Report MS-CIS-03-42, University of Pennsylvania, 2003.
\newblock Superseded by MS-CIS-05-02.

\bibitem[Ramsey and Csirmaz(2001)]{Ramsey01}
N.~Ramsey and E.~Csirmaz.
\newblock An algebraic approach to file synchronization.
\newblock \emph{SIGSOFT Softw. Eng. Notes}, 26\penalty0 (5):\penalty0 175--185,
  Sept. 2001.
\newblock ISSN 0163-5948.
\newblock \doi{10.1145/503271.503233}.
\newblock URL \url{http://doi.acm.org/10.1145/503271.503233}.

\bibitem[Westfechtel(1991)]{Westfechtel91}
B.~Westfechtel.
\newblock Structure-oriented merging of revisions of software documents.
\newblock In \emph{Proceedings of the 3rd International Workshop on Software
  Configuration Management}, SCM '91, pages 68--79, New York, NY, USA, 1991.
  ACM.
\newblock ISBN 0-89791-429-5.
\newblock \doi{10.1145/111062.111071}.
\newblock URL \url{http://doi.acm.org/10.1145/111062.111071}.

\end{thebibliography}

% We recommend abbrvnat bibliography style.
\bibliographystyle{abbrvnat}

%\bibliography{svc}

% \softraggedright

% \end{thebibliography}

%\listoftodos

\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex -shell-escape
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End: 

