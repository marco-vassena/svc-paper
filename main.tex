%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------

\documentclass{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{hyperref}

\usepackage{minted} % Code listing with reasonable good highlighting
\usepackage{bussproofs}   % For typing judgments
\usepackage[no-math]{fontspec}
\setmonofont[Scale=MatchLowercase]{Apple Symbols} % Unicode mono font

\usepackage[dvipsnames]{xcolor}  		% Color package
\definecolor{dgreen}{rgb}{0.,0.6,0.}    % Deep green
\usepackage{caption}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}	% todos

% Figures with border
\usepackage{float}
%\floatstyle{boxed} 
\restylefloat{figure}

\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{fancyvrb}

% Definitions for unicode characters not included
\usepackage{newunicodechar}                   
\newunicodechar{ᶜ}{$^c$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ᵗ}{$^t$}
\newunicodechar{ˢ}{$^s$}

\usepackage{pifont}
\newunicodechar{✗}{\ding{55}}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathpartir} % typing rules

\theoremstyle{plain}
\newtheorem{definition}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{cor}{Corollary}
\newtheorem{req}{Requirement}

\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}

% Drawings
\usepackage{tikz}
\usepackage{tikz-qtree}

\newcommand{\nil}{\texttt{[]}}
\newcommand{\cons}{\texttt{(:)}}
\newcommand{\num}[1]{\texttt{#1}}

\usepackage{graphicx}
\graphicspath{ {images/} }

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% \conferenceinfo{TYDE '16}{Sept d--d, 2016, Nara, ST, Japan} 
% \copyrightyear{2016} 
% \copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
% \doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusiveo license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Generic Diff3 for Algebraic Datatypes}
%\subtitle{Subtitle Text, if any}

\authorinfo{Marco Vassena}
           {Chalmers University}
           {vassena@chalmers.se}
% \authorinfo{Name2\and Name3}
%            {Affiliation2/3}
%            {Email2/3}

\maketitle

\begin{abstract}
  %
  Many version control systems, including Git and Mercurial, rely on
  \texttt{diff3} to merge different revisions of the same file.
  %
  More precisely \texttt{diff3} automatically merges two text files,
  given a common base version, comparing them line by line and raising
  conflicts when the changes made are irreconcilable.
  %
  The program ignores the actual structure of the data stored in the
  files, hence it might generate spurious conflicts, which must be
  manually resolved by the user.
  %
  In this paper, we present a state-based, three-way, persistent,
  data-type generic \texttt{diff3} algorithm whose increased precision
  in detecting changes reduces the number of false conflicts raised
  and improves its merging capabilities.
  %
  We have implemented the algorithm in Agda, a proof assistant with
  dependent types, and developed a model to reason about ``diffing''
  and merging.
  %
  We have formalized sanity properties and specifications of
  \texttt{diff3} and proved that our algorithm meets them.
  %
  Furthermore, we have identified the minimal conditions under which
  the merging algorithm raises a conflict and established a structural
  invariant preserved.
  %\todo{Improve conclusion?}
  %
  % We have implemented our algorithm in Haskell in order to make our results
  % practical and employed advanced type-system features to retain a 
  % fair amount of type safety.
  %\todo{Abstract Conclusion?}
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
Algorithms,

\keywords
Diff3, Dependent types, Datatype-generic programming

\section{Introduction}
\label{sec:intro}
Version control systems, such as Git \cite{Git} and Mercurial
\cite{Mercurial}, are used in the software industry, as well as in the
open source community and by researchers all over the world to develop
software.
%
These tools track all the changes in the source code throughout its
development, making it possible to quickly roll back to any previous
version and allow different developers to work separately on the same
project.
%
Version control systems provide these features by means of two
algorithms, called \texttt{diff} and \texttt{diff3}.
%
The former detects changes in source code files, while the latter
merges independent changes made to the code base, allowing
simultaneous development.
%
These algorithms are line-based, i.e.\ they compare files line by
line, therefore they can be used on any text-based file, not
exclusively on software artifacts.
%
Unfortunately, their line-granularity limits their precision when
detecting changes, which consequently deteriorates their merging
capabilities.
%
In this paper, we develop a fine-grained data-type generic version of
the \texttt{diff} and \texttt{diff3} algorithms, that improve their
applicability and whose increased precision in detecting changes
reduces the number of spurious conflicts raised and produces more
accurate true conflicts.

\paragraph{Example}
We show the shortcomings of line-based \texttt{diff} and
\texttt{diff3} algorithms by means of an example.  
%
The Comma Separated Values file format (CSV) is a simple text-based
encoding of data stored in tables. %b \cite{csv}.
%
In a CSV file, every line represents a row of the table and commas
separate values in different columns, within each row.
%
For instance, file \texttt{a.csv} encodes a $3 \times 3$ table
containing numbers from 1 to 9.
\begin{figure}[!h]
\centering
\begin{minipage}{.15\textwidth}
{  \centering
  \begin{verbatim}
  $ cat a.csv
  1,2,3
  4,5,6
  7,8,9
  \end{verbatim}\par
}
\end{minipage}%
\begin{minipage}{.15\textwidth}
{  \centering
  \begin{tabular}{ | c | c | c | }
    \hline
    1 & 2 & 3 \\ \hline
    4 & 5 & 6 \\ \hline
    7 & 8 & 9  \\ \hline
  \end{tabular}\par
}
\end{minipage}%
\end{figure}

Imagine that two users are simultaneously working on this table.
The first user adds a column filled with zero and saves the new table in \texttt{b.csv}:
\begin{figure}[h]
\centering
\begin{minipage}{.15\textwidth}
  \centering
\begin{Verbatim}[commandchars=\\\{\}]
  $ cat b.csv
  \textcolor{blue}{0},1,2,3
  \textcolor{blue}{0},4,5,6
  \textcolor{blue}{0},7,8,9
\end{Verbatim}
\end{minipage}%$
\begin{minipage}{.15\textwidth}
  \centering
  \begin{tabular}{ | c | c | c | c | }
    \hline
    \textcolor{blue}{0} & 1 & 2 & 3 \\ \hline
    \textcolor{blue}{0} & 4 & 5 & 6 \\ \hline
    \textcolor{blue}{0} & 7 & 8 & 9  \\ \hline
  \end{tabular}
\end{minipage}%
\end{figure} 

The second user changes some values in the third column and saves the new table in  \texttt{c.csv}:
\begin{figure}[h]
\centering
\begin{minipage}{.15\textwidth}
  \centering
  \begin{Verbatim}[commandchars=\\\{\}]
  $ cat c.csv
  1,2,3
  4,5,\textcolor{magenta}{9}
  7,8,\textcolor{magenta}{15}
  \end{Verbatim}
\end{minipage}% $
\begin{minipage}{.15\textwidth}
  \centering
  \begin{tabular}{ | c | c | c | }
    \hline
    1 & 2 & 3 \\ \hline
    4 & 5 & \textcolor{magenta}{9} \\ \hline
    7 & 8 & \textcolor{magenta}{15} \\ \hline
  \end{tabular}
\end{minipage}%
\end{figure}

The two users would like to synchronize their work now and decide to
use \texttt{diff3} to merge their versions.
%
They have modified \emph{independent} parts of the table, therefore
they are confident that it is should be possible to automatically
merge the changes, without incurring in a conflict.
%
Unfortunately, since \texttt{diff3} is a line-based algorithm, it
compares files line by line, without considering the actual structure
of the data stored in the files. 
%
As a result, the algorithm fails to merge the two tables and raises
spurious conflicts.
%
In particular, \texttt{diff3} employs the \emph{three-way-merge}
technique to compare and merge the corresponding lines of three files.
%
The following table shows the result of applying this technique to the
previous tables:
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\texttt{b} & \texttt{a} & \texttt{c} & \texttt{diff3 b a c} \\ \hline
\texttt{\textcolor{blue}{0},1,2,3} & \texttt{1,2,3} & \texttt{1,2,3} & \textcolor{dgreen}{\texttt{0,1,2,3}} \\ \hline
\texttt{\textcolor{blue}{0},4,5,6} & \texttt{4,5,6} & \texttt{4,5,\textcolor{magenta}{9}} & \textcolor{red}{✗}  \\ \hline
\texttt{\textcolor{blue}{0},7,8,9} & \texttt{7,8,9} & \texttt{7,8,\textcolor{magenta}{15}} & \textcolor{red}{✗} \\ \hline
\end{tabular}
\end{center}
If there is at most one different version of the same line, as it
happens in the first row, a merge is possible.
%
Instead, if the same line is different in all the three versions,
which is the case in the second and third row, a conflict is
triggered.
%


\paragraph{Discussion}
The main limitation of \texttt{diff} and \texttt{diff3} is that they
operate on data representation with a \emph{fixed} precision,
consisting of one line of text, therefore disregarding completely any
information about the actual structure of the data.
%
If they were aware of the table structure, consisting of columns and
rows, then \texttt{diff} could exactly represent the differences in
each version and \texttt{diff3} could automatically merge them, as the
users expected:
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\textcolor{blue}{0} & 1 & 2 & 3 \\ \hline
\textcolor{blue}{0} & 4 & 5 & \textcolor{magenta}{9} \\ \hline
\textcolor{blue}{0} & 7 & 8 & \textcolor{magenta}{15} \\ \hline
\end{tabular}
\end{center}

% Obviously we do not want to implement format specific \texttt{diff} and \texttt{diff3} algorithms, since this would hinder reusability, but instead
% they manipulate data directly, assuming that parsers and serializers for it are available. Furthermore we would like our algorithms to be as reusable as possible, with data of any possible shape.

\subsection{Contributions}
In this paper we make the following contributions:
\begin{itemize}
\item In Section \ref{subsec:edit-script}, we define a type-safe edit script data 
      type that supports \emph{delete}, \emph{insert} and \emph{update} edits and 
      that represents the differences between two objects. In Section 
      \ref{subsec:diff-algo}, we give the formal specifications of a \texttt{diff} 
      algorithm in terms of the edit script data type.
\item In Section \ref{subsec:merge-semantics}, we formalize the 
      \emph{three-way-merge} strategy and give a precise semantics of 
      \emph{mergeable} and \emph{conflicting} edits. We give 
      the formal specifications of a \texttt{diff3} algorithm in terms of our edit 
      semantics. 
\item In Section \ref{subsec:diff3-algo}, we show a data type generic, three-way 
      \texttt{diff3} algorithm that satisfy our specifications and we study its 
      formal properties in Section \ref{sec:properties}.
\end{itemize}
We have implemented these algorithms using generic programming
techniques in Agda \cite{Bove09}, a programming language with dependent
types and a proof assistant. Dependent types are particularly
convenient in this setting to idiomatically encode the pre-conditions
and post-conditions of our algorithms and ultimately verify their
properties.
%
We have then put our model into practice by efficiently implementing
our algorithms in Haskell \cite{Marlow_haskell2010}.
%
% In Section \ref{sec:haskell}, we point out the shortcomings and
% compromises that we had to make when moving from a language with 
% dependent types to a less expressive one.
%
The source code containing \texttt{diff} and \texttt{diff3}
algorithms, their properties and formal proofs are available
online\footnote{https://github.com/marco-vassena/gdiff3}.  For the
sake of presentation, we have simplified the code presented in this
paper, for instance by hiding implicit arguments and universe levels.
\todo{This paper is organized as follows}

\section{Universe}
\label{section:universe}
Data type generic algorithms work on a generic representation of
algebraic data types.
%
The universe used in this paper consists of typed heterogeneous rose
trees, a combination of mutually recursive heterogeneous lists and
trees, whose \emph{nodes} correspond to data type constructors and
their children to their fields.

\paragraph{Constructors}
Type \texttt{C as a} denotes a constructor of an algebraic data type
of type \texttt{a}, that takes arguments of types given in list
\texttt{as}.
%
For instance constructor \texttt{True} is represented by type \texttt{C []
  Bool}, because it does not take any argument and produces a boolean
value.
%
Note that also polymorphic data types are supported by this
representation, for example, constructor \texttt{Just} is represented
by type \texttt{C [a] (Maybe a)} for any type \texttt{a}.
%
In the following, we will leave type \texttt{C as a} abstract, as a
module parameter, together with a decidable heterogeneous equality
operator\footnote{In Agda, \texttt{Set} is the kind of simple types
  and \texttt{List Set} is the type of a list containing simple
  types.}.

\begin{minted}{agda}
module Diff3 (C : List Set → Set → Set) 
              (_≟_ : (α : C as a) (β : C bs b) → Dec (α ≅ β)) where
\end{minted}
In Section \ref{sec:haskell}, we show how to concretely implement this
representation.

\paragraph{Well-Typed Rose Trees}
Data type \texttt{HTree a} is a tree-like data structure that
represents a value of an algebraic data type of type \texttt{a}.
\begin{minted}{agda}
  data HTree : Set → Set where
    Node : C as a → HList as → HTree a
\end{minted}
%
Data type \texttt{HList as} collects the children of node, i.e. the
arguments of constructor \texttt{C as a}, each encoded as a typed
tree.
%
\begin{minted}{agda}
  data HList : List Set → Set where
    [] : HList []
   _∷_ : HTree a → HList as → HList (a ∷ as)
\end{minted}
%
This representation is type-safe because the constructor
witness and the heterogeneous list share the same index
\texttt{as}, therefore denoting a well-typed application of a
constructor to its arguments.
% 

\paragraph{Example}
List \texttt{[1,2]} is encoded in this universe as:
\begin{Verbatim}[commandchars=\\\{\}]
ht : HTree (List Int)
ht = Node (\textcolor{blue}{::}) [Node \textcolor{magenta}{1} [], Node (\textcolor{blue}{::}) [Node \textcolor{magenta}{2} [], Node \textcolor{blue}{[]} []]]
\end{Verbatim}
Where \texttt{(\textcolor{blue}{::}) : C [Int, List Int] (List Int)}
and \texttt{\textcolor{blue}{[]} : C [] (List Int)} denote the cons
constructor and the empty list constructor respectively, specialized
without loss of generality to \texttt{List Int}.
%
In our examples we automatically lift numbers to node constructors,
that is \texttt{\textcolor{magenta}{1}, \textcolor{magenta}{2} : C []
  Int}.
%
We graphically depict objects encoded in this universe as trees:

\begin{figure}[h]
\centering
\Tree
[.\texttt{(\textcolor{blue}{::})}
   [.\texttt{\textcolor{magenta}{1}} ]
   [.\texttt{(\textcolor{blue}{::})} [.\texttt{\textcolor{magenta}{2}} ] [.\texttt{\textcolor{blue}{[]}} ]]
]
\end{figure}
	
% \todo{Move later?}
% In the following we will use two auxiliary functions to append and
% split heterogeneous lists:
% \begin{minted}{agda}
% _+++_ : HList as → HList bs → HList (as ++ bs)
% \end{minted}
	
\section{Generic diff}
Our \texttt{diff3} algorithm relies on a \texttt{diff} algorithm, used
as a subroutine to compare the input objects and merge them.
%
The algorithm detect differences between two heterogeneous lists
given as input producing an edit script, whose edit operations
progressively transform one into the other.
%
More precisely an edit script is a list of edits, that either insert,
delete, or replace the nodes of the input objects.
%
We firstly describe a simply typed version of edit and edit scripts
and then refine them to guarantee type-safety.

\subsection{Edit Operations}
An edit operation is a mapping \texttt{u ⟼ v}, where \texttt{u} and
\texttt{v} are called \emph{source} and \emph{target} value
respectively.
%
A value is an optional node, i.e.  \texttt{Value as a = Maybe (C as
  a)}. 
%
For brevity, we write \texttt{∅} for an empty value and \texttt{⟨ α ⟩}
for a value containing node \texttt{α}.
% 
All the possible combinations of source and target value state, i.e.\
empty and non-empty, form four different edit operations.
\begin{minted}{agda}
data _⟼_ : Value as a → Value bs a → Set where
  Nop : ∅ ⟼ ∅
  Del : (α : C as a) → ⟨ α ⟩ ⟼ ∅
  Ins : (α : C as a) → ∅ ⟼ ⟨ α ⟩
  Upd : (α : C as a) (β : C bs a) → ⟨ α ⟩ ⟼ ⟨ β ⟩
\end{minted}
The \texttt{Nop} edit is a no-operation, that will be
used in Section \ref{subsec:alignment}, to \emph{align} edit scripts.
%
Edit \texttt{Del α} deletes node \texttt{α}, which is mapped to
the empty value \texttt{∅}, since it lacks a target node.
%
Similarly, edit \texttt{Ins α} inserts node \texttt{α}, which
then lacks a source node, hence it has the empty value \texttt{∅} 
as source value.
%
Edit \texttt{Upd α β} updates source node \texttt{α} with target node
\texttt{β} and concretely represents a constructor change.
%
Note that there is no explicit copy edit: it is just a special case of
update, in which the source and target nodes happen to be the same.
%
Edits that have the same \emph{source} and \emph{target} value are
called \emph{identity} edits---they have type \texttt{v
  ⟼ v}.
%
Node copy and no-operation fall into this category.
%
Even though the edit data type, as it is here defined, is not space
efficient, because it might store the same node twice, it is more
suitable for reasoning and leads to a more elegant merge and conflict
semantics.
%
\todo{An implementation should take care of this. Do we?}
	
\subsection{Untyped Edit Script}
\label{subsec:edit-script}
An edit script is a finite list of edit operations, that describe how
to transform a \emph{source} object into a \emph{target} object.
%
\begin{minted}{agda}
data ES : Set where
  [] : ES
  _::_ : v ⟼ w → ES → ES
\end{minted}	
%
More precisely the script traverse and process their nodes
by traversing the objects in depth-first preorder.
%
Note however that we do not transform plain trees, but rather
\emph{lists} of trees, which are used as \emph{stacks} of unprocessed
nodes, pushed and popped according to the edit operations found in the
script.
%
We work with lists of trees because certain edits, when applied to
nodes in a tree, will intrinsically result in multiple trees.
%
For instance, deleting the root node to tree \texttt{ht}, from Section
\ref{section:universe}, will produce two trees (\texttt{Node
  \textcolor{magenta}{1} []} and \texttt{Node (\textcolor{blue}{::})
  [Node \textcolor{magenta}{2} [], Node \textcolor{blue}{[]} []]}):

\begin{figure}[h!]
\centering
  \begin{minipage}{.15\textwidth}
  \centering
    \Tree
    [.\texttt{\textcolor{magenta}{1}} ]
  \end{minipage}%
%
\begin{minipage}{.15\textwidth}
  \centering
    \Tree
    [.\texttt{(\textcolor{blue}{::})} [.\texttt{\textcolor{magenta}{2}} ]     
    [.\texttt{\textcolor{blue}{[]}} ]]
\end{minipage}%
\end{figure}

%
Informally, a delete (insert) edit pops the root of the tree from the
top of the \emph{source} (\emph{target}) stack and pushes its children
instead.
%
An update behaves as a simultaneous delete and insert and
a no-operation leaves both of the stacks unchanged.
%
In principle, it should be possible to define functions that
retrieves the source and target objects from a script, by
\emph{inverting} the process that we have just described.
%
Unfortunately, the lack of types already makes it hard to even assign a suitable
type to a function \texttt{⟪\_⟫ : ES → HList ?} :
what type should we put instead of the question mark?
%
Crucially, an untyped edit script does not guarantee that its
operations will produce well-typed trees and not even that they can be
performed at all.
%
The top of the stack might contain trees of the wrong type, that do
not match those of the constructor at hand, or it might try to pop
trees from an empty stack.
%
For instance, edit script \texttt{[Ins (\textcolor{blue}{::}) , Ins
  \textcolor{magenta}{0}]} would generate a target list containing an
ill-typed tree, whose root node lacks a second child:
\begin{figure}[!h]
\centering
\Tree
[.\texttt{(\textcolor{blue}{::})}
   [.\texttt{\textcolor{magenta}{0}} ]
]
\end{figure}

%
Guaranteeing such invariants is the bread and butter of
dependently-typed programming, as we proceed to show in the next
section.

\subsection{Type-Safe Edit Script}
In order to make edit script type-safe, we firstly refine the type of
\emph{values}, to correctly approximate the trees popped and pushed on
a stack, with their index and secondly annotate the edit script data
type to ensure type-safety through them.

\paragraph{Value}
Given a source (target) value of type \texttt{Value as a}, an edit
will pop trees of types \texttt{as} and push a tree of type \texttt{a}
on the source (target) stack, if and only if a node is in fact
present, otherwise the corresponding stack will be left unchanged.
%
The following indexed data type correctly approximate inputs and
outputs, regardless of the presence of the node.
\begin{minted}{agda}
data Value : List Set → List Set → Set where
  ∅ : Value [] []
  ⟨_⟩ : C as a → Value as [ a ] 
\end{minted}
Observe that also the second index is a list and both of them are
empty, for the empty value.
%

\paragraph{Edit Script}
The edit script data type is still a list of edits, but it is now
indexed with type-level lists, which restrict the shape of the source
and target stacks, ensuring type-safety.
%
\begin{minted}{agda}
data ES : List Set → List Set → Set where
  [] : ES [] []
  _::_ : {v : Value as bs} {w : Value cs ds} → v ⟼ w → 
          ES (as ++ xs) (cs ++ ys) → ES (bs ++ xs) (ds ++ ys)
\end{minted}	
An edit script of type \texttt{ES xs ys} transforms a \emph{source}
list of type \texttt{HList xs} into a \emph{target} list of type
\texttt{HList ys}.  
%
The cons constructor takes an edit, whose source (target) value
consumes \texttt{as} (\texttt{cs}) and yields \texttt{bs}
(\texttt{ds}).
%
The fact that the lists of the rest of the edit script have prefix
\texttt{as} and \texttt{cs}, ensure that it will be possible to pop
trees of the right type from the source and target object
respectively, and replace them by constructing and pushing well-typed
trees of types \texttt{bs} and \texttt{ds}.

With more precise types, we can define \emph{source} function
\texttt{⟪\_⟫}, which retrieves the source object from an edit script:
\begin{minted}{agda}
⟪_⟫ : ES as bs → HList as
⟪ [] ⟫ = []
⟪ Nop ∷ e ⟫ = ⟪ e ⟫
⟪ Del α ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
⟪ Ins α ∷ e ⟫ = ⟪ e ⟫
⟪ Upd α β ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
\end{minted}
%
Source nodes are present in delete and update edits ---the other cases
are trivial.
% 
Function \texttt{hsplit : HList (as ++ bs) → HList as × HList bs}
splits an heterogeneous list in two parts according to its type and it
is used to \emph{pop} the arguments (\texttt{hs₁}) of the source
constructor (\texttt{α}) , from the rest of the list.
%
Note that the type of the cons constructor guarantees that the tree
\texttt{Node α hs₁} is well-typed.
%
Dually, we define the \emph{target} function, whose implementation is
analogous and thus omitted:
\begin{minted}{agda}
⟦_⟧ : ES as bs → HList bs
\end{minted}

\begin{figure*}[!t]
\centering
\includegraphics[scale=.27]{embedding2}
\caption{The embedding induced by \texttt{[Upd (::) (::), \textcolor{magenta}{Upd 0 1}, \textcolor{blue}{Ins (::)} , \textcolor{blue}{Ins 2}, Upd [] []]}}
\label{fig:embedding}
\end{figure*}

\paragraph{Example}
While the previous edit script is now ill-typed, the following script
encodes the differences between two lists of integers, namely \texttt{[0]} and \texttt{[1,2]}, as witnessed by its richer type:
\begin{Verbatim}[commandchars=\\\{\}]
e : ES [List Int] [List Int]
e = [Upd (::) (::), \textcolor{magenta}{Upd 0 1}, \textcolor{blue}{Ins (::)} , \textcolor{blue}{Ins 2}, Upd [] []]
\end{Verbatim}

Figure \ref{fig:embedding} shows that the script embeds nodes of the
source tree into those of the target object.
%
Finding a ``good'' embedding is the goal of \texttt{diff}.

\subsection{Diff Algorithm}
\label{subsec:diff-algo}
Our \texttt{diff3} algorithm does not merge objects directly, but like
its text-based counterpart, relies on a \texttt{diff} algorithm
as a subroutine to detect changes between them.
%
More precisely, a \texttt{diff} algorithm takes two object and produces
an edit script that describes the differences between them, which is
then used to compute the merged object by \texttt{diff3}.
%
We remark that our \texttt{diff3} algorithm and its formal guarantees,
do not rely on a specific \texttt{diff} algorithm, but rather are
valid with any function of type \texttt{diff : HList as → HList bs →
  ES as bs} that fulfills the following basic requirement.

\begin{req}[\texttt{diff} specifications]
  \label{req:diff-specs}
  A \texttt{diff} algorithm is correct if and only if for any list
  \texttt{x} and \texttt{y} \center{\texttt{e = diff x y ⇔ x ≡ ⟪ e ⟫ ∧
      y ≡ ⟦ e ⟧}}
\end{req}
%
This correctness criterion demands that the edit script computed by
\texttt{diff} transform exactly the source object \texttt{x} into the
target object \texttt{y}.  (In the specifications \texttt{≡} denotes
propositional equality.)
%
Note that the specification is very permissive: it does not require 
the edit script to be minimal, not even ``small''.
%
Even though we expect our \texttt{diff3} algorithm to perform better
with competitive \texttt{diff}s ---they will probably capture changes
more precisely, the advantage of reasoning by such specification is
that our results are valid for virtually any \emph{sensible}
\texttt{diff} algorithm.
%
% The following data type serves to this purpose: \texttt{Diff x y e} is
% the proof that the edit script \texttt{e} is the result of diffing
% lists \texttt{x} and \texttt{y}.
% \begin{minted}{agda}
% data Diff : HList xs → HList ys → ES xs ys → Set where
%   End : Diff [] [] []
%   Nop : Diff x y e → Diff x y (Nop ∷ e)
%   Del : Diff (x₁ +++ x₂) y e → Diff (Node α x₁ ∷ x₂ ) y (Del α ∷ e)
%   Ins : Diff x (y₁ +++ y₂) e → Diff x (Node β y₁ ∷ y₂) (Ins β ∷ e)
%   Upd : Diff (x₁ +++ x₂) (y₁ +++ y₂) e → 
%         Diff (Node α x₁ ∷ x₂) (Node β y₁ ∷ y₂) (Upd α β ∷ e)
% \end{minted}
% We prove that \texttt{Diff x y e} complies with the specifications of
% \texttt{diff} (Requirement \ref{req:diff-specs}), because \texttt{x}
% and \texttt{y} are uniquely determined by respectively the source and
% target function applied on \texttt{e}, as the following result shows.
% \begin{prop}[\texttt{Diff} is correct]
% \label{prop:diff-correct}
% Let \texttt{x} and \texttt{y} be heterogeneous lists and \texttt{e} an edit script, then
% \center{\texttt{Diff x y e ⇔ x ≡ ⟪ e ⟫ ∧ y ≡ ⟦ e ⟧}}
% \end{prop}
In our implementation we employ a generalization of Lempsink's
\texttt{diff} algorithm \cite{Lemp09}, which we have proved to meet
Requirement \ref{req:diff-specs}.
% \begin{minted} {agda}
% diff-suff :  (x : HList xs) (y : HList ys) → Diff x y (diff x y)
% \end{minted}

\section{Generic diff$_3$}
The \texttt{diff3} algorithm takes as input three objects, the
original version called \emph{base} and two new replicas, and it
outputs an edit script that combines the changes between them.
%
However, the algorithm does not work directly on the replicas, but
relies on a \texttt{diff} algorithm to compute two edit scripts that
describe the changes from base to each of the new versions.
%
It then generates an edit script by merging the edits contained in
edit scripts: the \emph{source} of the merged script is the base
object and the \emph{target} is the merged object.
%
Nevertheless, edits cannot always be automatically reconciled: a
conflict is triggered in this situation and reported to the user, who
has to solve it manually. 
%
\todo{More discussion about different design choices, persistent etc
  ...}
		
\todo{Remark that the three-way technique is attractive and we simply
  want to apply it to structured data. Maybe in intro?}
%
The merging technique employed in our \texttt{diff3} algorithm for
algebraic data types consists in applying the three-way merge
algorithm at the node level.
%
Informally the algorithm compares corresponding parts of two objects
and of their base version, when two parts disagree, the base version
is examined: a conflict is detected if each version is different,
otherwise the version that changed from base is chosen.
	
To put this strategy on a formal footing, we give precise definitions
of corresponding parts of objects and conflicts, on top of which, we
define a sound merging semantics.

\subsection{Alignment}
\label{subsec:alignment}
%
\emph{Alignment} is a relation used to pinpoint the corresponding
parts of two objects, which should be merged together.
%
Merging unrelated parts is likely to fail, resulting in spurious
conflicts, or produce unexpected results, therefore alignment affects
immensely the precision and reliability of \texttt{diff3}.
%
In this framework, \emph{edits} are suitable candidates to identify
these parts, because they relate source values that belong to the same
object (\emph{base}), with target values that belong to different
replicas, which we want to merge.
%
More formally, we define \emph{alignment} as follows.
\begin{definition}[Edit and Script Alignment]
\mbox{}
\label{def:align}
\begin{itemize}
  \item Two edit operations are aligned, if and only if they have the same source value.
  \item Two edit scripts are aligned, if and only if their edits are
    pairwise aligned.
\end{itemize}
\end{definition}
Note that Definition \ref{def:align} aligns edits according to their
source \emph{values}, rather than nodes, so that insert and
no-operations may also be aligned: any two edits of type \texttt{u ⟼
  v} and \texttt{u ⟼ w} are aligned.
%	
Intuitively, two edit scripts that have the same \emph{source} object
can be aligned, because they share the same collection of
\emph{source} nodes.
%
However, insert edits may break alignment, because they can occur at
any point in the scripts, introducing \emph{empty} values.

\paragraph{Example}
Consider the lists \texttt{x = [1]}, \texttt{y = [0,1]} and \texttt{z
  = [1,2]}.
%
Edit scripts \texttt{e₁} and \texttt{e₂} represent the \texttt{diff}
between \texttt{x} and \texttt{y} and \texttt{z}
respectively\footnote{In this example \texttt{Cpy α} stands for \texttt{Upd α α}}.
\begin{minted}{agda}
e₁ e₂ : ES [ List Int ] [ List Int ]
e₁ = [Ins  (::), Ins  0, Cpy (::), Cpy 1, Cpy []]
e₂ = [Cpy (::), Cpy 1, Ins  (::), Ins  2, Cpy []] 
\end{minted}       
%
% \begin{minted}{agda}
% e₁ e₂ : ES [ List Int ] [ List Int ]
% e₁ = [Ins (::), Ins 1, Cpy (::), Cpy 1,                 Cpy []]
% e₂ = [                Cpy (::), Cpy 1, Ins (::), Ins 2, Cpy []] 
% \end{minted}       
Scripts \texttt{e₁} and \texttt{e₂} are \emph{not} aligned, because
their first edits are not, namely \texttt{∅ ≢ ⟨ :: ⟩}, where
\texttt{∅} is the source value of \texttt{Ins (::)} in \texttt{e₁} and
\texttt{⟨ :: ⟩} is the source value of \texttt{Cpy (::)} in
\texttt{e₂}.

Interestingly, alignment can be recovered by inserting no-operation
edits in these points.
\begin{minted}{agda}
e₁* = [Ins (::), Ins 0, Cpy (::), Cpy 1, Nop   , Nop , Cpy []]
e₂* = [Nop   , Nop , Cpy (::), Cpy 1, Ins (::), Ins 2, Cpy []] 
\end{minted}

In the following, we use notation \texttt{e ⊑ e*} to denote that edit
script \texttt{e*} extends script \texttt{e} with a finite number of
\texttt{Nop} edits.
%
Observe that, \texttt{Nop} edits change neither the \emph{source} nor the
\emph{target} of the edit script, therefore it is an harmless
extension.
\begin{prop}[Equivalent Extension]
  If \texttt{e ⊑ e*}, then it holds that \texttt{⟦ e ⟧ ≡ ⟦ e* ⟧} and
  \texttt{ ⟪ e ⟫ ≡ ⟪ e* ⟫}
\end{prop}

Proposition \ref{prop:align-ext} guarantees that we can always
\texttt{Nop}-extend scripts that have the same source object.
%
As a result, we can systematically apply this technique in
\texttt{diff3}.
%
\begin{prop}[Alignment via Extension]
\label{prop:align-ext}
  Let \texttt{e₁ = diff x y} and \texttt{e₂ = diff x z}, then there
  exists edit scripts \texttt{e₁*} and \texttt{e₂*}, such that
  \texttt{e₁ ⊑ e₁*}, \texttt{e₂ ⊑ e₂*}, and \texttt{e₁*} and
  \texttt{e₂*} are aligned.
\end{prop}
Adding no-operations operations to align scripts is effective, because
\texttt{Nop} always aligns with \texttt{Ins} --- they both have the
empty value \texttt{∅} as source.
%
Furthermore, it is also innocuous, because no-operations cannot
introduce new conflicts, since they are \emph{identity} edits.


%         \paragraph{Weak Alignment}\todo{Drop weak alignment, give only Proposition}
%         Two edit scripts are \emph{weakly aligned} \texttt{e₁ \textasciitilde\ e₂} 
%         if they admit extensions that are \emph{aligned}:
% \begin{minted}{agda}
% data _~_ (e₁ : ES xs ys) (e₂ : ES xs zs) : Set where
%   WA : e₁ ⊴ e₁* → e₂ ⊴ e₂* → e₁* ⋎ e₂* → e₁ ~ e₂
% \end{minted}

%         We can now weakly align two edit scripts, that share the
%         same \emph{source} object. The alignment procedure examines the scripts
%         and extend either of them with no-operations, whenever one inserts a 
%         node and the other does not. 
% \begin{minted}{agda}
% align : Diff x y e₁ → Diff x z e₂ → e₁ ~ e₂
% \end{minted}

\subsection{Semantics of Merge and Conflict}
\label{subsec:merge-semantics}
We formalize the three-way merge technique, by defining a sound
semantics of merge and conflict over aligned edits.
%
Two aligned edits contain at most three distinct values: one common
source and two, possibly different, targets, which are treated as
corresponding parts.  
%
Three-way merge fails and triggers a conflict, if the three values are
all different: there is no general a priori strategy to merge such
contrasting edits.
%
If no more than two of them are different, it succeeds and finds an
edit that combines both.
	
\paragraph{Merge}
Data type \texttt{f ⊔ g ↧ h} represents the semantics of merge:
it is the proof that merging aligned edits \texttt{f} and \texttt{g}
succeeds, producing the edit \texttt{h}.
\begin{minted} {agda}
data _⊔_↧_ : (v ⟼ a) → (v ⟼ b) → (v ⟼ c) → Set where
  Id₁ : (f : v ⟼ v) (g : v ⟼ w) → f ⊔ g ↧ g
  Id₂ : (f : v ⟼ w) (g : v ⟼ v) → f ⊔ g ↧ f
  Idem : (f : v ⟼ w) → f ⊔ f ↧ f
\end{minted}
Observe that the type of the three edits in the declaration guarantees
that this judgment is defined only on aligned edits and that also the
resulting edit must share the same source value.
%
Each constructor represents a distinct axiom that justifies why the
merge is possible and determines the merged target value.
%
Rules \texttt{Id₁} and \texttt{Id₂} apply when respectively the
first and the second transformation is an \emph{identity} edit.
%
Similarly to the three-way merge algorithm, when one version is
unchanged the other is chosen.
%
The fact that merging is an \emph{idempotent} operation motivates the
third rule (\texttt{Idem}): it applies when the same edit is performed
independently on the same source value.
%
This merging semantics is compelling because it is minimal, it
contains only three axioms, yet complete because it can encode every
true merge, even though it does not mention any specific edit.

\paragraph{Conflict}
A conflict occurs when two edits perform irreconcilable changes.  
%
Data type \texttt{Conflict u v w} represents the cause of
a conflict, that may arise from merging aligned edits \texttt{u ⟼ v}
and \texttt{u ⟼ w}.
%
We omit the full declaration for brevity, but we briefly describe its
constructors.
%
Conflicts \texttt{InsIns β γ} and \texttt{UpdUpd α β γ}, of type
\texttt{Conflict ∅ ⟨ α ⟩ ⟨ β ⟩} and \texttt{Conflict ⟨ α ⟩ ⟨ β ⟩ ⟨ γ
  ⟩}, denote conflicting insertions and updates respectively.
%
They are similar to those detected by line-based \texttt{diff3}, which
encodes proper updates as a deletion followed by an insertion.
%
Conflict \texttt{DelUpd α β} of type \texttt{Conflict ⟨ α ⟩ ∅ ⟨ β ⟩},
is a new form of conflict, that stems from the fact that these two
edits are in general irreconcilable ---conflict \texttt{UpdDel α β} is analogous.
%
Data type \texttt{f ⊔ g ↥ c} represents the semantics of conflict: it
is the proof that edits \texttt{f} and \texttt{g} cannot be merged and
raise conflict \texttt{c}.
\begin{minted}{agda}
data _⊔_↥_ : (u ⟼ v) → (u ⟼ w) → Conflict u v w → Set where
  Cnf : (f : u ⟼ v) (g : u ⟼ w) → u ≢ v → v ≢ w  → u ≢ w → 
        (c : Conflict u v w) → f ⊔ g ↥ c
\end{minted}
The three inequalities attest that all the values involved are
different from each other, ensuring that the edits are actually
incompatible and may not be merged otherwise. 
%
If \texttt{u ≡ v} the first edit would be an \emph{identity} edit,
which can always be merged by \texttt{Id₁}. Similarly if \texttt{u ≡
  w} the second edit could be merged by \texttt{Id₂}. Lastly if
\texttt{v ≡ w} the edits \texttt{f} and \texttt{g} would perform the
same change and could be merged applying the \texttt{Idem} rule.
%
Given these inequalities the corresponding conflict is uniquely
determined, i.e. for any concrete choice of \texttt{u}, \texttt{v} and
\texttt{w} that are all different, the conflict \texttt{c} is uniquely
determined.
%
As a result, also the semantics of conflict is minimal, because it
contains only one axiom, yet complete because it can encode all true
conflicts.

\paragraph{Properties}
We now show some fundamental properties of the semantics of merge and
conflict, that are useful in our formalization.
        %
Firstly, we prove that the semantics is sound, i.e.\ fixed two edits
merge and conflict are \emph{mutually exclusive}.
\begin{prop}[Mutually Exclusive]
  \label{prop:mutually-exclusive}
  If \texttt{f ⊔ g ↧ h}, then there exists no conflict \texttt{c} such
  that \texttt{f ⊔ g ↥ c}.
\end{prop}
Secondly we prove \emph{determinancy} of the semantics relations.
\begin{prop}[Determinancy]
\mbox{}
\label{prop:determinancy}
\begin{itemize}
\item If \texttt{f ⊔ g ↧ h₁} and \texttt{f ⊔ g ↧ h₂}, then \texttt{h₁
    ≡ h₂}.
%
\item  If \texttt{f ⊔ g ↥ c₁} and \texttt{f ⊔ g ↥ c₂}, then \texttt{c₁ ≡ c₂}.
\end{itemize}
\end{prop}
Now that we have established that our semantics is sensible we define
a function to merge edits.

\paragraph{Merge Operator}
For every pair of aligned edits \texttt{f} and \texttt{g}, binary
operator \texttt{⊔} either finds a suitable edit \texttt{h} and
provide a proof that \texttt{f ⊔ g ↧ h}, or detects a conflict
\texttt{c}, with a proof that \texttt{f ⊔ g ↥ c}.
        
\begin{minted}{agda}
_⊔_ : (f : u ⟼ v) (g : u ⟼ w) →
        (∃ λ c → f ⊔ g ↥ c) ⊎ (∃ λ h → f ⊔ g ↧ h)
\end{minted}
Operator \texttt{⊔} is outlined in Table \ref{table:merge}, where we
have omitted the obvious inequalities in conflicts.
%
Operator \texttt{⊔₃} merges \emph{aligned} edit scripts\footnote{We
  extend edit script with a special constructor \_::ᶜ\_ for
  conflicts}, by applying operator \texttt{⊔} pairwise, i.e.\
\texttt{e₁ ⊔₃ e₂ = zipWith (⊔) e₁ e₂}.
 
%

	\begin{table*}[t!]
	\centering
	\begin{tabular}{| c | c | c |}
	\hline
	\texttt{f : u \textasciitilde> v} & \texttt{g : u \textasciitilde> w} &  \texttt{f ⊔ g} 
	\\ \hline
	\texttt{Nop} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ Nop g}} 
	\\ \hline
	\texttt{Upd α α} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ (Upd α α) g}} 
	\\ \hline
	\texttt{f} & \texttt{Nop} & \textcolor{Green}{\texttt{Id₂ f Nop}} 
	\\ \hline
	\texttt{f} & \texttt{Upd α α} & \textcolor{Green}{\texttt{Id₂ f (Upd α α)}} 
	\\ \hline
	\texttt{Del α} & \texttt{Del α} & \textcolor{Green}{\texttt{Idem (Del α)}}
	\\ \hline
	\texttt{Del α} & \texttt{Upd α β} & \textcolor{Red}{\texttt{Cnf (Del α) (Upd α β) (DelUpd α β) }}
	\\ \hline
	\texttt{Upd α β} & \texttt{Del α} & \textcolor{Red}{\texttt{Cnf (Upd α β) (Del α) (UpdDel α β)}}
	\\ \hline
	\texttt{Ins α} & \texttt{Ins α} & \textcolor{Green}{\texttt{Idem (Ins α)}} 
	\\	\hline
	\texttt{Ins α} & \texttt{Ins β} & \textcolor{Red}{\texttt{Cnf (Ins α) (Ins β) (InsIns α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α β} & \textcolor{Green}{\texttt{Idem (Upd α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α γ} & \textcolor{Red}{\texttt{Cnf (Upd α β) (Upd α γ) (UpdUpd α β γ)}}
	\\ \hline
	\end{tabular}
	
	\captionsetup{singlelinecheck=false, justification=centering}

	\caption{Implementation of merge operator. \\
	 \texttt{f ⊔ g :} \textcolor{Red}{\texttt{f ⊔ g ↥ c}} \texttt{⊎} \textcolor{Green}{\texttt{f ⊔ g ↧ h}}}	 
	\label{table:merge}
	\end{table*}

% 	\paragraph{Merged Edit Script}
% 	Just like we defined a merge operator for aligned edits, we need to 
% 	define a similar operator for aligned edit scripts.
% 	However, since single merges may fail this operator cannot return 
% 	the same well-typed edit script, that we have defined before.
% 	Therefore, we introduce an alternative edit script, which is only partially 
% 	well-typed and that can include conflicts.
% \begin{minted}{agda}
% data ES₃ : List Set → Set where
%   [] : ES₃ []
%   _∷_ : {u : Val as bs} → u ⟼ v → ES₃ (as ++ xs) → ES₃ (bs ++ xs)
%   _∷ᶜ_ : {u : Val as bs} → (c : Conflict u v w) → 
%              ES₃ (as ++ xs) → ES₃ (bs ++ xs)
% \end{minted}
% 	The data type is indexed only by the source type list and it is well-typed
% 	only with respect to it. Furthermore, it provides an additional constructor
% 	for conflicts. 

        \subsection{Diff$_3$ Algorithm}
        \label{subsec:diff3-algo}
% 	The merge operator for edit scripts takes two aligned edit scripts and
% 	applies the merge operator \texttt{⊔} previously defined to
% 	each pair of aligned edits. It builds a merged edit script choosing a 
% 	suitable constructor depending on the outcome of each single merge.
%         \todo{Define this as zipWith (⊔) e1 e2}
% \begin{minted}{agda}
% merge₃ : {e₁ : ES as bs} {e₂ : ES as cs} → e₁ ⋎ e₂ → ES₃ as
% merge₃ nil = []
% merge₃ (cons f g p) with f ⊔ g
% merge₃ (cons f g p) | inj₁ (c , _) = c ∷ᶜ merge₃ p
% merge₃ (cons f g p) | inj₂ (h , _) = h ∷  merge₃ p
% \end{minted}
% 	To improve readability we will use the following infix
%         operator:
% \begin{minted}{agda}
% _⊔₃_ (e₁ : ES as bs) (e₂ : ES as cs) {{p : e₁ ⋎ e₂}} → ES₃ as
% _⊔₃_  _ _ {{p}} = merge₃ p
% \end{minted}
% 	The alignment proof is passed  as an instance argument, i.e. a
%         special  type  of  implicit arguments  that  is  automatically
%         resolved at call-sites \cite{Devriese11}.

%         In order to reason about merging, we encode the specifications
%         of the merge operator in data type \texttt{Merge₃}:

% % \begin{figure*}[t!]
% % \centering
% \todo{Drop Merge3}
% \begin{minted}{agda}
% data Merge₃ : ES xs ys → Es xs zs → ES₃ xs → Set where
%   nil : Merge₃ [] [] []
%   merge : f ⊔ g ↧ h → Merge₃ e₁ e₂ e₃ → 
%                    Merge₃ (f ∷ e₁) (g ∷ e₂) (h ∷ e₃)
%   conflict : f ⊔ g ↥ c → Merge₃ e₁ e₂ e₃ → 
%                     Merge₃ (f ∷ e₁) (g ∷ e₂) (c ∷ᶜ e₃)
% \end{minted}
% \caption{Merge operator specification}
% \label{fig:merge3}
% \end{figure*}

%         We now prove that our merge operator fulfills its requirements.
% \begin{prop}[\texttt{⊔₃} is correct]
% \label{prop:merge3-correct}
% Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts such that,
% \texttt{e₁ ⋎ e₂}, then:
% \center{\texttt{e₃ ≡ e₁ ⊔₃ e₂ ⇔ Merge₃ e₁ e₂ e₃}}
% \end{prop}
% \begin{proof}
% The if direction follows by induction on \texttt{e₁ ⋎ e₂}.
% The iff direction follows by induction on \texttt{Merge₃ e₁ e₂ e₃} and 
% relies on properties \ref{prop:mutually-exclusive} and \ref{prop:determinancy}.
% \end{proof}
        
        % Now that we have shown that the merge operator is in a
        % one-to-one relationship with the specification data type, we
        % will use the latter to reason more conveniently about its
        % properties.

	% \paragraph{Diff3}
	We conclude this Section giving a generic \texttt{diff₃}
        algorithm for typed trees.
        %
        % We follow the conventional interface, in which the second
        % argument is considered \emph{base}:
\begin{minted}{agda}
diff₃ : HTree a → HTree a → HTree a → Conflicts ⊎ HTree a
diff₃ y x z with align (diff [ x ] [ y ]) (diff [ x ] [ z ])
... | (e₁* , e₂*) = typecheck (e₁* ⊔₃ e₂*)
\end{minted}
	Following the conventional interface, the second argument
        \texttt{x} is considered the \emph{base} version, therefore it
        is diffed against \texttt{y} and \texttt{z}, using a
        \texttt{diff} algorithm that meets Requirement
        \ref{req:diff-specs}.
        %
        Function \texttt{align} aligns the edit scripts obtained by
        diffing the base version with the new versions, extending them
        with \texttt{Nop} operations.
        %
        The call to this function is \emph{sound}, because dependent
        types can capture that those edit scripts share the same
        \emph{source} list \texttt{[ x ]}.
        %
        Edit scripts \texttt{e₁*} and \texttt{e₂*} are aligned by
        Proposition \ref{prop:align-ext} and are merged by operator
        \texttt{⊔₃}.
        %
        We now proceed to explain the non-standard function
        \texttt{typecheck}.
        %
        
\paragraph{Type Checking}
A merged edit script must be type-checked to ensure that it actually
produces a \emph{target} object, that is well-typed.
%
Clearly, a conflict makes a script ill-typed, because the \emph{target}
value is undefined.
%
Surprisingly enough a conflict-free edit script may still be
ill-typed.
%
This is counter-intuitive because the two input edit scripts are
singularly well-typed and one might expect that, without conflicts,
their fusion should also be well-typed.
%

\paragraph{Example} Consider for instance the following \emph{aligned}
edit scripts:
\begin{minted}{agda}
e₁ e₂ : ES [] [List Int]
e₁ = [Ins [], Nop]
e₂ = [Nop, Ins []]
\end{minted}
The merge operator \texttt{e₁ ⊔₃ e₂} yields script \texttt{[Ins [],
  Ins []]}, which is conflict-free, yet ill-typed, because the first
insert produces a constructor that does not take any arguments, but
the tail of the script yields another empty list as argument.
%
The culprit is that operator \texttt{⊔₃} merges edits \emph{pairwise},
therefore the whole merged script may alternatively follow either of
the input scripts.
%
There is no guarantee that this pattern actually retains type-safety:
the script must be explicitly type-checked!
%
The typing judgment \texttt{e ⇓ as} states that the edit script
\texttt{e} is well typed and produces a list of type \texttt{HList
  as}.
%
The typing rules are straightforward and a trivial inference algorithm
can be read off them.
\begin{mathpar}
          \inferrule
          {}
          {\texttt{[] ⇓ []}}
          \and
          \inferrule
          {\texttt{f : v \textasciitilde> w} \\ 
           \texttt{w : C cs ds} \\
           \texttt{e ⇓ cs ++ ys}}
          {\texttt{f ∷ e ⇓ (ds ++ ys)}}
\end{mathpar}
%
% Note
% Even though merging might succeed without triggering any conflict the
% merged edit script might be invalid, i.e.\ it will not produce a
% well-typed object as \emph{target}.
%         %
        
%   Moreover note that the conflict cons constructor (\texttt{∷ᶜ})
% is not mentioned in the typing rules, therefore edit scripts
% containing conflicts are ill-typed.  Edit scripts of type \texttt{ES₃}
% can be converted to \texttt{ES}, if they are well typed:
% \begin{minted}{agda}
% ⌜_⌝  : (e : ES₃ xs) → {{q : e ⇓ ys}} → ES xs ys
% \end{minted}

\paragraph{Discussion}
While \texttt{diff} is type-safe, i.e.\ it always produces a
well-typed edit script, it is quite disappointing that we cannot make
\texttt{diff3} type-safe, not even in absence of conflicts and with
dependent-types available.
%
The problem becomes evident in the type of the merge operator
\texttt{⊔₃ : ES xs ys -> ES xs zs -> ES xs ?}, what type should we put
instead of the question mark?
%
If \texttt{ys ≡ zs}, like inside \texttt{diff3}, the question is
trivial, but otherwise there is no ``right'' type.
%
An arbitrary choice, that is either \texttt{ys} or \texttt{zs}, is
unsatisfactory, because it makes the algorithm asymmetric: we would
expect \texttt{e₁ ⊔₃ e₂} to produce the same result as \texttt{e₂ ⊔₃
  e₁}, but the two scripts have even different types!
%
An existential type, i.e. \texttt{∃ ws . ES xs ws} is too ``general''.
In order to add an edit, say \texttt{Ins α}, with \texttt{α : C as a},
list \texttt{ws} should have prefix \texttt{as}, i.e.\ \texttt{ws ≡ as
  ++ ws'}, but \texttt{ws} is just \emph{some} list.
%
Unfortunately, we acknowledge that our \texttt{diff3} algorithm may
fail in yet another way, besides proper conflicts, that is by
producing an ill-typed script.

\section{Properties}
\label{sec:properties}
%
The multitude of works in change detection and data reconciliation
\cite{...} shows that a variety of different design choices are
possible, when implementing diffing and merging algorithms, each
leading to fundamental differences and tread-offs between precision,
performance and reliability.
%
In this section we present and motivate our design choices, while in
Section \ref{sec:related-work}, we discuss and compare them with
possible alternatives.
%
We show that our algorithms meet these choices, by defining properties
that clearly describe their semantics.
%
We remark that we have formalized and mechanically verified these
properties in Agda, using the model presented in this paper.
%
In the following, we will write \texttt{f ∈ e} and \texttt{c ∈ e} to
denote that edit \texttt{f} and conflict \texttt{c} occurs in script
\texttt{e} respectively and \texttt{α ∈ hs} if node \texttt{α}
occurs in list \texttt{hs}.
%
Furthermore we consider only edit-related conflicts \texttt{c :
  Conflict u v w}.
  
\subsection{Conflict Conditions}
The semantics of widespread merging algorithms, such as GNU
\texttt{diff3} is not mathematically formalized, but it is rather
approximately understood either empirically, and sometime largely
misunderstood, due to incorrect intuitions \cite{PierceDiff3}.
%
As a result, users often struggle to predict the outcome of complex
merge operations and end up facing unexpected conflicts.
%
The following property document precisely sufficient and necessary
conditions, that will trigger a conflict in a merge.
%
\begin{thm}[Conflict Conditions]
\label{thm:conflict-conds}
  Given objects \texttt{o}, \texttt{x}, \texttt{y}, 
  then \texttt{diff3 x o y} raises a conflict \texttt{c} if and only if
  there are two aligned edits \texttt{f} and \texttt{g}, such that
  \texttt{f ∈ (diff o x)}, \texttt{g ∈ (diff o y)}, and \texttt{f ⊔ g ↥ c}.
\end{thm}
Informally, Theorem \ref{thm:conflict-conds} asserts that merging
results in a conflict uniquely if there are two edits that are
\emph{aligned} and \emph{conflicting}.
%
The conflict and merge semantics, described in Section
\ref{subsec:merge-semantics} makes Theorem very intuitive and easy to
prove, but this does not diminish its importance.
%
For instance, a direct consequence of Theorem \ref{thm:conflict-conds}
is a sound \emph{locality} principle for \texttt{diff3}, which
guarantees that modifying independent, i.e. \emph{unaligned}, parts,
will not trigger any conflict.
%
Note that the same principle in GNU \texttt{diff3}, has been only
recently clarified and precisely formalized \cite{PierceDiff3}.

\subsection{Sanity Conditions}
The properties discussed in this section act as sanity conditions,
ensuring that \texttt{diff} and \texttt{diff3} behave properly.
%
Firstly, the \emph{data origin} property ensures that \texttt{diff}
processes every node of the input objects and only those, i.e.\ it
does not ``make up'' nodes.
%
Intuitively nodes are atomic blocks that cannot be modified, but
either inserted, replaced or discarded as a whole, ensuring users that
their data may not corrupted in the diffing process.
%
Secondly, the \emph{edit origin} property gives further guarantees
about the semantics of merge, namely that there is at least one script
accountable for every edit found in a merged script ---both scripts
may bear the same change independently (axiom \texttt{Idem}).
%
%
%We start with some auxiliary definitions and lemmas.
% Firstly we give some auxiliary definitions that will be used to
% state and prove
% this properties.
%     \paragraph{Membership}
%     The type \texttt{α ∈ hs} denotes that the node \texttt{α} is present
%     in the list of trees \texttt{hs}.

% \begin{minted}{agda}
% data _∈_ : C xs a → HList ys → Set where
%   here : (α : C as a) → α ∈ Node α hs₁ ∷ hs₂
%   there : α ∈ (hs₁ +++ hs₂) → α ∈ Node β hs₁ ∷ hs₂
% \end{minted}
%     A similar data type denotes the presence of an edit in a script.
% \begin{minted}{agda}
% data _∈ₑ_ : v ⟼ w → ES xs ys → Set where
%   here : (f : v ⟼ w) → f ∈ₑ f ∷ e
%   there : f ∈ₑ e → f ∈ₑ g ∷ e
% \end{minted}
    % Lastly the judgment \texttt{e ⊢ₑ u ⟼ v} denotes that
    % the script \texttt{e} contains some edit of type \texttt{u ⟼ v}.
% \% begin{definition}[Edit Mapping]
% An edit script \texttt{e} maps source value \texttt{u} into
% target value \texttt{v}, written \texttt{e ⊢ u ⟼ v}, if and
% only if there is an edit \texttt{f : u ⟼ v} such that \texttt{f ∈ e}.
% \end{definition}

% I think I will skip this one and directly state the more interesting one
% \begin{minted}{agda}
%    ∀   f : ⟨ α ⟩ ⟼ v  .  f ∈ₑ e   ⇒   α ∈ ⟪ e ⟫
%    ∀   f : v ⟼ ⟨ α ⟩  .  f ∈ₑ e   ⇒   α ∈ ⟦ e ⟧
% \end{minted}

% The following property shows that in an edit script a source (target)
% node is correctly part of the source (target) object.
% %
% In other words the source function \texttt{⟪\_⟫} and target function
% \texttt{⟦\_⟧} do not forget any node.
% \begin{prop}[\texttt{⟪\_⟫} and \texttt{⟦\_⟧} are correct]
% \label{prop:source-target-cmp}
% Given an edit script \texttt{e} and a node \texttt{α} then.
% If \texttt{e ⊢ ⟨ α ⟩ ⟼ v} then \texttt{α ∈ ⟪ e ⟫}.
% Similarly if \texttt{e ⊢ v ⟼ ⟨ α ⟩} then \texttt{α ∈ ⟦ e ⟧}.
% \end{prop}
We now formally state the \emph{data origin} and \emph{edit origin} property.
\begin{prop}[Data and Edit Origin]
\label{prop:sanity}
Let \texttt{α} be a node and \texttt{e = diff x y}:
\begin{itemize}
\item \texttt{α ∈ x} iff there exits \texttt{f : ⟨ α ⟩ ⟼ v}, such that
  \texttt{f ∈ e}.
\item \texttt{α ∈ y} iff there exits \texttt{f : v ⟼ ⟨ α ⟩}, such that
  \texttt{f ∈ e}.
\item If \texttt{f ∈ (e₁ ⊔₃ e₂)} then either \texttt{f ∈ e₁} or
  \texttt{f ∈ e₂}.
\end{itemize}
\end{prop}

% \begin{proof}
%   It follows directly from Requirement \ref{req:diff-specs} and Proposition
%   \ref{prop:diff-correct} (requirements and specifications of
%   \texttt{diff}) and Proposition \ref{prop:source-target-cmp}.
% \end{proof}

% We now formally state the \emph{data retention} property.
% \begin{prop}[Data Retention]
% \label{prop:data-retention}
%   Let \texttt{x} and \texttt{y} be two heterogeneous lists, let
%   \texttt{e = diff x y} and let \texttt{α} be a node.
% %
%   If \texttt{α ∈ x} then there is a target value \texttt{v} such that
%   \texttt{e ⊢ ⟨ α ⟩ ⟼ v}.
% %
%   Similarly if \texttt{α ∈ y} then there is a source value \texttt{v} such that
%   \texttt{e ⊢ v ⟼ ⟨ α ⟩}.
% \end{prop}
% \begin{proof}
%   It follows from Requirement \ref{req:diff-specs} and Proposition
%   \ref{prop:diff-correct} (requirements and specifications of
%   \texttt{diff}) and by induction on \texttt{α ∈ x}.
% \end{proof}
 
% We give now similar safety properties for our \texttt{diff₃}
% algorithm.
% We firstly discuss \emph{edit origin}, a generalization of
% \emph{data origin}
% that ensures that every edit present in the merged script comes from
% either
% of the input scripts.

Unfortunately, the properties proved in Proposition \ref{prop:sanity}
are not enough to characterize a useful merge algorithm.
%
Crucially, \emph{Edit Origin} asserts that if an edit is presented in
the merged script, then it is part of either the input scripts, but it
does not guarantee that \texttt{f} will actually end up in the merged
script.
%
A merge operator that merely returns an empty script (\texttt{e₁ ⊔₃ e₂
  = []}) would satisfy this property, but clearly it does not do
anything useful at all.
%
Proposition \ref{prop:maximality} proves \emph{maximality}, which
forces the merge operator to yield every edit that can be obtained
by merging aligned edits from the input scripts.

\begin{prop}[Maximality]
  \label{prop:maximality}
  For every pair of aligned edit scripts \texttt{f} and \texttt{g},
  such that \texttt{f ∈ e₁}, \texttt{g ∈ e₂}, if \texttt{f ⊔ g ↧ h}
  then \texttt{h ∈ (e₁ ⊔₃ e₂)}.
\end{prop}

\subsection{Persistence}
Persistence is a property that establishes how conflicting edits,
e.g.\ \texttt{∅ ⟼ ⟨ \textcolor{magenta}{1} ⟩} and \texttt{∅ ⟼ ⟨
  \textcolor{magenta}{2} ⟩}, should be handled during merging.
%
Persistence promises to \emph{never} back out user's changes, hence it
gives up \emph{convergence}, i.e.\ the guarantee to produce a merged
object, and raises a conflict when it is not possible to soundly merge
edits \cite{Pierce07}.
%
Inspired by GNU \texttt{diff3}, we have opted for \emph{persistence}:
Theorem \ref{thm:persistence} proves that \texttt{⊔₃} is persistent.

% We now formally state and prove that our merge algorithm is
% \emph{persistent}.  This property is very important because conflicts
% are triggered by changes, hence a non-persistent algorithm could
% back-out changes to avoid raising conflicts.

    % \paragraph{Persistence}
    % The converse property asserts that an edit present in one of the input
    % edit scripts will be found in the merged edit script, given that it does
    % perform a change and that the output script does not contain conflicts.
    % The first hypothesis is needed because identity edits can be silently 
    % ignored in the merge semantics by either \texttt{Id₁} or
    % \texttt{Id₂}.
    % On the other hand the second prerequisite is essential, because 
    % our algorithm is \emph{persistent}, i.e.\ it refuses to back out changes 
    % made by incompatible edits, but triggers an appropriate conflict instead.

    % Firstly an edit does perform a change if it is not an identity edit, or, in 
    % other words if the source and the target values are different.
				
\begin{thm}[Persistence]
\label{thm:persistence}
Let \texttt{e₃ = e₁ ⊔₃ e₂}, \texttt{f : u ⟼ v}, such that \texttt{u ≢
  v} and \texttt{f ∈ e₁} (\texttt{f ∈ e₂}), then either \texttt{f ∈
  e₃} or there exists a conflict \texttt{c} such that \texttt{c ∈ e₃}.
\end{thm}
Note that edit \texttt{f} represents a change edit because \texttt{u ≢
  v} ---it could have been an identity edit and overwritten by another
change edit due to axiom \texttt{Id₁} (\texttt{Id₂}) otherwise.
%
Persistence guarantees not to back out \texttt{f}, therefore either
\texttt{f} is part of the merged edit (\texttt{f ∈ e₃}), or it
triggers a conflict (\texttt{c ∈ e₃}).
%

% \begin{proof}
%   The proof is by induction on \texttt{Merge₃ e₁ e₂ e₃} (from Property
%   \ref{prop:merge3-correct}) and \texttt{f ∈ₑ e₁}.
%     % 
%     In the base case edit \texttt{f} is merged with some other edit
%     \texttt{g}, then either \texttt{f ⊔ g ↥ c} or \texttt{f ⊔ g ↧ h}.
%     %
%     In the former case we are done because \texttt{f} raises a
%     conflict.  In the latter case we proceed by case analysis on
%     \texttt{f ⊔ g ↧ h}.
%     %
%     The merged edit \texttt{h} is either \texttt{f} (case \texttt{Id₂}
%     or \texttt{Idem}), or \texttt{g} (\texttt{Id₁}). In the first case
%     we are done, because \texttt{f} occurs in the merged script.
%     %
%     The second case is contradictory because we assumed \texttt{u ≢
%       v}.
% \end{proof}        

%     The theorem holds also when the edit belongs to the other script and
%     the proof is entirely symmetrical.
   		
\subsection{Structural Invariant}
When diffing and merging tree-like data, it suddenly becomes difficult
to predict how edits may change its structure, especially if
compared with the ``flat'' structure of data handled by line-based
\texttt{diff3}.
%
In this section, we present a structural invariant, which retains some
order between nodes and their relative positions, thus characterizing
how the shape of structured data may change.
%    

\paragraph{Depth-First Pre-Order}
An edit script describes how to transform a source object into a
target object, by traversing the former in \emph{depth-first
  pre-order} and mapping its nodes into the nodes of the latter.
%
Interestingly, the embedding preserves depth-first pre-order: if a
source node comes before another then the mapping of the first will
come before the mapping of the second.
%
However, nodes are not only mapped (updated) from the source to the
target, but they may also be inserted and removed, therefore the
structural invariant must be adjusted to take these edits into
account.
%
Intuitively the order is preserved because nodes that are mapped first
in a script precede those that are mapped later ---since edit scripts
are a flat list-like data structure, we simply order edits according
to their position in the script.
% %
% A pre-order depth-first traversal consists of firstly visiting the
% current node and then traversing recursively its subtrees from the
% leftmost to the rightmost.  
% %
% The traversal induces an ordering on the nodes, so that those that are
% visited sooner come before those that are processed later.  Since edit
% scripts work with list of trees, we have to generalize the ordering
% accordingly.
    
% The type \texttt{hs ⊢ α ⊏ β} denotes that the node \texttt{α} comes
% before the node \texttt{β}, according to depth first traversal of the
% trees contained in the list of trees \texttt{hs}.  \todo{Probably drop
%   data type. Better notation?}
% \begin{minted}{agda}
% data _⊢_⊏_ : Hist xs → C as a → C bs b → Set where
%   here : β ∈ (hs₁ +++ hs₂) → Node α hs₁ ∷ hs₂ ⊢ α ⊏ β
%   there : (hs₁ +++ hs₂) ⊢ α ⊏ β → Node γ hs₁ ∷ hs₂ ⊢ α ⊏ β
% \end{minted}

% Intuitively the list is used as a stack, so that after visiting each
% node its children, yet to be traversed, are pushed on the stuck.  Note
% that those trees will be visited before those already on the stuck,
% hence following correctly the depth-first traversal.

% \begin{definition}[Edit Order]
% Given an edit script \texttt{e} and two edits \texttt{f} and \texttt{g}, we write
% \texttt{e ⊢ f ⊏ g} if and only if \texttt{f} precedes \texttt{g} in \texttt{e}.
% \end{definition}

% Before stating the main theorem relies on two fundamental properties:
% that the target (source) function and \texttt{diff} are
% \emph{order-preserving} (OP).
% %
% Property \ref{prop:order-preserving-target-fun} guarantees that the
% relative order of edits in a script corresponds to the depth-first
% order of their target (source) nodes in the target (source) objects.
% %
% Property \ref{prop:order-preserving-embedding} ensures that if in the
% target (source) object a node precedes another, then in the diff
% script the first node is produced by an edit that comes before the
% edit that produces the second.

% \begin{prop}[\texttt{⟦\_⟧} is OP]
% \label{prop:order-preserving-target-fun}
% Let \texttt{e} be an edit script and \texttt{f} and \texttt{g} edits
% of type \texttt{v ⟼ ⟨ α ⟩} and \texttt{w ⟼ ⟨ β ⟩}, such that
% \texttt{e ⊢ f ⊏ g}, then \texttt{⟦ e ⟧ ⊢ α ⊏ β}.
% \end{prop}
%   We omit the symmetrical property for \emph{source} nodes and objects.

% \begin{prop}[Embedding is OP]
% \label{prop:order-preserving-embedding}
% Let \texttt{x} and \texttt{y} be heterogeneous lists and let 
% \texttt{e} be an edit script such that \texttt{e = diff x y}.
% Let also \texttt{α} and \texttt{β} be nodes such that \texttt{y ⊢ α ⊏ β}.
% Then there are edits \texttt{f : u ⟼ ⟨ α ⟩} and \texttt{g : v ⟼ ⟨ β ⟩}
% such that \texttt{e ⊢ f ⊏ g}.
% \end{prop}
% \begin{proof}
%   The proof relies on Requirement \ref{req:diff-specs} and Proposition
%   \ref{prop:diff-correct} (requirements and specifications of
%   \texttt{diff}).
%   %
%   By induction on \texttt{y ⊢ α ⊏ β} we locate \texttt{f : u ⟼ ⟨ α ⟩}
%   in \texttt{e}. 
%   %
%   By Proposition \ref{prop:data-retention} it follows that there
%   exists \texttt{g : v ⟼ ⟨ β ⟩} in the tail of \texttt{e}.
% \end{proof}
% We again omit the dual property for \emph{source} nodes and object.

\paragraph{Order Invariant}
The order-invariant property ensures that \texttt{diff} preserves the
depth-first order of the source (target) objects:


% If \texttt{α} precedes \texttt{β} in the source object of script
% \texttt{e}, then one of the following holds:
%     \begin{itemize}
%     \item Node \texttt{α} is deleted in \texttt{e};
%     \item Node \texttt{β} is deleted in \texttt{e};
%     \item Node \texttt{α} is mapped to some node \texttt{γ} and node
%       \texttt{β} is mapped to some node \texttt{φ}, such that node
%       \texttt{γ} comes before node \texttt{φ} in the target object.
%     \end{itemize}

% We now prove our main theorem, which ensures that
% \texttt{diff} preserves the relative order of nodes in the
% source (target) objects.
% %
%
    % We show only the theorem about the \emph{source} object, because
    % the other is symmetrical.
\begin{thm}[\texttt{diff} is OP]
Let \texttt{e = diff x y} and nodes \texttt{α} and \texttt{β},
such that \texttt{α} precedes \texttt{β} in \texttt{x} (\texttt{y}).
Then one of the following holds.
\begin{itemize}
\item Node \texttt{α} is deleted in \texttt{e}.
\item Node \texttt{β} is deleted in \texttt{e}.
\item Node \texttt{α} is mapped to some node \texttt{γ}, node
  \texttt{β} is mapped to some node \texttt{φ}, such that
  \texttt{γ} comes before node \texttt{φ} in \texttt{y}.
  % \texttt{e ⊢ ⟨ α ⟩ ⟼ ∅} or \texttt{e ⊢ ⟨ β ⟩ ⟼ ∅} or there exists
  % nodes \texttt{γ} and \texttt{φ} such that \texttt{e ⊢ ⟨ α ⟩ ⟼ ⟨ γ
  %   ⟩}, \texttt{e ⊢ ⟨ β ⟩ ⟼ ⟨ φ ⟩} and \texttt{y ⊢ γ ⊏ φ}.
\end{itemize}
\end{thm}
% \begin{proof}
%   By Proposition \ref{prop:order-preserving-embedding} there are edits
%   \texttt{f : ⟨ α ⟩ ⟼ u} and \texttt{g : ⟨ β ⟩ ⟼ v}, such that
%   \texttt{e ⊢ f ⊏ g}.
%   %
%   By case analysis either \texttt{u = ∅} or \texttt{v = ∅} or \texttt{u = ⟨ γ ⟩}
%   and \texttt{v = ⟨ Φ ⟩}. In the first (second) case \texttt{α} (\texttt{β}) is deleted and we are done.
%   In the third case they are both updated, i.e.\ \texttt{e ⊢ ⟨ α ⟩ ⟼ ⟨ γ ⟩} and
%   \texttt{e ⊢ ⟨ β ⟩ ⟼ ⟨ φ ⟩}.
%   %
%   By Proposition \ref{prop:order-preserving-target-fun} we deduce that
%   \texttt{⟦ e ⟧ ⊢ γ ⊏ Φ} and by Requirement \ref{req:diff-specs} and
%   Proposition \ref{prop:diff-correct} (requirements and specifications
%   of \texttt{diff}) it follows that \texttt{y ⊢ γ ⊏ Φ}.
% \end{proof}

% We now generalize the \emph{order invariant} property to
% \texttt{diff₃}, which guarantees that the relative order of edits in
% each input script is preserved in the merged script.
% %
% Note that the property is restricted only to successful merges and
% furthermore only to \emph{non-identity} edits, since they could 
% ne be excluded in favor of proper changing edits otherwise.
% %
% The property holds intuitively because the merge algorithm does not
% rearrange the input edits, but rather merge them pointwise, retaining
% the original order in the merged script.
% %
% \todo{Better! Give me a take home message!}
% \begin{thm}[\texttt{diff₃} is OP]
%   Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts such
%   that \texttt{e₁ ⋎ e₂}, \texttt{e₃ = e₁ ⊔₃ e₂} and \texttt{e₃} does not
%   contain conflicts.
% %
%   Let \texttt{f} and \texttt{g} be edits of type \texttt{u ⟼ v} and
%   \texttt{w ⟼ z} such that \texttt{u ≢ v}, \texttt{w ≢ z} and
%   \texttt{e₁ ⊢ f ⊏ g}, then \texttt{e₃ ⊢ f ⊏ g}.
% \end{thm}
%   The theorem holds also with respect to the edits contained in \texttt{e₂}.

\section{Example Revised}
\label{sec:haskell}
In this section, we revisit the motivating example from Section
\ref{sec:intro} using our fine-grained merge algorithm and show that
it performs better than line-based \texttt{diff3}.
%
Furthermore while presenting this example we show the API of the
Haskell library that implements our algorithm.
%
Haskell can only partially simulate dependently typed programming,
therefore the library cannot enforce certain invariants of the
original model, in particular \emph{aligmentent} of scripts, which are
instead checked at run-time.
%
On the other hand, the Haskell implementation has much better
performance, an essential requirement to make our algorithm practical.
%

\subsection{Data  Representation}
In our model, the abstract type \texttt{C as a} encodes a constructor
of algebraic data type \texttt{a}, that takes arguments \texttt{as}.
%
In the library\todo{Here link}, we implement this representation using
a Generalized Algebraic Data Type (GADT), indexed by a list of types
and a target type\footnote{Lists are automatically lifted to the type
  level and share the same term-syntax. A tick distinguishes lifted
  lists of kind \texttt{[ * ]}, e.g. \texttt{'[]}, from the type of
  homogeneous lists of kind \texttt{*}, e.g. \texttt{[]}.}.
%
Each data type constructor is represented by a different constructor,
which instantiates the first index with the type of its arguments and
the second with the resulting type.
%
\paragraph{Example}
For example, data type \texttt{ListC} encodes the list constructors:
\begin{minted}{haskell}
data ListC (as :: [ * ]) (a :: *) where
  Nil :: ListC '[] [a]
  Cons :: ListC '[a , [a]] [a]
\end{minted}
Constructor \texttt{Nil} represents the empty list constructor ---it
takes no argument (\texttt{'[]}) and produce type \texttt{[a]}.
%m
Constructor \texttt{Cons} represents the cons constructor, which
takes two arguments, the head of the list and the tail of the list
\texttt{'[a , [a]]} and produces a list of type \texttt{[a]}.
%
Observe that, \texttt{Nil} and \texttt{Cons} represent \emph{polymorphic}
constructors.
%

%
This representation encodes also primitive types, i.e.\ non algebraic
data types, such as integer.
%
Since they may assume many values, they are all combined in a single
constructor, whose index declares that it does not take any argument
(\texttt{'[]}), while, in reality, it stores the actual value.
\begin{minted}{haskell}
data IntC xs a where
  I :: Int → IntC '[] Int
\end{minted}
Thanks to polymorphism, these two encoding are sufficient for our to
revisit our initial example: we represent a CSV table as lists of
lists of integers.
\begin{minted}{haskell}
type Csv = [[Int]]
\end{minted} 

\subsection{Diffing}
Since \texttt{diff3} relies on \texttt{diff}, our library defines type
class \texttt{Diff a}, for types \texttt{a} that support diffing.

\begin{minted}{haskell}
class Typeable a => Diff a where
  type Encoding a :: [ * ] → * → *
  toHTree :: a → HTree a
  fromHTree :: HTree a → a
  (=?=) :: C xs a → C ys a → Maybe (xs :~: ys)
\end{minted}
%  distance :: C xs a → C ys a → Double
The associated type family \texttt{Encoding a} returns the concrete
data type that encodes the constructors of \texttt{a}.
%
The type synonym \texttt{C} is used to improve readability of signatures
and for consistency:
\begin{minted}{haskell}
type C xs a = (Encoding a) xs a
\end{minted}
% \todo{You can also do it with another type class parameter and functional 
% dependencies but it is worse in end.}
%
Methods \texttt{toHTree} and \texttt{fromHTree} are \emph{inverse}
functions that embed a value into and from the generic representation.
% 
% The universe used in the implementation corresponds precisely to that
% of the model, except that it requires a \texttt{Diff} instance for
% every child of a node.
%
% \begin{minted}{haskell}
% data HList xs where
%   HNil :: HList []
%   HCons :: Diff a => HTree a → HList as → HList (a : as)
%
% data HTree a where
%   Node :: C as a → HList as → HTree a
% \end{minted}
%
% This definition automatically ensures that the whole family of mutually recursive 
% types have a \texttt{Diff} instance.
%
Method \texttt{(=?=)} tests equality between constructors of the same
data type, and if so it returns a proof that their field types are
equal. This operator is used both in the diff and merge algorithm both
to merge edits.
%
% The function \texttt{distance} computes the cost of an update between
% constructors of the same type and it is expected to be a
% \emph{metric}.

% \begin{definition}[Metric]
% \label{par:Metric}
% A metric on a set A is a function
% d : (A × A) → ${\rm I\!R}$ such that $\forall$ x, y, z $\in$ A:
% 	\begin{align*}
% 		d(x, y) &\geq 0 \quad &\mbox{\emph{{(non-negativity)}}}\\ 
% 		d(x, y) &= 0 \Leftrightarrow x = y \quad &\mbox{\emph{(coincidence axiom)}} \\		
% 		d(x, y) &= d(y, x) \quad &\mbox{\emph{(symmetry)}}\\
% 		d(x, z) &\leq d(x, y) + d(y, z) \quad &\mbox{\emph{(triangle inequality})}
% 	\end{align*}	
% \end{definition}

For instance, in \texttt{diff} it is used to compute the
\emph{discrete distance}, and find a minimal length edit script:
	\[ d(x, y) = 
		\begin{cases} 
			0 \quad &\mbox{if } x = y \\
			1 \quad &\mbox {otherwise}		
		\end{cases} \]	
%
Lastly, superclass \texttt{Typeable} provides methods to inspect
and compare types at run-time.
%
In \texttt{diff} and \texttt{diff3} algorithms, these methods are
needed to check whether two constructors are of the same data type and
to type-check a merged edit script respectively.

\paragraph{Example}
Diffing tables requires only two \texttt{Diff} instances, one for
integers and one for lists.
%
In fact given the \texttt{Diff} instance for the content type, we can
derive a \texttt{Diff} instance for lists of them, so that
\texttt{Diff [Int]} is derived from \texttt{Diff Int}, and
\texttt{Diff [[Int]]} from the previous one.

\begin{minted}{haskell}
instance Diff a => Diff [a] where	
  type Encoding [a] = ListF

  Nil =?= Nil = Just Refl
  Cons =?= Cons = Just Refl
  _ =?= _ = Nothing

  toHTree [] = Node Nil HNil
  toHTree (x : xs) = Node Cons (HCons (toHTree x) hs)
    where hs = HCons (toHTree xs) HNil

  fromHTree (Node Nil HNil) = []
  fromHTree (Node Cons (HCons t (HCons ts HNil))) 
    = fromHTree x : fromHTree ts
\end{minted} 
%
Note that when comparing primitive type ``constructors'',
we have to compare the actual value, to establish 
that they represent the ``same'' constructor.
\begin{minted}{haskell}
instance Diff Int where
  type Encoding Int = IntF

  (I x) =?= (I y) = if x == y then Just Refl else Nothing
  
  toHTree x = Node (I x) HNil
  
  fromHTree (Node (I x) HNil) = x
\end{minted}
%
% Tables are just lists of list of integers, so that the same list
% \texttt{Diff} instance is used twice, once to derive \texttt{Diff
%   [Int]} from \texttt{Diff Int} and then to automatically derive
% \texttt{Diff [[Int]]} from it.
%
% In both the instances we used \emph{discrete distance}, however
% depending on the specific domain more fine grained distance measure
% could be used to get more precise diffs.

\paragraph{Algorithm}
A  \texttt{diff} algorithm takes as input two objects and outputs an
edit script that reports the differences between them.
%
In particular, GNU \texttt{diff} finds a \emph{minimal length} edit
script, or equivalently the \emph{longest common subsequence} of its
inputs \cite{Berg00, PierceDiff3}, that is a script which 
copies as many lines as possible.
%
Our library detects differences between two values by means of function \texttt{gdiff}:
\begin{minted}{haskell}
gdiff :: (Diff a, Diff b) => a → b → ES '[ a ] '[ b ]
\end{minted}
%
Our \texttt{diff} algorithm is mostly an extension of that of
Lempsink's et al.\ therefore we omit it.
%
We only remark that we have adjusted the edit script length function,
in order to take into account update edits, whose cost is given by the
\emph{discrete distance} function, when computing its score.
%
% \begin{minted}{haskell}
% cost :: ES xs ys -> Int
% cost End = 0
% cost (Ins x e) = 1 + cost e
% cost (Del x e) = 1 + cost e
% cost (Upd x y e) = if x =?
% \end{minted}
%
Observe that using discrete distance, a single update edit is
preferred to a delete and a subsequent insert.
%
\paragraph{Patch}
Our library provides also a generic \texttt{patch} function, which corresponds
to the target function \texttt{⟦\_⟧} of the model.
\begin{minted}{haskell}
gpatch :: ES xs ys → HList ys
\end{minted}

We remark that contrary to that of Lempsink's \cite{Lemp09} the
function is total and furthermore does not need the source object to
compute the target object, since the edit script alone contains all
the information necessary to reconstruct it.

\subsection{Merging}
Merging consists in diffing the base version with respect to each new
version, producing two edit scripts that are combined following the
three-way merge technique.
%
The merge may fail either due to some conflict or because it generates
an ill-typed script.
%
Our library merges objects in this way by means of function \texttt{gdiff3}:
\begin{minted}{haskell}
gdiff3 :: Diff a => a → a → a → Either [Conflict] (ES '[ a ] '[ a ])
gdiff3 x o y = typecheck $ merge e1 e2
  where e1 = gdiff [ toHTree o ] [ toHTree x ]
         e2 = gdiff [ toHTree o ] [ toHTree y ]
\end{minted}
The input objects are transformed into our generic encoding by
\texttt{toHTree} and diffed with respect to the original version.
%
For the sake of brevity, we lift list syntax to heterogeneous lists,
so that \texttt{[ toHTree o ] :: HList '[ a ]} is a singleton list
containing the \texttt{HTree a} representation of \texttt{o}.
%
Edit scripts \texttt{e₁} and \texttt{e₂} are merged by function
\texttt{merge}, which implements the merge operator \texttt{⊔₃}.
%
While in Agda we can exploit full-fledgeg dependent type to ensure
that \texttt{⊔₃} takes only \emph{aligned} edit scripts,
\texttt{merge} is less finely typed and must therefore
\emph{dynamically} check alignment of each pair of edits.
%
 and
produces a merged edit script that is lastly typechecked by function
\texttt{typecheck}.
%

\paragraph{Example}
Variables \texttt{a}, \texttt{b} and \texttt{c} represent the tables
of the example from the introduction:
\begin{minted}{haskell}
a :: Csv
a = [[1,2,3],
      [4,5,6],
      [7,8,9]]

b :: Csv
b = map (0 :) a

c :: Csv
c = [[1,2,3],
      [4,5,9],
      [7,8,15]]
\end{minted}
Merging them using \texttt{gdiff3} succeeds and gives the expected table:
\begin{verbatim}
Main> let Right e = gdiff3 b a c
Main> gpatch e
[[0,1,2,3], [0,4,5,9], [0,7,8,15]]
\end{verbatim}



% \subsection{Example}
% Interactive session with initial example revised.

\section{Discussion and Related Work}
\label{sec:related-work}
Research in the field of change detection and merge has produced a
variety of tools that address these problems.  Many focus on XML
files, such as LaDiff \cite{Chawathe96}, MH-Diff \cite{Chawathe97} and
3DM \cite{Lind01, Lind04, Lind05}.  We refer to Peters for a
comprehensive survey \cite{PetersSurvey}.
%
Other works address file and data synchronization, which raises
problems similar to those discussed in this paper. Relevant examples
include Unison, a file synchronizer \cite{Pierce98, UnisonSpec};
Harmony, a synchronizer for heterogeneous data
\cite{HarmonyOverview,Pierce07} and an algebra for file
synchronization \cite{Ramsey01}.
%
Lastly some mergers are tailored exclusively on software artifacts
\cite{Westfechtel91, Mens02, Apel11}. 

\paragraph{Diff}
Merging relies on a \texttt{diff} algorithm to detect changes between
objects, which are then to be merged according to some strategy.
%
Our \emph{edit script} is inspired by Lempsink's \cite{Lemp09}, but
employs a more general notion of \emph{edit}, a mapping between
values, which enables reasoning about merge and conflict.
%
While Lempsink's \texttt{diff} algorithm finds a \emph{minimal length}
edit script, ours uses a \emph{cost} measure, which is parametric in
the \texttt{distance} function used to weight updates.  
%
We both employ similar trees and heterogeneous list, but our
constructor representation handles also \emph{polymorphic}
data types such as lists, while their approach requires 
to encode families of mutually recursive data-types
at once, furthermore only with fully instantiated types.
Our representation is instead modular and reusable.

\paragraph{Ordered and Unordered Data} 
The merge algorithm presented in this paper works on algebraic data
types, which are strongly typed, tree-like, ordered objects. File
systems are usually hierarchical, but not inherently ordered, while
XML trees can also be unordered.
%
Schemas are used in Harmony to identify specific
conflicts (\emph{schema domain conflicts}), which would break their
structural invariants \cite{Pierce07}.
%
They play a role similar to types in this work, which we use to
type-check edit scripts.
%
Chawathe et al.\ assume that nodes have unique identifiers
\cite{Chawathe96}, which greatly simplifies the change detection
phase.
%
This assumption is inappropriate in our context because data formats
do not usually mark their content, furthermore even XML trees
might not have identifiers in their nodes.
	
\paragraph{Alignment and Data Structures} 
Alignment of corresponding parts plays a central role when merging
two objects. 
%
In this work the alignment is \emph{global} and mainly determined by
\texttt{diff},
% \todo{Discuss alignment and diff in the Haskell section?}
which computes the embedding of the source into the target object, by
minimizing an appropriate cost model.
%
GNU \texttt{diff3} aligns lines of texts dividing them in stable and
unstable \emph{chunks} based on the longest common subsequences
computed by \texttt{diff} \cite{PierceDiff3}.  
%
Overlapping equal lines are matched and fused in stable chunks,
leaving possibly conflicting chunks between them.
%
This technique works well when lines are mostly unique such as in
software artifacts.
%
We doubt that this technique would give good results in our context.
%
Firstly the basic values to be aligned are unlikely to be unique,
increasing the chances of misalignment.
%
Secondly such an aligner would not take into account the tree-like
structure of the data, possibly missing important matching.
%
Our aligner retains the structured nature of the data by preserving
the relative order of the nodes and strives to generate a proper
embedding by matching pairs of nodes and preferring updates
to a sequence of delete and insert.
%
The \emph{alignment} strategy has a profound impact when merging data
structures.
%
Harmony employs a \emph{local} strategy, that associates subtrees by
name, therefore it is able to merge correctly unordered collections
such as records and sets.
%
Our algorithm struggle with unordered data structures, 
because it treats them as structured.
%
On the other hand Harmony performs poorly with lists, because
it \emph{align} them by absolute position.
%
For example merging \texttt{[1, 3]} with \texttt{[2]} and base 
\texttt{[1, 2]} surprisingly it gives \texttt{[2, 3]}, instead of
\texttt{[3]} as we do.
%
Chawathe and Molina reduce the change detection problem to the problem
of computing a minimum-cost edge cover of a bipartite graph
\cite{Chawathe96}.
%
Since this problem is NP-hard they employ an heuristic, consisting of
pruning rules, to find a \emph{minimal} edge cover.
			
\paragraph{Edit Operations} 
Edit operations are very important in a diffing algorithm, because
they determine how precisely changes in data can be detected, 
hence affecting the merging phase.
%
GNU diff employs insert, delete and copy in scripts only and updates
are imprecisely encoded as a delete followed by an insert.  Our
algorithm detects updates explicitly reducing the number of false
conflicts and raising more specific and informative true conflicts
(\texttt{UpdUpd}, \texttt{UpdDel}, \texttt{DelUpd}).
%
Some synchronizers employ also a \emph{move} edit operation
\cite{Lind04, Chawathe96, Chawathe97}.
In our algorithm and in Ramsey's \cite{Ramsey01}, move edits
are encoded by delete and insert, bearing the same 
drawbacks of an imprecise representation.
Move can improve the quality of diffs only if it is detected
with a fair confidence, therefore Lindholm takes into
account the \emph{context} of a node in order to improve the precision.
%
With respect to our work we remark that move edits would weaken 
the structural invariants guarantees and would probably 
complicate reasoning \cite{Ramsey01}.
	
\paragraph{Formal Model}
The semantics of merging algorithms employed in version control
systems, with the notable exception of Darcs \cite{HomoPatchTheory,
  CategoryPatchTheory} is not formalized, but it is usually understood
empirically, leading to severe misconceptions \cite{PierceDiff3}.
%
For instance it is in general hard to predict the outcome of complex
merges and determine whether a conflict is indeed true or the
consequence of a bug.
%
Furthermore, even when merges are successful, they might produce
unexpected results, for instance duplicating lines or changing their
order.
%
This situation calls for a formalization of such merging algorithms.
%
Unison \cite{UnisonSpec} is an example of a file synchronizer
automatically derived from a formal model \cite{Pierce98}.
%
In this paper we have presented several properties of our algorithms,
inspired by the work from Pierce et al.\ in Harmony
\cite{HarmonyOverview}.
%
Ramsey and Csirmaz proposes an algebraic approach to file
synchronization \cite{Ramsey01}. 
%
Differently from our work their synchronizer is
\emph{operation-based}, rather than \emph{state-based}, i.e.\ it does
not rely uniquely on the current states of the replicas, but it
requires to track the operations that changed them.
%
They give a proof system for a simple filesystem algebra,
and prove that it is sound and complete.
%
% The model is based on a relation between sequences of commands that
% ensures that a sequence safely approximates another and conflictless
% synchronization is possible if there is a sequence at least as good as
%both.
%
However the system is quite large, for only five operations it
consists of about fifty laws, to the point that it requires automatic
techniques to prove it sound.
%
On the other hand our model is instead concise and straightforward
to analyze.
%
% The 3DM tool devised by Lindholm does not include a mechanically
% verified model and moreover the general merge rules have been derived
% analyzing the expected result of use cases \cite{Lind04}.  His change
% model is based on \emph{content} and \emph{structural change}. The
% changes in each version are combined into a change set and can be
% merged only if the set is \emph{consistent}, i.e.  unambiguously
% determine at most one parent, predecessor and successor for each node.
% Conflicts are divided in core conflicts and optional conflicts and are
% overall consistent with those listed in \ref{subsec:Merge}, except for
% the delete/edit conflict, which is optional, whereas in this thesis is
% not. It is not explained under which circumstances these changes could
% be considered compatible.  The lack of a formal model raises some
% doubts about the properties claimed for the merge.  First of all the
% merge is considered symmetric, but later it is admitted that appends
% of nodes originated from different trees may be accepted in either
% order. This kind of implementation details are actually relevant from
% the user point of view and have so far fostered the need for formal,
% unambiguous models. In this thesis inserts compete for matching
% positions and may trigger conflicts if incompatible.  Secondly the
% fourth merge rule explicitly requires that changes in either versions
% to be included in the merged tree, however the fact that updates in
% deleted trees are optionally considered conflicts contradicts this
% rule and weaken the property about preservation of edits.

\section{Conclusion and Future Work}
\label{sec:conclusion}
We present a state-based, three-way, persistent, data type generic
\texttt{diff3} algorithm for typed algebraic data type.
%
By employing more accurate edits we detect changes in data more
precisely, leading to more specific edit scripts and ultimately
reducing the number of spurious conflicts raised in merges and
improving the quality of automatic reconciliation.
%
We have formalized the semantics of merge and conflict in Agda and
use it to prove several properties about our algorithm allowing
users to reason about complex merge operations.
%
We have released an efficient version of our algorithm as an Haskell
library.
%
Moved from our promising results, we plan to perform a rigorous evaluation
of our algorithm on real world data as future work.
%


% We achieve a better precision in detecting changing 
% in the \emph{change-detection} phase by
% extending the 
%  the edits that describe changes in adata we achieve a 
% \appendix
% \section{Appendix Title}

% This is the text of the appendix, if you need one.

% \acks

% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.
\bibliography{svc}

% \softraggedright


% \end{thebibliography}

\listoftodos

\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices
]

%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex -shell-escape
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End: 

