%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------

\documentclass{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{hyperref}

\usepackage{minted} % Code listing with reasonable good highlighting
\usepackage{bussproofs}   % For typing judgments
\usepackage[no-math]{fontspec}
\setmonofont[Scale=MatchLowercase]{Apple Symbols} % Unicode mono font

\usepackage[dvipsnames]{xcolor}  		% Color package
\definecolor{dgreen}{rgb}{0.,0.6,0.}    % Deep green
\usepackage{caption}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}	% todos

% Figures with border
\usepackage{float}
%\floatstyle{boxed} 
\restylefloat{figure}

\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{fancyvrb}

% Definitions for unicode characters not included
\usepackage{newunicodechar}                   
\newunicodechar{ᶜ}{$^c$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ᵗ}{$^t$}
\newunicodechar{ˢ}{$^s$}

\usepackage{pifont}
\newunicodechar{✗}{\ding{55}}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathpartir} % typing rules

\theoremstyle{plain}
\newtheorem{definition}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{cor}{Corollary}
\newtheorem{req}{Requirement}

\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}

% Drawings
\usepackage{tikz}
\usepackage{tikz-qtree}

\newcommand{\nil}{\texttt{[]}}
\newcommand{\cons}{\texttt{(:)}}
\newcommand{\num}[1]{\texttt{#1}}

\usepackage{graphicx}
\graphicspath{ {images/} }

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% \conferenceinfo{TYDE '16}{Sept d--d, 2016, Nara, ST, Japan} 
% \copyrightyear{2016} 
% \copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
% \doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusiveo license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Generic diff3 for Algebraic Datatypes}
%\subtitle{Subtitle Text, if any}

\authorinfo{Marco Vassena}
           {Chalmers University}
           {vassena@chalmers.se}
% \authorinfo{Name2\and Name3}
%            {Affiliation2/3}
%            {Email2/3}

\maketitle

\begin{abstract}
  %
  Many version control systems, including Git and Mercurial, rely on
  \texttt{diff3} to merge different revisions of the same file.
  %
  More precisely \texttt{diff3} automatically merges two text files,
  given a common base version, comparing them line by line and raising
  conflicts when the changes made are irreconcilable.
  %
  The program ignores the actual structure of the data stored in the
  files, hence it might generate spurious conflicts, which must be
  manually resolved by the user.
  %
  In this paper, we present a state-based, three-way, persistent,
  data-type generic \texttt{diff3} algorithm whose increased precision
  in detecting changes reduces the number of false conflicts raised
  and improves its merging capabilities.
  %
  We have implemented the algorithm in Agda, a proof assistant with
  dependent types, and developed a model to reason about ``diffing''
  and merging.
  %
  We have formalized sanity properties and specifications of
  \texttt{diff3} and proved that our algorithm meets them.
  %
  Furthermore, we have identified the minimal conditions under which
  the merging algorithm raises a conflict and established a structural
  invariant preserved.\todo{Improve conclusion?}
  %
  % We have implemented our algorithm in Haskell in order to make our results
  % practical and employed advanced type-system features to retain a 
  % fair amount of type safety.
  %\todo{Abstract Conclusion?}
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
Algorithms,

\keywords
Diff3, Dependent types, Datatype-generic programming

\section{Introduction}
\label{sec:intro}
Version control systems, such as Git \cite{Git} and Mercurial
\cite{Mercurial}, are used in the software industry, as well as in the
open source community and by researchers all over the world to develop
software.
%
These tools track all the changes in the source code throughout its
development, making it possible to quickly roll back to any previous
version and allow different developers to work separately on the same
project.
%
Version control systems provide these features by means of two
algorithms, called \texttt{diff} and \texttt{diff3}.
%
The former detects changes in source code files, while the latter
merges independent changes made to the code base, allowing
simultaneous development.
%
These algorithms are line-based, i.e.\ they compare files line by
line, therefore they can be used on any text-based file, not
exclusively on software artifacts.
%
Unfortunately, their line-granularity limits their precision when
detecting changes, which consequently deteriorates their merging
capabilities.
%
In this paper, we develop a fine-grained data-type generic version of
the \texttt{diff} and \texttt{diff3} algorithms, that improve their
applicability and whose increased precision in detecting changes
reduces the number of spurious conflicts raised and produces more
accurate true conflicts.

\paragraph{Example}
We show the shortcomings of line-based \texttt{diff} and
\texttt{diff3} algorithms by means of an example.  
%
The Comma Separated Values file format (CSV) is a simple text-based
encoding of data stored in tables. %b \cite{csv}.
%
In a CSV file, every line represents a row of the table and commas
separate values in different columns, within each row.
%
For instance, file \texttt{a.csv} encodes a $3 \times 3$ table
containing numbers from 1 to 9.
\begin{figure}[!h]
\centering
\begin{minipage}{.15\textwidth}
{  \centering
  \begin{verbatim}
  $ cat a.csv
  1,2,3
  4,5,6
  7,8,9
  \end{verbatim}\par
}
\end{minipage}%
\begin{minipage}{.15\textwidth}
{  \centering
  \begin{tabular}{ | c | c | c | }
    \hline
    1 & 2 & 3 \\ \hline
    4 & 5 & 6 \\ \hline
    7 & 8 & 9  \\ \hline
  \end{tabular}\par
}
\end{minipage}%
\end{figure}

Imagine that two users are simultaneously working on this table.
The first user adds a column filled with zero and saves the new table in \texttt{b.csv}:
\begin{figure}[h]
\centering
\begin{minipage}{.15\textwidth}
  \centering
\begin{Verbatim}[commandchars=\\\{\}]
  $ cat b.csv
  \textcolor{blue}{0},1,2,3
  \textcolor{blue}{0},4,5,6
  \textcolor{blue}{0},7,8,9
\end{Verbatim}
\end{minipage}%$
\begin{minipage}{.15\textwidth}
  \centering
  \begin{tabular}{ | c | c | c | c | }
    \hline
    \textcolor{blue}{0} & 1 & 2 & 3 \\ \hline
    \textcolor{blue}{0} & 4 & 5 & 6 \\ \hline
    \textcolor{blue}{0} & 7 & 8 & 9  \\ \hline
  \end{tabular}
\end{minipage}%
\end{figure} 

The second user changes some values in the third column and saves the new table in  \texttt{c.csv}:
\begin{figure}[h]
\centering
\begin{minipage}{.15\textwidth}
  \centering
  \begin{Verbatim}[commandchars=\\\{\}]
  $ cat c.csv
  1,2,3
  4,5,\textcolor{magenta}{9}
  7,8,\textcolor{magenta}{15}
  \end{Verbatim}
\end{minipage}% $
\begin{minipage}{.15\textwidth}
  \centering
  \begin{tabular}{ | c | c | c | }
    \hline
    1 & 2 & 3 \\ \hline
    4 & 5 & \textcolor{magenta}{9} \\ \hline
    7 & 8 & \textcolor{magenta}{15} \\ \hline
  \end{tabular}
\end{minipage}%
\end{figure}

The two users would like to synchronize their work now and decide to
use \texttt{diff3} to merge their versions.
%
They have modified \emph{independent} parts of the table, therefore
they are confident that it is should be possible to automatically
merge the changes, without incurring in a conflict.
%
Unfortunately, since \texttt{diff3} is a line-based algorithm, it
compares files line by line, without considering the actual structure
of the data stored in the files. 
%
As a result, the algorithm fails to merge the two tables and raises
spurious conflicts.
%
In particular, \texttt{diff3} employs the \emph{three-way-merge}
technique to compare and merge the corresponding lines of three files.
%
The following table shows the result of applying this technique to the
previous tables:
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\texttt{b} & \texttt{a} & \texttt{c} & \texttt{diff3 b a c} \\ \hline
\texttt{\textcolor{blue}{0},1,2,3} & \texttt{1,2,3} & \texttt{1,2,3} & \textcolor{dgreen}{\texttt{0,1,2,3}} \\ \hline
\texttt{\textcolor{blue}{0},4,5,6} & \texttt{4,5,6} & \texttt{4,5,\textcolor{magenta}{9}} & \textcolor{red}{✗}  \\ \hline
\texttt{\textcolor{blue}{0},7,8,9} & \texttt{7,8,9} & \texttt{7,8,\textcolor{magenta}{15}} & \textcolor{red}{✗} \\ \hline
\end{tabular}
\end{center}
If there is at most one different version of the same line, as it
happens in the first row, a merge is possible.
%
Instead, if the same line is different in all the three versions,
which is the case in the second and third row, a conflict is
triggered.
%


\paragraph{Discussion}
The main limitation of \texttt{diff} and \texttt{diff3} is that they
operate on data representation with a \emph{fixed} precision,
consisting of one line of text, therefore disregarding completely any
information about the actual structure of the data.
%
If they were aware of the table structure, consisting of columns and
rows, then \texttt{diff} could exactly represent the differences in
each version and \texttt{diff3} could automatically merge them, as the
users expected:
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\textcolor{blue}{0} & 1 & 2 & 3 \\ \hline
\textcolor{blue}{0} & 4 & 5 & \textcolor{magenta}{9} \\ \hline
\textcolor{blue}{0} & 7 & 8 & \textcolor{magenta}{15} \\ \hline
\end{tabular}
\end{center}

% Obviously we do not want to implement format specific \texttt{diff} and \texttt{diff3} algorithms, since this would hinder reusability, but instead
% they manipulate data directly, assuming that parsers and serializers for it are available. Furthermore we would like our algorithms to be as reusable as possible, with data of any possible shape.

\subsection{Contributions}
In this paper we make the following contributions:
\begin{itemize}
\item In Section \ref{subsec:edit-script}, we define a type-safe edit script data 
      type that supports \emph{delete}, \emph{insert} and \emph{update} edits and 
      that represents the differences between two objects. In Section 
      \ref{subsec:diff-algo}, we give the formal specifications of a \texttt{diff} 
      algorithm in terms of the edit script data type.
\item In Section \ref{subsec:merge-semantics}, we formalize the 
      \emph{three-way-merge} strategy and give a precise semantics of 
      \emph{mergeable} and \emph{conflicting} edits. We give 
      the formal specifications of a \texttt{diff3} algorithm in terms of our edit 
      semantics. 
\item In Section \ref{subsec:diff3-algo}, we show a data type generic, three-way 
      \texttt{diff3} algorithm that satisfy our specifications and we study its 
      formal properties in Section \ref{sec:properties}.
\end{itemize}
We have implemented these algorithms using generic programming
techniques in Agda \cite{Bove09}, a programming language with dependent
types and a proof assistant. Dependent types are particularly
convenient in this setting to idiomatically encode the pre-conditions
and post-conditions of our algorithms and ultimately verify their
properties.
%
We have then put our model into practice by efficiently implementing
our algorithms in Haskell \cite{Marlow_haskell2010}.
%
% In Section \ref{sec:haskell}, we point out the shortcomings and
% compromises that we had to make when moving from a language with 
% dependent types to a less expressive one.
%
The source code containing \texttt{diff} and \texttt{diff3}
algorithms, their properties and formal proofs are available
online\footnote{https://github.com/marco-vassena/gdiff3}.  For the
sake of presentation, we have simplified the code presented in this
paper, for instance by hiding implicit arguments and universe levels.
\todo{This paper is organized as follows}

\section{Universe}
\label{section:universe}
Data type generic algorithms work on a generic representation of
algebraic data types.
%
The universe used in this paper consists of typed heterogeneous rose
trees, a combination of mutually recursive heterogeneous lists and
trees, whose \emph{nodes} correspond to data type constructors and
their children to their fields.

\paragraph{Constructors}
Type \texttt{C as a} denotes a constructor of an algebraic data type
of type \texttt{a}, that takes arguments of types given in list
\texttt{as}.
%
For instance constructor \texttt{True} is represented by type \texttt{C []
  Bool}, because it does not take any argument and produces a boolean
value.
%
Note that also polymorphic data types are supported by this
representation, for example, constructor \texttt{Just} is represented
by type \texttt{C [a] (Maybe a)} for any type \texttt{a}.
%
In the following, we will leave type \texttt{C as a} abstract, as a
module parameter, together with a decidable heterogeneous equality
operator\footnote{In Agda, \texttt{Set} is the kind of simple types
  and \texttt{List Set} is the type of a list containing simple
  types.}.

\begin{minted}{agda}
module Diff3 (C : List Set → Set → Set) 
              (_≟_ : (α : C as a) (β : C bs b) → Dec (α ≅ β)) where
\end{minted}
In Section \ref{sec:haskell}, we show how to concretely implement this
representation.

\paragraph{Well-Typed Rose Trees}
Data type \texttt{HTree a} is a tree-like data structure that
represents a value of an algebraic data type of type \texttt{a}.
\begin{minted}{agda}
  data HTree : Set → Set where
    Node : C as a → HList as → HTree a
\end{minted}
%
Data type \texttt{HList as} collects the children of node, i.e. the
arguments of constructor \texttt{C as a}, each encoded as a typed
tree.
%
\begin{minted}{agda}
  data HList : List Set → Set where
    [] : HList []
   _∷_ : HTree a → HList as → HList (a ∷ as)
\end{minted}
%
This representation is type-safe because the constructor
witness and the heterogeneous list share the same index
\texttt{as}, therefore denoting a well-typed application of a
constructor to its arguments.
% 

\paragraph{Example}
List \texttt{[1,2]} is encoded in this universe as:
\begin{Verbatim}[commandchars=\\\{\}]
ht : HTree (List Int)
ht = Node (\textcolor{blue}{::}) [Node \textcolor{magenta}{1} [], Node (\textcolor{blue}{::}) [Node \textcolor{magenta}{2} [], Node \textcolor{blue}{[]} []]]
\end{Verbatim}
Where \texttt{(\textcolor{blue}{::}) : C [Int, List Int] (List Int)}
and \texttt{\textcolor{blue}{[]} : C [] (List Int)} denote the cons
constructor and the empty list constructor respectively, specialized
without loss of generality to \texttt{List Int}.
%
In our examples we automatically lift numbers to node constructors,
that is \texttt{\textcolor{magenta}{1}, \textcolor{magenta}{2} : C []
  Int}.
%
We graphically depict objects encoded in this universe as trees:

\begin{figure}[h]
\centering
\Tree
[.\texttt{(\textcolor{blue}{::})}
   [.\texttt{\textcolor{magenta}{1}} ]
   [.\texttt{(\textcolor{blue}{::})} [.\texttt{\textcolor{magenta}{2}} ] [.\texttt{\textcolor{blue}{[]}} ]]
]
\end{figure}
	
% \todo{Move later?}
% In the following we will use two auxiliary functions to append and
% split heterogeneous lists:
% \begin{minted}{agda}
% _+++_ : HList as → HList bs → HList (as ++ bs)
% \end{minted}
	
\section{Generic diff}
Our \texttt{diff3} algorithm relies on a \texttt{diff} algorithm, used
as a subroutine to compare the input objects and merge them.
%
The algorithm detect differences between two heterogeneous lists
given as input producing an edit script, whose edit operations
progressively transform one into the other.
%
More precisely an edit script is a list of edits, that either insert,
delete, or replace the nodes of the input objects.
%
We firstly describe a simply typed version of edit and edit scripts
and then refine them to guarantee type-safety.

\subsection{Edit Operations}
An edit operation is a mapping \texttt{u ⟼ v}, where \texttt{u} and
\texttt{v} are called \emph{source} and \emph{target} value
respectively.
%
A value is an optional node, i.e.  \texttt{Value as a = Maybe (C as
  a)}. 
%
For brevity, we write \texttt{⊥} for an empty value and \texttt{⟨ α ⟩}
for a value containing node \texttt{α}.
% 
All the possible combinations of source and target value state, i.e.\
empty and non-empty, form four different edit operations.
\begin{minted}{agda}
data _⟼_ : Value as a → Value bs a → Set where
  Nop : ⊥ ⟼ ⊥
  Del : (α : C as a) → ⟨ α ⟩ ⟼ ⊥
  Ins : (α : C as a) → ⊥ ⟼ ⟨ α ⟩
  Upd : (α : C as a) (β : C bs a) → ⟨ α ⟩ ⟼ ⟨ β ⟩
\end{minted}
The \texttt{Nop} edit is a no-operation, that will be
used in Section \ref{subsec:alignment}, to \emph{align} edit scripts.
%
Edit \texttt{Del α} deletes node \texttt{α}, which is mapped to
the empty value \texttt{⊥}, since it lacks a target node.
%
Similarly, edit \texttt{Ins α} inserts node \texttt{α}, which
then lacks a source node, hence it has the empty value \texttt{⊥} 
as source value.
%
Edit \texttt{Upd α β} updates source node \texttt{α} with target node
\texttt{β} and concretely represents a constructor change.
%
Note that there is no explicit copy edit: it is just a special case of
update, in which the source and target nodes happen to be the same.
%
Edits that have the same \emph{source} and \emph{target} value are
called \emph{identity} edits---they have type \texttt{v
  ⟼ v}.
%
Node copy and no-operation fall into this category.
%
Even though the edit data type, as it is here defined, is not space
efficient, because it might store the same node twice, it is more
suitable for reasoning and leads to a more elegant merge and conflict
semantics.
%
\todo{An implementation should take care of this. Do we?}
	
\subsection{Untyped Edit Script}
\label{subsec:edit-script}
An edit script is a finite list of edit operations, that describe how
to transform a \emph{source} object into a \emph{target} object.
%
\begin{minted}{agda}
data ES : Set where
  [] : ES
  _::_ : v ⟼ w → ES → ES
\end{minted}	
%
More precisely the script traverse and process their nodes
by traversing the objects in depth-first preorder.
%
Note however that we do not transform plain trees, but rather
\emph{lists} of trees, which are used as \emph{stacks} of unprocessed
nodes, pushed and popped according to the edit operations found in the
script.
%
We work with lists of trees because certain edits, when applied to
nodes in a tree, will intrinsically result in multiple trees.
%
For instance, deleting the root node to tree \texttt{ht}, from Section
\ref{section:universe}, will produce two trees (\texttt{Node
  \textcolor{magenta}{1} []} and \texttt{Node (\textcolor{blue}{::})
  [Node \textcolor{magenta}{2} [], Node \textcolor{blue}{[]} []]}):

\begin{figure}[h!]
\centering
  \begin{minipage}{.15\textwidth}
  \centering
    \Tree
    [.\texttt{\textcolor{magenta}{1}} ]
  \end{minipage}%
%
\begin{minipage}{.15\textwidth}
  \centering
    \Tree
    [.\texttt{(\textcolor{blue}{::})} [.\texttt{\textcolor{magenta}{2}} ]     
    [.\texttt{\textcolor{blue}{[]}} ]]
\end{minipage}%
\end{figure}

%
Informally, a delete (insert) edit pops the root of the tree from the
top of the \emph{source} (\emph{target}) stack and pushes its children
instead.
%
An update behaves as a simultaneous delete and insert and
a no-operation leaves both of the stacks unchanged.
%
In principle, it should be possible to define functions that
retrieves the source and target objects from a script, by
\emph{inverting} the process that we have just described.
%
Unfortunately, the lack of types already makes it hard to even assign a suitable
type to a function \texttt{⟪\_⟫ : ES → HList ?}:
what type should we put instead of the question mark?
%
Crucially, an untyped edit script does not guarantee that its
operations will produce well-typed trees and not even that they can be
performed at all.
%
The top of the stack might contain trees of the wrong type, that do
not match those of the constructor at hand, or it might try to pop
trees from an empty stack.
%
For instance, edit script \texttt{[Ins (\textcolor{blue}{::}) , Ins
  \textcolor{magenta}{0}]} would generate a target list containing an
ill-typed tree, whose root node lacks a second child:
\begin{figure}[!h]
\centering
\Tree
[.\texttt{(\textcolor{blue}{::})}
   [.\texttt{\textcolor{magenta}{0}} ]
]
\end{figure}

%
Guaranteeing such invariants is the bread and butter of
dependently-typed programming, as we proceed to show in the next
section.

\subsection{Type-Safe Edit Script}
In order to make edit script type-safe, we firstly refine the type of
\emph{values}, to correctly approximate the trees popped and pushed on
a stack, with their index and secondly annotate the edit script data
type to ensure type-safety through them.

\paragraph{Value}
Given a source (target) value of type \texttt{Value as a}, an edit
will pop trees of types \texttt{as} and push a tree of type \texttt{a}
on the source (target) stack, if and only if a node is in fact
present, otherwise the corresponding stack will be left unchanged.
%
The following indexed data type correctly approximate inputs and
outputs, regardless of the presence of the node.
\begin{minted}{agda}
data Value : List Set → List Set → Set where
  ⊥ : Value [] []
  ⟨_⟩ : C as a → Value as [ a ] 
\end{minted}
Observe that also the second index is a list and both of them are
empty, for the empty value.
%

\paragraph{Edit Script}
The edit script data type is still a list of edits, but it is now
indexed with type-level lists, which restrict the shape of the source
and target stacks, ensuring type-safety.
%
\begin{minted}{agda}
data ES : List Set → List Set → Set where
  [] : ES [] []
  _::_ : {v : Value as bs} {w : Value cs ds} → v ⟼ w → 
          ES (as ++ xs) (cs ++ ys) → ES (bs ++ xs) (ds ++ ys)
\end{minted}	
An edit script of type \texttt{ES xs ys} transforms a \emph{source}
list of type \texttt{HList xs} into a \emph{target} list of type
\texttt{HList ys}.  
%
The cons constructor takes an edit, whose source (target) value
consumes \texttt{as} (\texttt{cs}) and yields \texttt{bs}
(\texttt{ds}).
%
The fact that the lists of the rest of the edit script have prefix
\texttt{as} and \texttt{cs}, ensure that it will be possible to pop
trees of the right type from the source and target object
respectively, and replace them by constructing and pushing well-typed
trees of types \texttt{bs} and \texttt{ds}.

With more precise types, we can define \emph{source} function
\texttt{⟪\_⟫}, which retrieves the source object from an edit script:
\begin{minted}{agda}
⟪_⟫ : ES as bs → HList as
⟪ [] ⟫ = []
⟪ Nop ∷ e ⟫ = ⟪ e ⟫
⟪ Del α ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
⟪ Ins α ∷ e ⟫ = ⟪ e ⟫
⟪ Upd α β ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
\end{minted}
%
Source nodes are present in delete and update edits ---the other cases
are trivial.
% 
Function \texttt{hsplit : HList (as ++ bs) → HList as × HList bs}
splits an heterogeneous list in two parts according to its type and it
is used to \emph{pop} the arguments (\texttt{hs₁}) of the source
constructor (\texttt{α}) , from the rest of the list.
%
Note that the type of the cons constructor guarantees that the tree
\texttt{Node α hs₁} is well-typed.
%
Dually, we define the \emph{target} function, whose implementation is
analogous and thus omitted:
\begin{minted}{agda}
⟦_⟧ : ES as bs → HList bs
\end{minted}

\begin{figure*}[!t]
\centering
\includegraphics[scale=.27]{embedding2}
\caption{The embedding induced by \texttt{[Upd (::) (::), \textcolor{magenta}{Upd 0 1}, \textcolor{blue}{Ins (::)} , \textcolor{blue}{Ins 2}, Upd [] []]}}
\label{fig:embedding}
\end{figure*}

\paragraph{Example}
While the previous edit script is now ill-typed, the following script
encodes the differences between two lists of integers, namely \texttt{[0]} and \texttt{[1,2]}, as witnessed by its richer type:
\begin{Verbatim}[commandchars=\\\{\}]
e : ES [List Int] [List Int]
e = [Upd (::) (::), \textcolor{magenta}{Upd 0 1}, \textcolor{blue}{Ins (::)} , \textcolor{blue}{Ins 2}, Upd [] []]
\end{Verbatim}

Figure \ref{fig:embedding} shows that the script embeds nodes of the
source tree into those of the target object.
%
Finding a ``good'' embedding is the goal of \texttt{diff}.

\subsection{Diff Algorithm}
\label{subsec:diff-algo}
Our \texttt{diff3} algorithm does not merge objects directly, but like
its text-based counterpart, relies on a \texttt{diff} algorithm
as a subroutine to detect changes between them.
%
More precisely, a \texttt{diff} algorithm takes two object and produces
an edit script that describes the differences between them, which is
then used to compute the merged object by \texttt{diff3}.
%
We remark that our \texttt{diff3} algorithm and its formal guarantees,
do not rely on a specific \texttt{diff} algorithm, but rather are
valid with any function of type \texttt{diff : HList as → HList bs →
  ES as bs} that fulfills the following basic requirement.

\begin{req}[\texttt{diff} specifications]
  \label{req:diff-specs}
  A \texttt{diff} algorithm is correct if and only if for any list
  \texttt{x} and \texttt{y} \center{\texttt{e = diff x y ⇔ x ≡ ⟪ e ⟫ ∧
      y ≡ ⟦ e ⟧}}
\end{req}
  % specifications, not minimal to accommodate more diffs}
%
This correctness criterion demands that the edit script computed by
\texttt{diff} transform exactly the source object \texttt{x} into the
target object \texttt{y}.  (In the specifications \texttt{≡} denotes
propositional equality.)
%
Note that the specification is very permissive: it does not require 
the edit script to be minimal, not even ``small''.
%
Even though we expect our \texttt{diff3} algorithm to perform better
with competitive \texttt{diff}s ---they will probably capture changes
more precisely, the advantage of reasoning by such specification is
that our results are valid for virtually any \emph{sensible}
\texttt{diff} algorithm.
 %
% The following data type serves to this purpose: \texttt{Diff x y e} is
% the proof that the edit script \texttt{e} is the result of diffing
% lists \texttt{x} and \texttt{y}.
% \begin{minted}{agda}
% data Diff : HList xs → HList ys → ES xs ys → Set where
%   End : Diff [] [] []
%   Nop : Diff x y e → Diff x y (Nop ∷ e)
%   Del : Diff (x₁ +++ x₂) y e → Diff (Node α x₁ ∷ x₂ ) y (Del α ∷ e)
%   Ins : Diff x (y₁ +++ y₂) e → Diff x (Node β y₁ ∷ y₂) (Ins β ∷ e)
%   Upd : Diff (x₁ +++ x₂) (y₁ +++ y₂) e → 
%         Diff (Node α x₁ ∷ x₂) (Node β y₁ ∷ y₂) (Upd α β ∷ e)
% \end{minted}

% We prove that \texttt{Diff x y e} complies with the specifications of
% \texttt{diff} (Requirement \ref{req:diff-specs}), because \texttt{x}
% and \texttt{y} are uniquely determined by respectively the source and
% target function applied on \texttt{e}, as the following result shows.
% \begin{prop}[\texttt{Diff} is correct]
% \label{prop:diff-correct}
% Let \texttt{x} and \texttt{y} be heterogeneous lists and \texttt{e} an edit script, then
% \center{\texttt{Diff x y e ⇔ x ≡ ⟪ e ⟫ ∧ y ≡ ⟦ e ⟧}}
% \end{prop}
In our implementation we employ a generalization of Lempsink's
\texttt{diff} algorithm \cite{Lemp09}, which meets
Requirement \ref{req:diff-specs}.
% \begin{minted} {agda}
% diff-suff :  (x : HList xs) (y : HList ys) → Diff x y (diff x y)
% \end{minted}

\section{Generic diff$_3$}
The \texttt{diff3} algorithm takes as input three objects, the
original version called \emph{base} and two new replicas, and it
outputs an edit script that combines the changes between them.
%
However, the algorithm does not work directly on the replicas, but
relies on a \texttt{diff} algorithm to compute two edit scripts that
describe the changes from base to each of the new versions.
%
It then generates an edit script by merging the edits contained in
edit scripts: the \emph{source} of the merged script is the base
object and the \emph{target} is the merged object.
%
Nevertheless, edits cannot always be automatically reconciled: a
conflict is triggered in this situation and reported to the user, who
has to solve it manually. 
%
\todo{More discussion about different design choices, persistent etc
  ...}
		
\todo{Remark that the three-way technique is attractive and we simply
  want to apply it to structured data. Maybe in intro?}
%
The merging technique employed in our \texttt{diff3} algorithm for
algebraic data types consists in applying the three-way merge
algorithm at the node level.
%
Informally the algorithm compares corresponding parts of two objects
and of their base version, when two parts disagree, the base version
is examined: a conflict is detected if each version is different,
otherwise the version that changed from base is chosen.
	
To put this strategy on a formal footing, we give precise definitions
of corresponding parts of objects and conflicts, on top of which, we
define a sound merging semantics.

\subsection{Alignment}
\label{subsec:alignment}
%
\emph{Alignment} is a relation that captures corresponding parts of
objects, that should be merged.
%
Trying to merge unrelated parts is likely to fail, resulting in
spurious conflicts, therefore alignment affects immensely the
precision and reliability of \texttt{diff3}.
%
In our framework, it is convenient to use \emph{edits} to identify
these parts.
%
In fact, while their source values belong to the same object
(\emph{base}), their target values belong to different replicas, which
we want to merge.
%
More formally, we define \emph{alignment} as follows.
\begin{definition}[Edit and Script Alignment]
\mbox{}
\label{def:align}
\begin{itemize}
  \item Two edit operations are aligned, if and only if they have the same source value.
  \item Two edit scripts are aligned, if and only if their edits are
    pairwise aligned.
\end{itemize}
\end{definition}
Definition \ref{def:align} is about \emph{values}, not only nodes: any
two edits \texttt{u ⟼ v} and \texttt{u ⟼ w} are aligned.
%	
Intuitively, two edit scripts that have the same \emph{source} object
can be aligned, because they share the same collection of
\emph{source} nodes.
%
However, insert edits may break alignment, because they can occur at
any point in the scripts, introducing \emph{empty} values.

\paragraph{Example}
Consider the lists \texttt{x = [1]}, \texttt{y = [0,1]} and \texttt{z
  = [1,2]}.
%
Edit scripts \texttt{e₁} and \texttt{e₂} represent the \texttt{diff}
between \texttt{x} and respectively \texttt{y} and \texttt{z}
\footnote{In this example \texttt{Cpy α} stands for \texttt{Upd α α}}.
\begin{minted}{agda}
e₁ e₂ : ES [ List Int ] [ List Int ]
e₁ = [Ins  (::), Ins  0, Cpy (::), Cpy 1, Cpy []]
e₂ = [Cpy (::), Cpy 1, Ins  (::), Ins  2, Cpy []] 
\end{minted}       
%
% \begin{minted}{agda}
% e₁ e₂ : ES [ List Int ] [ List Int ]
% e₁ = [Ins (::), Ins 1, Cpy (::), Cpy 1,                 Cpy []]
% e₂ = [                Cpy (::), Cpy 1, Ins (::), Ins 2, Cpy []] 
% \end{minted}       
The scripts are \emph{not} aligned, because their first edits are not,
namely \texttt{⊥ ≢ ⟨ :: ⟩}, where \texttt{⊥} is the source value of
\texttt{Ins (::)} in \texttt{e₁} and \texttt{⟨ :: ⟩} is the source
value of \texttt{Cpy (::)} in \texttt{e₂}.

Interestingly, alignment can be recovered by inserting no-operation
edits in these points.
\begin{minted}{agda}
e₁* = [Ins (::), Ins 0, Cpy (::), Cpy 1, Nop   , Nop , Cpy []]
e₂* = [Nop   , Nop , Cpy (::), Cpy 1, Ins (::), Ins 2, Cpy []] 
\end{minted}

In the following, we use notation \texttt{e ⊑ e*} to denote that edit
script \texttt{e*} extends script \texttt{e} with a finite number of
\texttt{Nop} edits.
%
Observe that, \texttt{Nop} edits change neither the \emph{source} nor the
\emph{target} of the edit script, therefore it is an harmless
extension.
\begin{prop}[Equivalent Extension]
  If \texttt{e ⊑ e*}, then it holds that \texttt{⟦ e ⟧ ≡ ⟦ e* ⟧} and
  \texttt{ ⟪ e ⟫ ≡ ⟪ e* ⟫}
\end{prop}

Proposition \ref{prop:align-ext} guarantees that we can always
\texttt{Nop}-extend scripts that have the same source object.
%
As a result, we can systematically apply this technique in
\texttt{diff3}.
%
\begin{prop}[Alignment via Extension]
\label{prop:align-ext}
  Let \texttt{e₁ = diff x y} and \texttt{e₂ = diff x z}, then there
  exists edit scripts \texttt{e₁*} and \texttt{e₂*}, such that
  \texttt{e₁ ⊑ e₁*}, \texttt{e₂ ⊑ e₂*}, and \texttt{e₁*} and
  \texttt{e₂*} are aligned.
\end{prop}
Adding no-operations operations to align scripts is effective, because
\texttt{Nop} always aligns with \texttt{Ins} --- they both have the
empty value \texttt{⊥} as source.
%
Furthermore, it is also an attractive technique, because no-operations
cannot introduce new conflicts, since they are \emph{identity} edits.


%         \paragraph{Weak Alignment}\todo{Drop weak alignment, give only Proposition}
%         Two edit scripts are \emph{weakly aligned} \texttt{e₁ \textasciitilde\ e₂} 
%         if they admit extensions that are \emph{aligned}:
% \begin{minted}{agda}
% data _~_ (e₁ : ES xs ys) (e₂ : ES xs zs) : Set where
%   WA : e₁ ⊴ e₁* → e₂ ⊴ e₂* → e₁* ⋎ e₂* → e₁ ~ e₂
% \end{minted}

%         We can now weakly align two edit scripts, that share the
%         same \emph{source} object. The alignment procedure examines the scripts
%         and extend either of them with no-operations, whenever one inserts a 
%         node and the other does not. 
% \begin{minted}{agda}
% align : Diff x y e₁ → Diff x z e₂ → e₁ ~ e₂
% \end{minted}

	\subsection{Merge Semantics}
        \label{subsec:merge-semantics}
        \todo{Mention that implements the three-way merge}
	Our merge semantics is defined over aligned edits.
	Two aligned edits contain at most three distinct values: 
	one common source and two, 	possibly different, targets, which 
	are treated as corresponding parts.
	A merge can either fail raising a conflict or succeed producing
	an edit that combines both.
	
	\paragraph{Merge}
	Data type \texttt{f ⊔ g ↧ h} is the proof that merging aligned
        edits \texttt{f} and \texttt{g} succeeds producing the edit
        \texttt{h}.
	
\begin{minted} {agda}
data _⊔_↧_ : (v ⟼ a) → (v ⟼ b) → (v ⟼ c) → Set where
  Id₁ : (f : v ⟼ v) (g : v ⟼ w) → f ⊔ g ↧ g
  Id₂ : (f : v ⟼ w) (g : v ⟼ v) → f ⊔ g ↧ f
  Idem : (f : v ⟼ w) → f ⊔ f ↧ f
\end{minted}

	Observe that the type of the two input edits guarantees their
        alignment.
        %
        Furthermore, determines only the \emph{target} value, hence the
        third merged edit retain the the same source value \texttt{v}.

	Each constructor represents a distinct axiom that justifies why
	the merge is possible and determines the merged edit.
	The rules \texttt{Id₁} and \texttt{Id₂} apply when 
	respectively the first and the second transformation is an \emph{identity} 
        edit.
	Similarly to the three-way merge algorithm, when one version is unchanged the other
        is chosen.
	The fact that merging is an \emph{idempotent} operation motivates the 
	third rule \texttt{Idem}.
	It applies when the same edit is performed independently in both versions.
	
	Note that this definition is particularly effective because it is 
	minimal and concise, as it does not mention specific
	edits, yet it is complete, because it can encode all the true concrete 
        merges.	

	\paragraph{Conflict}
	A conflict occurs when two edits perform irreconcilable changes.
	The following data type represents the possible conflicts that may arise
	from aligned edits.
	\todo{Drop data type, discuss only generically what conflicts
              are possible}
\begin{minted}{agda}
data Conflict : Val as bs → Val cs ds → Val es fs → Set where
  DelUpd : (α : C as a) (β : C bs a) → Conflict ⟨ α ⟩ ⊥ ⟨ β ⟩
  UpdDel : (α : C as a) (β : C bs a) → Conflict ⟨ α ⟩ ⟨ β ⟩ ⊥ 
  InsIns : (α : C as a) (β : C bs b) → Conflict ⊥ ⟨ α ⟩ ⟨ β ⟩
  UpdUpd : (α : C as a) (β : C bs a) (γ : C cs a) →
             Conflict ⟨ α ⟩ ⟨ β ⟩ ⟨ γ ⟩    
\end{minted}

	In the type \texttt{Conflict u v w} the index \texttt{u} is
        the common source value, while indexes \texttt{v} and
        \texttt{w} are the target values of the edits.
        %
        Conflicts given by \texttt{InsIns} and \texttt{UpdUpd}
        represent conflicting insertions and updates, similar
        to those detected by line-based \texttt{diff3}, which
        encodes proper updates as a deletion followed by an insertion.
        %
        Those given by \texttt{UpdDel} and \texttt{DelUpd} are
        entirely new and stem from the fact that these two edits are
        in general irreconcilable.

	The data type \texttt{f ⊔ g ↥ c} denotes that the edits
        \texttt{f} and \texttt{g} cannot be merged and raise conflict
        \texttt{c}.

\begin{minted}{agda}
data _⊔_↥_ : (u ⟼ v) → (u ⟼ w) → Conflict u v w → Set where
  Cnf : (f : u ⟼ v) (g : u ⟼ w) → u ≢ v → v ≢ w  → u ≢ w → 
        (c : Conflict u v w) → f ⊔ g ↥ c
\end{minted}

	The three inequalities guarantee that all the values involved are different
        and ensure that the edits are actually incompatible and may not be merged 
        otherwise. For example if \texttt{u ≡ v} the first edit would be an
        \emph{identity} edit, which can always be merged by
        \texttt{Id₁}. Similarly if \texttt{u ≡ w} the second edit could be merged
        by \texttt{Id₂}. Lastly if \texttt{v ≡ w} the edits \texttt{f} and \texttt{g}
        would perform the same change and could be merged applying the \texttt{Idem}
        rule.
        Given these inequalities the corresponding conflict is uniquely determined,
        i.e. for any concrete choice of \texttt{u}, \texttt{v} and \texttt{w} that
        are all different, the conflict \texttt{c} is uniquely determined.
	As a result also the semantics of conflict is minimal, but still complete
        because it can encode all the true conflicts.

        \paragraph{Properties}
        We now show some fundamental properties of our merge semantics that
        will be handy in our formalization.
        %
        Firstly, we prove that the semantics is sound, that is
        merge and conflicts are mutually exclusive.
        \begin{prop}[Mutually Exclusive]
          \label{prop:mutually-exclusive}
          Let \texttt{f}, \texttt{g}, \texttt{h} be aligned edits, such that
          \texttt{f ⊔ g ↧ h} then there exists no conflict \texttt{c} such that
          \texttt{f ⊔ g ↥ c}.
        \end{prop}
        Secondly we prove \emph{determinancy} of the semantics relations.
        \begin{prop}[Determinancy]
          \label{prop:determinancy}
        Let \texttt{f}, \texttt{g}, \texttt{h₁}, \texttt{h₂} be
        aligned edits, such that \texttt{f ⊔ g ↧ h₁} and \texttt{f ⊔ g
          ↧ h₂}, then \texttt{h₁ ≡ h₂}.
        %
        Similarly let \texttt{c₁} and \texttt{c₂} be conflicts, such
        that \texttt{f ⊔ g ↥ c₁} and \texttt{f ⊔ g ↥ c₂}, then
        \texttt{c₁ ≡ c₂}.
        \end{prop}

        Now that we have established that our semantics is sensible we
        define a function that merges edits.

	\paragraph{Merge Operator}
        \todo{No Signature, prose / definition}
	The binary operator \texttt{⊔} merges two aligned edits.
        % 
        For every pair of edits \texttt{f} and \texttt{g}, it either
        finds a suitable edit \texttt{h} and provide a proof that
        \texttt{f ⊔ g ↧ h}, or detects a conflict \texttt{c}, with a
        proof that \texttt{f ⊔ g ↥ c}.
        
\begin{minted}{agda}
_⊔_ : (f : u ⟼ v) (g : u ⟼ w) →
        (∃ λ c → f ⊔ g ↥ c) ⊎ (∃ λ h → f ⊔ g ↧ h)
\end{minted}
	This operator is outlined in table \ref{table:merge}, where we have
        omitted the obvious inequalities in conflicts.

	\begin{table*}[t]
	\centering
	\begin{tabular}{| c | c | c |}
	\hline
	\texttt{f : u \textasciitilde> v} & \texttt{g : u \textasciitilde> w} &  \texttt{f ⊔ g} 
	\\ \hline
	\texttt{Nop} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ Nop g}} 
	\\ \hline
	\texttt{Upd α α} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ (Upd α α) g}} 
	\\ \hline
	\texttt{f} & \texttt{Nop} & \textcolor{Green}{\texttt{Id₂ f Nop}} 
	\\ \hline
	\texttt{f} & \texttt{Upd α α} & \textcolor{Green}{\texttt{Id₂ f (Upd α α)}} 
	\\ \hline
	\texttt{Del α} & \texttt{Del α} & \textcolor{Green}{\texttt{Idem (Del α)}}
	\\ \hline
	\texttt{Del α} & \texttt{Upd α β} & \textcolor{Red}{\texttt{Cnf (Del α) (Upd α β) (DelUpd α β) }}
	\\ \hline
	\texttt{Upd α β} & \texttt{Del α} & \textcolor{Red}{\texttt{Cnf (Upd α β) (Del α) (UpdDel α β)}}
	\\ \hline
	\texttt{Ins α} & \texttt{Ins α} & \textcolor{Green}{\texttt{Idem (Ins α)}} 
	\\	\hline
	\texttt{Ins α} & \texttt{Ins β} & \textcolor{Red}{\texttt{Cnf (Ins α) (Ins β) (InsIns α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α β} & \textcolor{Green}{\texttt{Idem (Upd α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α γ} & \textcolor{Red}{\texttt{Cnf (Upd α β) (Upd α γ) (UpdUpd α β γ)}}
	\\ \hline
	\end{tabular}
	
	\captionsetup{singlelinecheck=false, justification=centering}

	\caption{Implementation of merge operator. \\
	 \texttt{f ⊔ g :} \textcolor{Red}{\texttt{f ⊔ g ↥ c}} \texttt{⊎} \textcolor{Green}{\texttt{f ⊔ g ↧ h}}}	 
	\label{table:merge}
	\end{table*}

	\paragraph{Merged Edit Script}
	Just like we defined a merge operator for aligned edits, we need to 
	define a similar operator for aligned edit scripts.
	However, since single merges may fail this operator cannot return 
	the same well-typed edit script, that we have defined before.
	Therefore, we introduce an alternative edit script, which is only partially 
	well-typed and that can include conflicts.
\begin{minted}{agda}
data ES₃ : List Set → Set where
  [] : ES₃ []
  _∷_ : {u : Val as bs} → u ⟼ v → ES₃ (as ++ xs) → ES₃ (bs ++ xs)
  _∷ᶜ_ : {u : Val as bs} → (c : Conflict u v w) → 
             ES₃ (as ++ xs) → ES₃ (bs ++ xs)
\end{minted}
	The data type is indexed only by the source type list and it is well-typed
	only with respect to it. Furthermore, it provides an additional constructor
	for conflicts. 

        \subsection{Diff$_3$ Algorithm}
        \label{subsec:diff3-algo}

	The merge operator for edit scripts takes two aligned edit scripts and
	applies the merge operator \texttt{⊔} previously defined to
	each pair of aligned edits. It builds a merged edit script choosing a 
	suitable constructor depending on the outcome of each single merge.
        \todo{Define this as zipWith (⊔) e1 e2}
\begin{minted}{agda}
merge₃ : {e₁ : ES as bs} {e₂ : ES as cs} → e₁ ⋎ e₂ → ES₃ as
merge₃ nil = []
merge₃ (cons f g p) with f ⊔ g
merge₃ (cons f g p) | inj₁ (c , _) = c ∷ᶜ merge₃ p
merge₃ (cons f g p) | inj₂ (h , _) = h ∷  merge₃ p
\end{minted}
	To improve readability we will use the following infix
        operator:
\begin{minted}{agda}
_⊔₃_ (e₁ : ES as bs) (e₂ : ES as cs) {{p : e₁ ⋎ e₂}} → ES₃ as
_⊔₃_  _ _ {{p}} = merge₃ p
\end{minted}
	The alignment proof is passed  as an instance argument, i.e. a
        special  type  of  implicit arguments  that  is  automatically
        resolved at call-sites \cite{Devriese11}.

        In order to reason about merging, we encode the specifications
        of the merge operator in data type \texttt{Merge₃}:

% \begin{figure*}[t!]
% \centering
\todo{Drop Merge3}
\begin{minted}{agda}
data Merge₃ : ES xs ys → Es xs zs → ES₃ xs → Set where
  nil : Merge₃ [] [] []
  merge : f ⊔ g ↧ h → Merge₃ e₁ e₂ e₃ → 
                   Merge₃ (f ∷ e₁) (g ∷ e₂) (h ∷ e₃)
  conflict : f ⊔ g ↥ c → Merge₃ e₁ e₂ e₃ → 
                    Merge₃ (f ∷ e₁) (g ∷ e₂) (c ∷ᶜ e₃)
\end{minted}
% \caption{Merge operator specification}
% \label{fig:merge3}
% \end{figure*}

        We now prove that our merge operator fulfills its requirements.
\begin{prop}[\texttt{⊔₃} is correct]
\label{prop:merge3-correct}
Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts such that,
\texttt{e₁ ⋎ e₂}, then:
\center{\texttt{e₃ ≡ e₁ ⊔₃ e₂ ⇔ Merge₃ e₁ e₂ e₃}}
\end{prop}
\begin{proof}
The if direction follows by induction on \texttt{e₁ ⋎ e₂}.
The iff direction follows by induction on \texttt{Merge₃ e₁ e₂ e₃} and 
relies on properties \ref{prop:mutually-exclusive} and \ref{prop:determinancy}.
\end{proof}
        
        Now that we have shown that the merge operator is in a
        one-to-one relationship with the specification data type, we
        will use the latter to reason more conveniently about its
        properties.

	\paragraph{Diff3}
        \todo{Less details, more intuition, both in code and explanations}
	We finally give a generic \texttt{diff₃} algorithm for
        heterogeneous lists.
        %
        We follow the conventional interface, in which the second
        argument is considered \emph{base}:
\begin{minted}{agda}
diff₃ : HList ys → HList xs → HList zs → ES₃ xs
diff₃ y x z with align (diff-suff x y) (diff-suff x z)
diff₃ y x z | WA _ _ p = merge₃ p
\end{minted}
	
	The \texttt{diff} algorithm is called implicitly by
        \texttt{diff-suf}; the edit scripts so obtained are aligned
        via extension using \texttt{align}, from which the alignment
        proof \texttt{p} is extracted and used to finally merge the
        scripts with \texttt{merge₃}.  Note that the call to
        \texttt{align} is valid because \texttt{diff-suff} is invoked
        with the same value \texttt{x} as first argument in both its
        arguments.

        \paragraph{Type Checking}
        \todo{Typed-version of diff3, 
              no-conflict /-> well-typed example,
              discussion about finding type signature}
	Even though merging might succeed without triggering any
        conflict the merged edit script might be invalid, i.e.\ it will
        not produce a well-typed object as \emph{target}.
        %
        The reason is that the merge operator \texttt{⊔₃} merges edits
        \emph{pointwise}, therefore the script obtained by joining two
        well-typed edit script may not be well-typed.  Consider for
        instance the following edit scripts:
\begin{minted}{agda}
e₁ e₂ : ES [] [List Int]
e₁ = [Ins [], Nop]
e₂ = [Nop, Ins []]
\end{minted}
        Merging the two edits with \texttt{e₁ ⊔₃ e₂} yields a conflict
        free, yet ill-typed edit script:
\begin{minted}{agda}
e₃ : ES₃ []
e₃ = [Ins [], Ins []]
\end{minted}
        The problem is that the first insert produces a constructor
        that does not take any arguments, yet the tail of the script
        yields another empty list as argument.
        
        The merged edit script must be type-checked to ensure that it
        actually produces a well-typed merged \emph{target} object.
        %
	The typing judgment \texttt{e ⇓ as} states that the edit
        script \texttt{e} is well typed and produces a list of type
        \texttt{HList as}.  The typing rules are straightforward:
	\begin{mathpar}
          \inferrule
          {}
          {\texttt{[] ⇓ []}}
          \and
          \inferrule
          {\texttt{f : v \textasciitilde> w} \\ 
           \texttt{w : C cs ds} \\
           \texttt{e ⇓ cs ++ ys}}
          {\texttt{f ∷ e ⇓ (ds ++ ys)}}
        \end{mathpar}

	A trivial inference algorithm can be easily deduced from the typing rules.
	Moreover note that the conflict cons constructor (\texttt{∷ᶜ}) is not 
	mentioned in the typing rules, therefore edit scripts containing
	conflicts are ill-typed.		
	Edit scripts of type \texttt{ES₃} can be converted to \texttt{ES}, if they
	are well typed:
\begin{minted}{agda}
⌜_⌝  : (e : ES₃ xs) → {{q : e ⇓ ys}} → ES xs ys
\end{minted}

\section{Properties}
\label{sec:properties}
\todo{Why do we want properties?}
In this section we present several properties of our merge algorithm,
all of which have been verified in Agda using the model presented in
this paper.  
%
In the following, we will write \texttt{f ∈ e} to denote that edit
\texttt{f} occurs in script \texttt{e}.
%
Furthermore We generalize membership to conflicts \texttt{c ∈ e} and
to nodes in heterogeneous lists \texttt{α ∈ hs}.
  
    \subsection{Conflict}  
    In order to reason about complex merge operations, we have studied
    what are the minimal conditions that will trigger a conflict.
    %
    Merging two scripts will result in a conflict if they contain at
    least a pair of aligned edits that may not be merged.  
    %
    The type \texttt{e₁ ⊔₃ e₂ ↥ c} denotes that aligned edit scripts
    \texttt{e₁} and \texttt{e₂} will raise conflict \texttt{c} if
    merged and precisely captures these circumstances.
    \todo{Drop data type!}
\begin{minted}{agda}
data _⊔₃_↥_ : ES xs ys → ES xs zs → Conflict u v w → Set where
  here :  f ⊔ g ↥ c → (f ∷ e₁) ⊔₃ (g ∷ e₂) ↥ c
  there : e₁ ⊔₃ e₂ ↥ c → (f ∷ e₁) ⊔₃ (g ∷ e₂) ↥ c
\end{minted}

    % In order to show that these are truly the minimal conditions to get a conflict,
    % we define a data type that denotes that a merged edit script contains a 
    % conflict. 

% \begin{minted}{agda}
% data _∈ᶜ_ (c : Conflict u v w) : ES₃ xs → Set where
%   here : c ∈ᶜ (c ∷ᶜ e)
%   there : c ∈ᶜ e → c ∈ᶜ f ∷ e
%   thereᶜ : c ∈ᶜ e → c ∈ᶜ (c' ∷ᶜ e)
% \end{minted}

    The following theorem shows that a conflict occurs in a merged script
    if and only if there are two aligned conflicting edits in the input scripts.
    \todo{Stress why this is good! No bugs, clear explanation etc...}
\begin{thm}[Conflict Conditions]
  Let \texttt{e₁} and \texttt{e₂} be two aligned edit scripts
  and let \texttt{e₃ = e₁ ⊔₃ e₂}, then \texttt{c ∈ e₃} if and only if
  \texttt{e₁ ⊔₃ e₂ ↥ c}.
\end{thm}

    % the presence of a conflict in a merged
    % edit script can be explained by the condition \texttt{e₁ ⊔₃ e₂ ↥ c}, i.e.\
    % that \texttt{e₁} and \texttt{e₂} contain two conflicting edits.


% \begin{minted}{agda}
%     Merge₃ e₁ e₂ e₃    ∧    c ∈ᶜ e₃    ⇒    e₁ , e₂ ↥ c
% \end{minted}
%     The proof follows immediately by induction.
%     Conversely we show that \texttt{e₁ , e₂ ↥ c} implies the presence
%     of a conflict in their merged edit script.
% \begin{minted}{agda}
%     Merge₃ e₁ e₂ e₃    ∧    e₁ , e₂ ↥ c     ⇒    c ∈ᶜ e₃
% \end{minted}
%     The proof also follow from induction. Note that we can discharge the paradoxical
%     base case in which the same edits are merged (\texttt{f ⊔ g ↧ h}) in 
%     \texttt{Merge₃ e₁ e₂ e₃} and not (\texttt{f ⊔ g ↥ c}) in \texttt{e₁ , e₂ ↥ c},
%     because these two cases are mutually exclusive.    

    \subsection{Safety}
    \todo{More intuition and explanation, less details}
    The safety properties discussed in this section act as a sanity
    check, ensuring that \texttt{diff} and \texttt{diff3} behave
    properly.
    %
    Firstly, we show \emph{data origin}, which ensures that every source
    and target node found in an edit script belong respectively to the
    source and target object diffed.  
    %
    Secondly, we show the converse property \emph{data retention}, which 
    guarantees that every node found in source and target object is
    processed in the diff and mapped in the edit script.
    %
    We start with some auxiliary definitions and lemmas.
    % Firstly we give some auxiliary definitions that will be used to state and prove
    % this properties.
%     \paragraph{Membership}
%     The type \texttt{α ∈ hs} denotes that the node \texttt{α} is present
%     in the list of trees \texttt{hs}.

% \begin{minted}{agda}
% data _∈_ : C xs a → HList ys → Set where
%   here : (α : C as a) → α ∈ Node α hs₁ ∷ hs₂
%   there : α ∈ (hs₁ +++ hs₂) → α ∈ Node β hs₁ ∷ hs₂
% \end{minted}

%     A similar data type denotes the presence of an edit in a script.

% \begin{minted}{agda}
% data _∈ₑ_ : v ⟼ w → ES xs ys → Set where
%   here : (f : v ⟼ w) → f ∈ₑ f ∷ e
%   there : f ∈ₑ e → f ∈ₑ g ∷ e
% \end{minted}

    % Lastly the judgment \texttt{e ⊢ₑ u ⟼ v} denotes that
    % the script \texttt{e} contains some edit of type \texttt{u ⟼ v}.
\begin{definition}[Edit Mapping]
An edit script \texttt{e} maps source value \texttt{u} into
target value \texttt{v}, written \texttt{e ⊢ u ⟼ v}, if and
only if there is an edit \texttt{f : u ⟼ v} such that \texttt{f ∈ e}.
\end{definition}

% I think I will skip this one and directly state the more interesting one
% \begin{minted}{agda}
%    ∀   f : ⟨ α ⟩ ⟼ v  .  f ∈ₑ e   ⇒   α ∈ ⟪ e ⟫
%    ∀   f : v ⟼ ⟨ α ⟩  .  f ∈ₑ e   ⇒   α ∈ ⟦ e ⟧
% \end{minted}

The following property shows that in an edit script a source (target)
node is correctly part of the source (target) object.
%
In other words the source function \texttt{⟪\_⟫} and target function
\texttt{⟦\_⟧} do not forget any node.
\begin{prop}[\texttt{⟪\_⟫} and \texttt{⟦\_⟧} are correct]
\label{prop:source-target-cmp}
Given an edit script \texttt{e} and a node \texttt{α} then.
If \texttt{e ⊢ ⟨ α ⟩ ⟼ v} then \texttt{α ∈ ⟪ e ⟫}.
Similarly if \texttt{e ⊢ v ⟼ ⟨ α ⟩} then \texttt{α ∈ ⟦ e ⟧}.
\end{prop}

We now formally state the \emph{data origin} property.
\todo{Here I am assuming a diff that satisfies our specification. Is it clear?}
\begin{prop}[Data Origin]
Let \texttt{x} and \texttt{y} be two heterogeneous lists, let \texttt{e = diff x y}
and let \texttt{α} be a node.
If \texttt{e ⊢ ⟨ α ⟩ ⟼ v} then \texttt{α ∈ x}. Similarly if \texttt{e ⊢ v ⟼ ⟨ α ⟩}
then \texttt{α ∈ y}.
\end{prop}    
\begin{proof}
  It follows directly from Requirement \ref{req:diff-specs} and Proposition
  \ref{prop:diff-correct} (requirements and specifications of
  \texttt{diff}) and Proposition \ref{prop:source-target-cmp}.
\end{proof}

We now formally state the \emph{data retention} property.
\begin{prop}[Data Retention]
\label{prop:data-retention}
  Let \texttt{x} and \texttt{y} be two heterogeneous lists, let
  \texttt{e = diff x y} and let \texttt{α} be a node.
%
  If \texttt{α ∈ x} then there is a target value \texttt{v} such that
  \texttt{e ⊢ ⟨ α ⟩ ⟼ v}.
%
  Similarly if \texttt{α ∈ y} then there is a source value \texttt{v} such that
  \texttt{e ⊢ v ⟼ ⟨ α ⟩}.
\end{prop}
\begin{proof}
  It follows from Requirement \ref{req:diff-specs} and Proposition
  \ref{prop:diff-correct} (requirements and specifications of
  \texttt{diff}) and by induction on \texttt{α ∈ x}.
\end{proof}
 
  We give now similar safety properties for our \texttt{diff₃} algorithm.
  We firstly discuss \emph{edit origin}, a generalization of \emph{data origin}
  that ensures that every edit present in the merged script comes from either 
  of the input scripts. We then conclude with  \emph{persistence}, an important 
  theorem that guarantees that no changes of either version are ignored when
  the scripts are merged.

\begin{prop}[Edit Origin]
Let \texttt{e₁}, \texttt{e₂}, \texttt{e₃} be scripts such that
\texttt{e₁ ⋎ e₂} and \texttt{e₃ = e₁ ⊔₃ e₂}. Let \texttt{f} be an edit.
If \texttt{f ∈ e₃} then either \texttt{f ∈ e₁} or \texttt{f ∈ e₂}.
\end{prop}
\begin{proof}
  It follows directly from Property \ref{prop:merge3-correct}
  (correctness of \texttt{⊔₃}) and by induction.
\end{proof}

  We now formally state and prove that our merge algorithm is \emph{persistent}.
  This property is very important because conflicts are triggered by changes,
  hence a non-persistent algorithm could back-out changes to avoid raising
  conflicts.

    % \paragraph{Persistence}
    % The converse property asserts that an edit present in one of the input
    % edit scripts will be found in the merged edit script, given that it does
    % perform a change and that the output script does not contain conflicts.
    % The first hypothesis is needed because identity edits can be silently 
    % ignored in the merge semantics by either \texttt{Id₁} or
    % \texttt{Id₂}.
    % On the other hand the second prerequisite is essential, because 
    % our algorithm is \emph{persistent}, i.e.\ it refuses to back out changes 
    % made by incompatible edits, but triggers an appropriate conflict instead.

    % Firstly an edit does perform a change if it is not an identity edit, or, in 
    % other words if the source and the target values are different.
				
\begin{thm}[Persistence]
Let \texttt{e₁}, \texttt{e₂}, \texttt{e₃} be scripts such that
\texttt{e₁ ⋎ e₂} and \texttt{e₃ = e₁ ⊔₃ e₂}. Let \texttt{f} be an edit
of type \texttt{u ⟼ v} such that \texttt{u ≢ v} and \texttt{f ∈ e₁}.
Then either \texttt{f ∈ e₃} or there is a conflict \texttt{c} such that
\texttt{e₁ ⊔₃ e₂ ↑ c}.
\end{thm}
\begin{proof}
  The proof is by induction on \texttt{Merge₃ e₁ e₂ e₃} (from Property
  \ref{prop:merge3-correct}) and \texttt{f ∈ₑ e₁}.
    % 
    In the base case edit \texttt{f} is merged with some other edit
    \texttt{g}, then either \texttt{f ⊔ g ↥ c} or \texttt{f ⊔ g ↧ h}.
    %
    In the former case we are done because \texttt{f} raises a
    conflict.  In the latter case we proceed by case analysis on
    \texttt{f ⊔ g ↧ h}.
    %
    The merged edit \texttt{h} is either \texttt{f} (case \texttt{Id₂}
    or \texttt{Idem}), or \texttt{g} (\texttt{Id₁}). In the first case
    we are done, because \texttt{f} occurs in the merged script.
    %
    The second case is contradictory because we assumed \texttt{u ≢
      v}.
\end{proof}        

    The theorem holds also when the edit belongs to the other script and
    the proof is entirely symmetrical.
   		
    \subsection{Maximality}
    \todo{Not interesting, but desirable! cite Pierce}
    Another interesting property of our merge algorithm is
    \emph{maximality}, which guarantees that whenever it is possible
    to reconcile two edits from the input scripts, then the merged
    edit must be included in the merged script.
    %
    Theorem \ref{thm:max} shows that every successful merge is
    \emph{maximal}.

    \paragraph{Example} 
    Consider scripts \texttt{e₁*} and \texttt{e₂*} from section
    \ref{subsec:alignment}.
    %
    The merged edit \texttt{e₁* ⊔₃ e₂* = [Ins (::), Ins 0, Cpy (::),
      Cpy 1, Ins (::), Ins 2 , Cpy []]}, is maximal because it
    contains all the edits obtained by merging them pairwise.
    %
    \begin{thm}[Maximality]
      \label{thm:max}
      Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts
      such that \texttt{e₁ ⋎ e₂}, \texttt{e₃ = e₁ ⊔₃ e₂} and
      \texttt{e₃} does not contain any conflict. Then \texttt{e₃} is
      maximal with respect to \texttt{e₁} and \texttt{e₂}.
    \end{thm}

    \subsection{Structural  Invariants}
    \todo{Start with the problem: with structured data, there
    nodes could be rearranged in arbitrary ways to avoid conflicts.
    The structural invariant specifies how nodes can be rearranged.
    Why do we want this specific one?}
    
    An edit script describes how to transform the source object into
    the target object, by traversing it in \emph{depth-first order}
    and mapping source nodes into target nodes.
    %
    Interestingly the embedding preserves the depth-first order: if a
    source node comes before another then the mapping of the first
    will come before the mapping of the second.    
    %
    However nodes are not only mapped (updated) from the source to the
    target, but they may also be inserted and removed, therefore the
    structural invariant must be adjusted to take these edits into
    account.
    %
    Intuitively the order is preserved because nodes that 
    are mapped first in a script precede those that are mapped later.
    %
    We start by generalizing depth-first ordering to list of trees and
    giving a basic ordering to edits in a script.
    %
    % The structural invariant property relies on 
    % by showing how the former implies the latter we deduce
    % the structural invariant.
    

    \paragraph{Depth-First Order}
    A pre-order depth-first traversal consists of firstly visiting the current node 
    and then traversing recursively its subtrees from the leftmost to the rightmost.
    The traversal induces an ordering on the nodes, so that those that
    are visited sooner come before those that are processed later.
    Since edit scripts work with list of trees, we have to generalize the
    ordering accordingly.
    
    The type \texttt{hs ⊢ α ⊏ β} denotes that the node \texttt{α}
    comes before the node \texttt{β}, according to depth first
    traversal of the trees contained in the list of trees \texttt{hs}.
    \todo{Probably drop data type. Better notation?}
\begin{minted}{agda}
data _⊢_⊏_ : Hist xs → C as a → C bs b → Set where
  here : β ∈ (hs₁ +++ hs₂) → Node α hs₁ ∷ hs₂ ⊢ α ⊏ β
  there : (hs₁ +++ hs₂) ⊢ α ⊏ β → Node γ hs₁ ∷ hs₂ ⊢ α ⊏ β
\end{minted}

    Intuitively the list is used as a stack, so that after visiting
    each node its children, yet to be traversed, are pushed on the stuck.
    Note that those trees will be visited before those already on the stuck,
    hence following correctly the depth-first traversal.

    \paragraph{Edit Order}
    Since edit scripts are a flat list-like data structure, we simply
    order edits according to their position in the script.

\begin{definition}[Edit Order]
Given an edit script \texttt{e} and two edits \texttt{f} and \texttt{g}, we write
\texttt{e ⊢ f ⊏ g} if and only if \texttt{f} precedes \texttt{g} in \texttt{e}.
\end{definition}

\paragraph{Order Invariant}
Before stating the main theorem relies on two fundamental properties:
that the target (source) function and \texttt{diff} are
\emph{order-preserving} (OP).
%
Property \ref{prop:order-preserving-target-fun} guarantees that the
relative order of edits in a script corresponds to the depth-first
order of their target (source) nodes in the target (source) objects.
%
Property \ref{prop:order-preserving-embedding} ensures that if in the
target (source) object a node precedes another, then in the diff
script the first node is produced by an edit that comes before the
edit that produces the second.

\begin{prop}[\texttt{⟦\_⟧} is OP]
\label{prop:order-preserving-target-fun}
Let \texttt{e} be an edit script and \texttt{f} and \texttt{g} edits
of type \texttt{v ⟼ ⟨ α ⟩} and \texttt{w ⟼ ⟨ β ⟩}, such that
\texttt{e ⊢ f ⊏ g}, then \texttt{⟦ e ⟧ ⊢ α ⊏ β}.
\end{prop}
  We omit the symmetrical property for \emph{source} nodes and objects.

\begin{prop}[Embedding is OP]
\label{prop:order-preserving-embedding}
Let \texttt{x} and \texttt{y} be heterogeneous lists and let 
\texttt{e} be an edit script such that \texttt{e = diff x y}.
Let also \texttt{α} and \texttt{β} be nodes such that \texttt{y ⊢ α ⊏ β}.
Then there are edits \texttt{f : u ⟼ ⟨ α ⟩} and \texttt{g : v ⟼ ⟨ β ⟩}
such that \texttt{e ⊢ f ⊏ g}.
\end{prop}
\begin{proof}
  The proof relies on Requirement \ref{req:diff-specs} and Proposition
  \ref{prop:diff-correct} (requirements and specifications of
  \texttt{diff}).
  %
  By induction on \texttt{y ⊢ α ⊏ β} we locate \texttt{f : u ⟼ ⟨ α ⟩}
  in \texttt{e}. 
  %
  By Proposition \ref{prop:data-retention} it follows that there
  exists \texttt{g : v ⟼ ⟨ β ⟩} in the tail of \texttt{e}.
\end{proof}
We again omit the dual property for \emph{source} nodes and object.

    % We now have all the lemmas to prove the \emph{order invariant}
    % theorem, which ensures that the edit script data type preserves
    % the depth-first order of the source (target) objects.
    %
We now prove our main theorem, which ensures that
\texttt{diff} preserves the relative order of nodes in the
source (target) objects.
%
Since nodes may also be deleted the property sees also these cases,
namely if node \texttt{α} precedes \texttt{β} in the source object of
script \texttt{e}, then one of the following holds:
    \begin{itemize}
    \item Node \texttt{α} is deleted in \texttt{e};
    \item Node \texttt{β} is deleted in \texttt{e};
    \item Node \texttt{α} is mapped to some node \texttt{γ} and node
      \texttt{β} is mapped to some node \texttt{φ}, such that node
      \texttt{γ} comes before node \texttt{φ} in the target object.
    \end{itemize}
%
    We show only the theorem about the \emph{source} object, because
    the other is symmetrical.
\begin{thm}[\texttt{diff} is OP]
  Let \texttt{x} and \texttt{y} be heterogeneous lists and \texttt{e}
  an edit script, such that \texttt{e = diff x y}. Let also \texttt{α}
  and \texttt{β} be nodes such that \texttt{x ⊢ α ⊏ β} then either
  \texttt{e ⊢ ⟨ α ⟩ ⟼ ⊥} or \texttt{e ⊢ ⟨ β ⟩ ⟼ ⊥} or there exists nodes
  \texttt{γ} and \texttt{φ} such that \texttt{e ⊢ ⟨ α ⟩ ⟼ ⟨ γ ⟩},
  \texttt{e ⊢ ⟨ β ⟩ ⟼ ⟨ φ ⟩} and \texttt{y ⊢ γ ⊏ φ}.
\end{thm}
\begin{proof}
  By Proposition \ref{prop:order-preserving-embedding} there are edits
  \texttt{f : ⟨ α ⟩ ⟼ u} and \texttt{g : ⟨ β ⟩ ⟼ v}, such that
  \texttt{e ⊢ f ⊏ g}.
  %
  By case analysis either \texttt{u = ⊥} or \texttt{v = ⊥} or \texttt{u = ⟨ γ ⟩}
  and \texttt{v = ⟨ Φ ⟩}. In the first (second) case \texttt{α} (\texttt{β}) is deleted and we are done.
  In the third case they are both updated, i.e.\ \texttt{e ⊢ ⟨ α ⟩ ⟼ ⟨ γ ⟩} and
  \texttt{e ⊢ ⟨ β ⟩ ⟼ ⟨ φ ⟩}.
  %
  By Proposition \ref{prop:order-preserving-target-fun} we deduce that
  \texttt{⟦ e ⟧ ⊢ γ ⊏ Φ} and by Requirement \ref{req:diff-specs} and
  Proposition \ref{prop:diff-correct} (requirements and specifications
  of \texttt{diff}) it follows that \texttt{y ⊢ γ ⊏ Φ}.
\end{proof}

We now generalize the \emph{order invariant} property to
\texttt{diff₃}, which guarantees that the relative order of edits in
each input script is preserved in the merged script.
%
Note that the property is restricted only to successful merges and
furthermore only to \emph{non-identity} edits, since they could 
ne be excluded in favor of proper changing edits otherwise.
%
The property holds intuitively because the merge algorithm does not
rearrange the input edits, but rather merge them pointwise, retaining
the original order in the merged script.
%
\todo{Better! Give me a take home message!}
\begin{thm}[\texttt{diff₃} is OP]
  Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts such
  that \texttt{e₁ ⋎ e₂}, \texttt{e₃ = e₁ ⊔₃ e₂} and \texttt{e₃} does not
  contain conflicts.
%
  Let \texttt{f} and \texttt{g} be edits of type \texttt{u ⟼ v} and
  \texttt{w ⟼ z} such that \texttt{u ≢ v}, \texttt{w ≢ z} and
  \texttt{e₁ ⊢ f ⊏ g}, then \texttt{e₃ ⊢ f ⊏ g}.
\end{thm}
  The theorem holds also with respect to the edits contained in \texttt{e₂}.

\section{Example Revised}
\label{sec:haskell}
In this section, we revisit the motivating example from Section
\ref{sec:intro} using our fine-grained merge algorithm and show that
it performs better than line-based \texttt{diff3}.
%
Furthermore while presenting this example we show the API of the
Haskell library that implements our algorithm.
%
Haskell can only partially simulate dependently typed programming,
therefore the library cannot enforce certain invariants of the
original model, such as \todo{In particular} \emph{aligment}, which are instead checked at
run-time.
%
On the other hand, the Haskell implementation has much better
performance, an essential requirement to make our algorithm practical.
%

\subsection{Data  Representation}
In our model we used the abstract representation \texttt{C as a}
for a constructor of the algebraic data type \texttt{a} which takes
arguments \texttt{as}.
%
In the library this construct is encoded as a Generalized Algebraic
Data Type (GADT), indexed by a list of types and a target type.
%
Each constructor of the algebraic data type is represented separately
by one of its constructor, which instantiates the first index with
the type of its arguments and the second with the resulting type.
%
\paragraph{Example}
We encode the list constructors in \texttt{ListC}:
\begin{minted}{haskell}
data ListC (as :: [ * ]) (a :: *) where
  Nil :: ListC '[] [a]
  Cons :: ListC '[a , [a]] [a]
\end{minted}
\todo{Explain the constructors!!!}
In Haskell, lists are automatically lifted to the type level and they
both share the same syntax, hence we put a tick to distinguish lifted
lists of kind \texttt{[ * ]} from the type of homogeneous lists of kind \texttt{*}.
%
Primitive types such as integer are also encoded in a similar data
type, but since they may assume many values, they are all combined in
a single constructor that takes the original value.
\begin{minted}{haskell}
data IntC xs a where
  I :: Int → IntC '[] Int
\end{minted}

These two encoding are sufficient for our example, in
which we encode tables as lists of lists of integers.
\begin{minted}{haskell}
type Csv = [[Int]]
\end{minted} 

\subsection{Diffing}
Since \texttt{diff3} relies on \texttt{diff}, our library
defines a type class for types that can be diffed.

\begin{minted}{haskell}
class Typeable a => Diff a where
  type Encoding a :: [ * ] → * → *
  toHTree :: a → HTree a
  fromHTree :: HTree a → a
  (=?=) :: C xs a → C ys a → Maybe (xs :~: ys)
  distance :: C xs a → C ys a → Double
\end{minted}
The associated type family \texttt{Encoding a} returns the concrete
data type that encodes the constructors of \texttt{a}.
%
The type synonym \texttt{C} is used to improve readability of signatures
and for consistency:
\begin{minted}{haskell}
type C xs a = (Encoding a) xs a
\end{minted}
\todo{You can also do it with another type class parameter and functional 
dependencies but it is worse in end.}
%
Methods \texttt{toHTree} and \texttt{fromHTree} are inverse functions
that embed a value into and from the generic representation.
% 
% The universe used in the implementation corresponds precisely to that
% of the model, except that it requires a \texttt{Diff} instance for
% every child of a node.
%
% \begin{minted}{haskell}
% data HList xs where
%   HNil :: HList []
%   HCons :: Diff a => HTree a → HList as → HList (a : as)
%
% data HTree a where
%   Node :: C as a → HList as → HTree a
% \end{minted}
%
% This definition automatically ensures that the whole family of mutually recursive 
% types have a \texttt{Diff} instance.
%
Method \texttt{(=?=)} tests equality between constructors of the same
data type, and if so it returns a proof that their field types are
equal. This operator is used by the merge algorithm to dynamically
check \emph{alignment} and to determine whether an update is just a copy.
%
The function \texttt{distance} computes the cost of an update between
constructors of the same type and it is expected to be a
\emph{metric}.

\begin{definition}[Metric]
\label{par:Metric}
A metric on a set A is a function
d : (A × A) → ${\rm I\!R}$ such that $\forall$ x, y, z $\in$ A:
	\begin{align*}
		d(x, y) &\geq 0 \quad &\mbox{\emph{{(non-negativity)}}}\\ 
		d(x, y) &= 0 \Leftrightarrow x = y \quad &\mbox{\emph{(coincidence axiom)}} \\		
		d(x, y) &= d(y, x) \quad &\mbox{\emph{(symmetry)}}\\
		d(x, z) &\leq d(x, y) + d(y, z) \quad &\mbox{\emph{(triangle inequality})}
	\end{align*}
	
\end{definition}
A reasonable distance function for algebraic
data type constructors is the \emph{discrete distance}:
	\[ d(x, y) = 
		\begin{cases} 
			0 \quad &\mbox{if } x = y \\
			1 \quad &\mbox {otherwise}		
		\end{cases} \]	
%
Lastly the superclass \texttt{Typeable} provides methods to inspect and
compare types at run-time.
The \texttt{diff} and \texttt{diff3} algorithms use its methods respectively 
to check whether two constructors are of the same data type
and to type-check a merged edit script.

\paragraph{Example}
Diffing tables requires only a \texttt{Diff} instance for integers
and one for lists.
In fact given the \texttt{Diff} instance for the content type, we can
derive a \texttt{Diff} instance for lists of them.

\begin{minted}{haskell}
instance Diff a => Diff [a] where	
  type Encoding [a] = ListF

  Nil =?= Nil = Just Refl
  Cons =?= Cons = Just Refl
  _ =?= _ = Nothing

  toHTree [] = Node Nil HNil
  toHTree (x : xs) = Node Cons (HCons (toHTree x) hs)
    where hs = HCons (toHTree xs) HNil

  fromHTree (Node Nil HNil) = []
  fromHTree (Node Cons (HCons t (HCons ts HNil))) 
    = fromHTree x : fromHTree ts

  distance Nil Nil = 0
  distance Cons Cons = 0
  distance _ _ = 1
\end{minted} 
%
The \texttt{Diff Int} is straightforward:
\begin{minted}{haskell}
instance Diff Int where
  type Encoding Int = IntF

  (I x) =?= (I y) = if x == y then Just Refl else Nothing
  
  toHTree x = Node (I x) HNil
  
  fromHTree (Node (I x) HNil) = x

  distance (I x) (I y) = if x == y then 0 else 1
\end{minted}
When applied to primitive types, method \texttt{=?=} needs to check that the
actual values are in fact equal.
%
Tables are just lists of list of integers, so that the same list
\texttt{Diff} instance is used twice, once to derive \texttt{Diff
  [Int]} from \texttt{Diff Int} and then to automatically derive
\texttt{Diff [[Int]]} from it.
%
In both the instances we used \emph{discrete distance}, however
depending on the specific domain more fine grained distance measure
could be used to get more precise diffs.

\paragraph{Algorithm}
A  \texttt{diff} algorithm takes as input two objects and outputs an
edit script that reports the differences between them.
%
In particular, GNU \texttt{diff} finds a \emph{minimal length} edit
script, or equivalently the \emph{longest common subsequence} of its
inputs \cite{Berg00, PierceDiff3}, that is a script which 
copies as many lines as possible.
%
Our library detects differences between two values by means of function \texttt{gdiff}:
\begin{minted}{haskell}
gdiff :: (Diff a, Diff b) => a → b → ES '[ a ] '[ b ]
\end{minted}
%
Our \texttt{diff} algorithm is mostly an extension of that of
Lempsink's et al.\ therefore we omit it.
%
We only remark that we have adjusted the definition of edit script length,
in order to take into account update edits, whose cost is given
by the \texttt{distance} function.
%
When using \emph{discrete distance}, a single update edit is preferred
to a delete and a subsequent insert.
%
\paragraph{Patch}
Our library provides also a \texttt{patch} function, which corresponds to
the target function \texttt{⟦\_⟧} of the model.
\begin{minted}{haskell}
patch :: ES xs ys → HList ys
\end{minted}

We remark that contrary to that of Lempsink's \cite{Lemp09} the function
is total and furthermore does not need the source object to compute the
target object, since the edit script alone contains all the information
necessary to reconstruct it.

\subsection{Merging}
Merging consists in diffing the base version with respect to each new
version, producing two edit scripts that are combined following the
three-way merge technique.
%
The merge may fail either due to some conflict or because it generates
an ill-typed script.
%
Our library merges objects in this way by means of function \texttt{gdiff3}:
\begin{minted}{haskell}
gdiff3 :: Diff a => a → a → a → Either [Conflict] (ES '[ a ] '[ a ])
gdiff3 x o y = typecheck $ merge e1 e2
  where e1 = diff [ toHTree o ] [ toHTree x ]
         e2 = diff [ toHTree o ] [ toHTree y ]
\end{minted}
The input objects are transformed in our generic encoding by \texttt{toHTree}
and diffed with respect to the original version.
%
For the sake of brevity we are lifting list syntax to heterogeneous lists,
so that \texttt{[ toHTree o ] :: HList '[ a ]} is a singleton list
containing the \texttt{HTree a} representation of \texttt{o}.
%
Edit scripts \texttt{e₁} and \texttt{e₂} are merged by function
\texttt{merge}, that implements the merge operator \texttt{⊔₃},
producing a merged edit script that is lastly typechecked by function
\texttt{typecheck}.
%

\paragraph{Example}
Variables \texttt{a}, \texttt{b} and \texttt{c} represent the tables
of the example from the introduction:
\begin{minted}{haskell}
a :: Csv
a = [[1,2,3],
      [4,5,6],
      [7,8,9]]

b :: Csv
b = map (0 :) a

c :: Csv
c = [[1,2,3],
      [4,5,9],
      [7,8,15]]
\end{minted}

Merging them using \texttt{gdiff3} succeeds and gives the expected table:
\begin{verbatim}
Main> let Right e = gdiff3 b a c
Main> patch e
[[0,1,2,3], [0,4,5,9], [0,7,8,15]]
\end{verbatim}



% \subsection{Example}
% Interactive session with initial example revised.

\section{Discussion and Related Work}
\label{sec:related-work}
Research in the field of change detection and merge has produced a
variety of tools that address these problems.  Many focus on XML
files, such as LaDiff \cite{Chawathe96}, MH-Diff \cite{Chawathe97} and
3DM \cite{Lind01, Lind04, Lind05}.  We refer to Peters for a
comprehensive survey \cite{PetersSurvey}.
%
Other works address file and data synchronization, which raises
problems similar to those discussed in this paper. Relevant examples
include Unison, a file synchronizer \cite{Pierce98, UnisonSpec};
Harmony, a synchronizer for heterogeneous data
\cite{HarmonyOverview,Pierce07} and an algebra for file
synchronization \cite{Ramsey01}.
%
Lastly some mergers are tailored exclusively on software artifacts
\cite{Westfechtel91, Mens02, Apel11}. 

\paragraph{Diff}
Merging relies on a \texttt{diff} algorithm to detect changes between
objects, which are then to be merged according to some strategy.
%
Our \emph{edit script} is inspired by Lempsink's \cite{Lemp09}, but
employs a more general notion of \emph{edit}, a mapping between
values, which enables reasoning about merge and conflict.
%
While Lempsink's \texttt{diff} algorithm finds a \emph{minimal length}
edit script, ours uses a \emph{cost} measure, which is parametric in
the \texttt{distance} function used to weight updates.  
%
We both employ similar trees and heterogeneous list, but our
constructor representation handles also \emph{polymorphic}
data types such as lists, while their approach requires 
to encode families of mutually recursive data-types
at once, furthermore only with fully instantiated types.
Our representation is instead modular and reusable.

\paragraph{Ordered and Unordered Data} 
The merge algorithm presented in this paper works on algebraic data
types, which are strongly typed, tree-like, ordered objects. File
systems are usually hierarchical, but not inherently ordered, while
XML trees can also be unordered.
%
Schemas are used in Harmony to identify specific
conflicts (\emph{schema domain conflicts}), which would break their
structural invariants \cite{Pierce07}.
%
They play a role similar to types in this work, which we use to
type-check edit scripts.
%
Chawathe et al.\ assume that nodes have unique identifiers
\cite{Chawathe96}, which greatly simplifies the change detection
phase.
%
This assumption is inappropriate in our context because data formats
do not usually mark their content, furthermore even XML trees
might not have identifiers in their nodes.
	
\paragraph{Alignment and Data Structures} 
Alignment of corresponding parts plays a central role when merging
two objects. 
%
In this work the alignment is \emph{global} and mainly determined by
\texttt{diff} \todo{Discuss alignment and diff in the Haskell
  section?} which computes the embedding of the source into the target
object, by minimizing an appropriate cost model.
%
GNU \texttt{diff3} aligns lines of texts dividing them in stable and
unstable \emph{chunks} based on the longest common subsequences
computed by \texttt{diff} \cite{PierceDiff3}.  
%
Overlapping equal lines are matched and fused in stable chunks,
leaving possibly conflicting chunks between them.
%
This technique works well when lines are mostly unique such as in
software artifacts.
%
We doubt that this technique would give good results in our context.
%
Firstly the basic values to be aligned are unlikely to be unique,
increasing the chances of misalignment.
%
Secondly such an aligner would not take into account the tree-like
structure of the data, possibly missing important matching.
%
Our aligner retains the structured nature of the data by preserving
the relative order of the nodes and strives to generate a proper
embedding by matching pairs of nodes and preferring updates
to a sequence of delete and insert.
%
The \emph{alignment} strategy has a profound impact when merging data
structures.
%
Harmony employs a \emph{local} strategy, that associates subtrees by
name, therefore it is able to merge correctly unordered collections
such as records and sets.
%
Our algorithm struggle with unordered data structures, 
because it treats them as structured.
%
On the other hand Harmony performs poorly with lists, because
it \emph{align} them by absolute position.
%
For example merging \texttt{[1, 3]} with \texttt{[2]} and base 
\texttt{[1, 2]} surprisingly it gives \texttt{[2, 3]}, instead of
\texttt{[3]} as we do.
%
Chawathe and Molina reduce the change detection problem to the problem
of computing a minimum-cost edge cover of a bipartite graph
\cite{Chawathe96}.
%
Since this problem is NP-hard they employ an heuristic, consisting of
pruning rules, to find a \emph{minimal} edge cover.
			
\paragraph{Edit Operations} 
Edit operations are very important in a diffing algorithm, because
they determine how precisely changes in data can be detected, 
hence affecting the merging phase.
%
GNU diff employs insert, delete and copy in scripts only and updates
are imprecisely encoded as a delete followed by an insert.  Our
algorithm detects updates explicitly reducing the number of false
conflicts and raising more specific and informative true conflicts
(\texttt{UpdUpd}, \texttt{UpdDel}, \texttt{DelUpd}).
%
Some synchronizers employ also a \emph{move} edit operation
\cite{Lind04, Chawathe96, Chawathe97}.
In our algorithm and in Ramsey's \cite{Ramsey01}, move edits
are encoded by delete and insert, bearing the same 
drawbacks of an imprecise representation.
Move can improve the quality of diffs only if it is detected
with a fair confidence, therefore Lindholm takes into
account the \emph{context} of a node in order to improve the precision.
%
With respect to our work we remark that move edits would weaken 
the structural invariants guarantees and would probably 
complicate reasoning \cite{Ramsey01}.
	
\paragraph{Formal Model}
The semantics of merging algorithms employed in version control
systems, with the notable exception of Darcs \cite{HomoPatchTheory,
  CategoryPatchTheory} is not formalized, but it is usually understood
empirically, leading to severe misconceptions \cite{PierceDiff3}.
%
For instance it is in general hard to predict the outcome of complex
merges and determine whether a conflict is indeed true or the
consequence of a bug.
%
Furthermore, even when merges are successful, they might produce
unexpected results, for instance duplicating lines or changing their
order.
%
This situation calls for a formalization of such merging algorithms.
%
Unison \cite{UnisonSpec} is an example of a file synchronizer
automatically derived from a formal model \cite{Pierce98}.
%
In this paper we have presented several properties of our algorithms,
inspired by the work from Pierce et al.\ in Harmony
\cite{HarmonyOverview}.
%
Ramsey and Csirmaz proposes an algebraic approach to file
synchronization \cite{Ramsey01}. 
%
Differently from our work their synchronizer is
\emph{operation-based}, rather than \emph{state-based}, i.e.\ it does
not rely uniquely on the current states of the replicas, but it
requires to track the operations that changed them.
%
They give a proof system for a simple filesystem algebra,
and prove that it is sound and complete.
%
% The model is based on a relation between sequences of commands that
% ensures that a sequence safely approximates another and conflictless
% synchronization is possible if there is a sequence at least as good as
%both.
%
However the system is quite large, for only five operations it
consists of about fifty laws, to the point that it requires automatic
techniques to prove it sound.
%
On the other hand our model is instead concise and straightforward
to analyze.
%
% The 3DM tool devised by Lindholm does not include a mechanically
% verified model and moreover the general merge rules have been derived
% analyzing the expected result of use cases \cite{Lind04}.  His change
% model is based on \emph{content} and \emph{structural change}. The
% changes in each version are combined into a change set and can be
% merged only if the set is \emph{consistent}, i.e.  unambiguously
% determine at most one parent, predecessor and successor for each node.
% Conflicts are divided in core conflicts and optional conflicts and are
% overall consistent with those listed in \ref{subsec:Merge}, except for
% the delete/edit conflict, which is optional, whereas in this thesis is
% not. It is not explained under which circumstances these changes could
% be considered compatible.  The lack of a formal model raises some
% doubts about the properties claimed for the merge.  First of all the
% merge is considered symmetric, but later it is admitted that appends
% of nodes originated from different trees may be accepted in either
% order. This kind of implementation details are actually relevant from
% the user point of view and have so far fostered the need for formal,
% unambiguous models. In this thesis inserts compete for matching
% positions and may trigger conflicts if incompatible.  Secondly the
% fourth merge rule explicitly requires that changes in either versions
% to be included in the merged tree, however the fact that updates in
% deleted trees are optionally considered conflicts contradicts this
% rule and weaken the property about preservation of edits.

\section{Conclusion and Future Work}
\label{sec:conclusion}
We present a state-based, three-way, persistent, data type generic
\texttt{diff3} algorithm for typed algebraic data type.
%
By employing more accurate edits we detect changes in data more
precisely, leading to more specific edit scripts and ultimately
reducing the number of spurious conflicts raised in merges and
improving the quality of automatic reconciliation.
%
We have formalized the semantics of merge and conflict in Agda and
use it to prove several properties about our algorithm allowing
users to reason about complex merge operations.
%
We have released an efficient version of our algorithm as an Haskell
library.
%
Moved from our promising results, we plan to perform a rigorous evaluation
of our algorithm on real world data as future work.
%


% We achieve a better precision in detecting changing 
% in the \emph{change-detection} phase by
% extending the 
%  the edits that describe changes in adata we achieve a 
% \appendix
% \section{Appendix Title}

% This is the text of the appendix, if you need one.

% \acks

% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.
\bibliography{svc}

% \softraggedright


% \end{thebibliography}

\listoftodos

\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices
]

%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex -shell-escape
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End: 

