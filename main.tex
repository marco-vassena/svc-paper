%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------

\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{hyperref}

\usepackage{minted} % Code listing with reasonable good highlighting
\usepackage{bussproofs}   % For typing judgments
\usepackage[no-math]{fontspec}
\setmonofont[Scale=MatchLowercase]{Apple Symbols} % Unicode mono font

\usepackage[dvipsnames]{xcolor}  		% Color package
\definecolor{dgreen}{rgb}{0.,0.6,0.}    % Deep green
\usepackage{caption}
\usepackage{todonotes}	% todos

% Figures with border
\usepackage{float}
%\floatstyle{boxed} 
\restylefloat{figure}

\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{fancyvrb}

% Definitions for unicode characters not included
\usepackage{newunicodechar}                   
\newunicodechar{ᶜ}{$^c$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ᵗ}{$^t$}
\newunicodechar{ˢ}{$^s$}

\usepackage{pifont}
\newunicodechar{✗}{\ding{55}}

\usepackage{amsthm}
\usepackage{amsmath}
 
\theoremstyle{plain}
\newtheorem{definition}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{cor}{Corollary}
\newtheorem{req}{Requirement}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusiveo license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Generic diff3 for Algebraic Datatypes}
\subtitle{Subtitle Text, if any}

\authorinfo{Marco Vassena}
           {Chalmers University}
           {vassena@chalmers.se}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}

\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}
Version control systems (VCS) such as Git \cite{Git} and Mercurial \cite{Mercurial}
are used in the software industry, as well as in the open source community and by researchers all over the world to develop software.
These tools track all the changes in the source code throughout its development, making it possible to quickly roll back to any previous version. Furthermore developers can simultaneously work on the same project and use a VCS to merge their changes together.
VCS provides these features by means of two algorithms, called \texttt{diff} and \texttt{diff3}.
The former detects changes in source code files and it is used to track their history, while the latter merges independent changes made to the code base, allowing simultaneous development.
These algorithms are line-based, they compare files line by line, and can be used not only on software artifacts, but with any text-based file. 
Unfortunately their fixed-granularity limit their precision when detecting changes and deteriorate their merging capabilities. In this paper we develop a data-type generic version of the \texttt{diff} and \texttt{diff3} algorithms, that improve their precision and applicability.

\paragraph{Example}
We show the shortcomings of the line-based \texttt{diff} and \texttt{diff3} algorithms by means of an example.
The Comma Separated Values file format (CSV) is a simple text-based encoding of data stored in tables \cite{csv}.
In a CSV file every line represents a row of the table and within each row commas separate values in different columns.
For instance the file \texttt{a.csv} encodes a $3 \times 3$ table containing numbers from 1 to 9.
\begin{figure}[!h]
\centering
\begin{minipage}{.25\textwidth}
  \centering
  \begin{tabular}{ | c | c | c | }
    \hline
    1 & 2 & 3 \\ \hline
    4 & 5 & 6 \\ \hline
    7 & 8 & 9  \\ \hline
  \end{tabular}
\end{minipage}%
\begin{minipage}{.25\textwidth}
  \centering
  \begin{verbatim}
  $ cat a.csv
  1,2,3
  4,5,6
  7,8,9
  \end{verbatim}
\end{minipage}%
\end{figure}

\newpage
Imagine that two users are simultaneously working on this table.
The first user adds a column filled with zero and saves the new table in \texttt{b.csv}:
\begin{figure}[h]
\centering
\begin{minipage}{.25\textwidth}
  \centering
  \begin{tabular}{ | c | c | c | c | }
    \hline
    \textcolor{blue}{0} & 1 & 2 & 3 \\ \hline
    \textcolor{blue}{0} & 4 & 5 & 6 \\ \hline
    \textcolor{blue}{0} & 7 & 8 & 9  \\ \hline
  \end{tabular}
\end{minipage}%
\begin{minipage}{.25\textwidth}
  \centering
\begin{Verbatim}[commandchars=\\\{\}]
  $ cat b.csv
  \textcolor{blue}{0},1,2,3
  \textcolor{blue}{0},4,5,6
  \textcolor{blue}{0},7,8,9
\end{Verbatim}
\end{minipage}%$
\end{figure} 

The second user changes some values in the third column and saves the new table in  \texttt{c.csv}:
\begin{figure}[h]
\centering
\begin{minipage}{.25\textwidth}
  \centering
  \begin{tabular}{ | c | c | c | }
    \hline
    1 & 2 & 3 \\ \hline
    4 & 5 & \textcolor{magenta}{9} \\ \hline
    7 & 8 & \textcolor{magenta}{15} \\ \hline
  \end{tabular}
\end{minipage}%
\begin{minipage}{.25\textwidth}
  \centering
  \begin{Verbatim}[commandchars=\\\{\}]
  $ cat c.csv
  1,2,3
  4,5,\textcolor{magenta}{9}
  7,8,\textcolor{magenta}{15}
  \end{Verbatim}
\end{minipage}% $
\end{figure}

The two users would like to synchronize their work now and decide to use 
\texttt{diff3} to merge their versions. They have modified \emph{indipendent} parts of the table, therefore they are confident that it is should be possible to automatically merge the changes, without incurring in a conflict.
Unfortunately \texttt{diff3} is a line-based algorithm therefore it compares files line by line, without considering the actual structure of the data stored in the files. As a result the algorithm fails to merge the two tables and raises spurious conflicts.

In particular \texttt{diff3} employs the \emph{three-way-merge} technique to compare and merge the corresponding lines of three files. The following table shows the result of applying this technique to the previous tables:
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\texttt{b} & \texttt{a} & \texttt{c} & \texttt{diff3 b a c} \\ \hline
\texttt{\textcolor{blue}{0},1,2,3} & \texttt{1,2,3} & \texttt{1,2,3} & \textcolor{dgreen}{\texttt{0,1,2,3}} \\ \hline
\texttt{\textcolor{blue}{0},4,5,6} & \texttt{4,5,6} & \texttt{4,5,\textcolor{magenta}{9}} & \textcolor{red}{✗}  \\ \hline
\texttt{\textcolor{blue}{0},7,8,9} & \texttt{7,8,9} & \texttt{7,8,\textcolor{magenta}{15}} & \textcolor{red}{✗} \\ \hline
\end{tabular}
\end{center}
A merge is possible when there is at most one different version of the same line, as it happens in the first row.
A conflict is instead triggered when the same line is different in all the three versions, which is the case in the second and third row.


\paragraph{Discussion}
The main limitation of \texttt{diff3} and \texttt{diff} is that they are  coarse-grained, because they operate on data representation with a fixed precision consisting of one line of text, therefore disregarding completely any information about the actual structure of the data.
If \texttt{diff} and \texttt{diff3} were aware of the table structure, consisting of columns and rows, then \texttt{diff} could exactly represent the differences in each version and \texttt{diff3} could automatically merge them, as the users expected:
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\textcolor{blue}{0} & 1 & 2 & 3 \\ \hline
\textcolor{blue}{0} & 4 & 5 & \textcolor{magenta}{9} \\ \hline
\textcolor{blue}{0} & 7 & 8 & \textcolor{magenta}{15} \\ \hline
\end{tabular}
\end{center}

% Obviously we do not want to implement format specific \texttt{diff} and \texttt{diff3} algorithms, since this would hinder reusability, but instead
% they manipulate data directly, assuming that parsers and serializers for it are available. Furthermore we would like our algorithms to be as reusable as possible, with data of any possible shape.

\subsection{Contributions}
In this paper we make the following contributions:
\begin{itemize}
\item In section \ref{subsec:edit-script} we define a type-safe edit script data 
      type that supports \emph{delete}, \emph{insert} and \emph{update} edits and 
      that represents the differences between two objects. In section 
      \ref{subsec:diff-algo} we give the formal specifications of a \texttt{diff} 
      algorithm in terms of the edit script data type.
\item In section \ref{subsec:merge-semantics} we formalize the 
      \emph{three-way-merge} strategy and give a precise semantics of 
      \emph{mergeable} and \emph{conflicting} edits. We give 
      the formal specifications of a \texttt{diff3} algorithm in terms of our edit 
      semantics. 
\item In section \ref{subsec:diff3-algo} we show a data-type generic, three-way 
      \texttt{diff3} algorithm that satisfy our specifications and we study its 
      formal properties in section \ref{sec:properties}.
\end{itemize}
We have implemented these algorithms using generic programming techniques in Agda \cite{agda}, a programming language with dependent types and a proof assistant. 
Dependent types are particularly convenient in this setting to idiomatically encode the pre-conditions and post-conditions of our algorithms and ultimately verify their properties.
The source code containing the \texttt{diff} and \texttt{diff3} algorithms, their properties and formal proofs are available online\footnote{TODO create separate repo just for this}. 
For the sake of presentation we have simplified the code presented in this paper, for instance by 
hiding implicit arguments and universe levels.

\section{Universe}
In order to implement data type generic algorithms we need a generic
representation of algebraic data types.
%
The universe used in this paper consists of typed heterogeneous rose
trees, a combination of mutually recursive heterogeneous lists and
trees whose \emph{nodes} correspond to data type constructors and
their children to their fields.
\begin{minted}{agda}
  data HTree : Set → Set where
    Node : F as a → HList as → HTree a

  data HList : List Set → Set where
    [] : HList []
   _∷_ : HTree a → HList as → HList (a ∷ as)
\end{minted}
	The type \texttt{F as a} denotes the constructor of an algebraic data
	type of type \texttt{a} that takes arguments of types determined by the list 
	\texttt{as}.
        %
        This representation is type-safe because the constructor
        \texttt{Node} requires the same types \texttt{as} in the
        fields types and in the list of subtrees, hence it forms a
        well-typed application of a constructor to its arguments.
        %
	We will show in section \ref{sec:haskell} how to instantiate \texttt{F} with concrete 
        data types. In the model we will just leave it abstract as a module parameter.
\begin{minted}{agda}
module Diff3 (F : List Set → Set → Set) where
\end{minted}
	
        \paragraph{Example} 
        The list \texttt{[1,2]} can be encoded in this universe as: 
\begin{Verbatim}[commandchars=\\\{\}]
hs : HList [List Int]
hs = Node (\textcolor{blue}{::}) [Node \textcolor{magenta}{1} [], Node (\textcolor{blue}{::}) [Node \textcolor{magenta}{2} [], Node \textcolor{blue}{[]} []]]
\end{Verbatim}
        Where \texttt{(\textcolor{blue}{::}) : F [Int, List Int] (List Int)}
        and \texttt{\textcolor{blue}{[]} : F [] (List Int)} are the reification of respectively the cons constructor and the
        empty list constructor, specialized without loss of generality to the type \texttt{List Int}.
        Similarly in our examples we will automatically lift numbers to node constructors, that is
        \texttt{\textcolor{magenta}{1}, \textcolor{magenta}{2} : F [] [Int]}.

	In the following we will use two auxiliary functions to append and split 
	heterogeneous lists:
\begin{minted}{agda}
_+++_ : HList as → HList bs → HList (as ++ bs)
hsplit : HList (as ++ bs) → HList as × HList bs
\end{minted}
	
\section{Generic diff}
	Our \texttt{diff3} algorithm relies on a \texttt{diff} algorithm used 
        as a subroutine to quickly compare the input objects and merge them.
	The algorithm finds the differences between two heterogeneous lists given 
	as input producing an edit script, whose edit operations progressively 
	transform one into the other.

	\subsection{Edit Operations}
	Single edits are defined over \emph{values}, which denote either the presence or 
	the absence of a node.
        At first we might try to define them as a maybe value:
\begin{minted}{agda}
Val : List Set -> Set -> Set
Val as a = Maybe (F as a)
\end{minted}
        In the type \texttt{Val as a} the parameters \texttt{as} and \texttt{a} 
        witness the possible presence of a node \texttt{F as a}, that given objects 
        of types \texttt{as} will produce an object of type \texttt{a}.
        The drawback of this encoding is that \texttt{as} and \texttt{a} are 
        valid input and output approximations only if a node is in fact present.
        An indexed data type on the other hand can give a much more accurate
        approximation:
\begin{minted}{agda}
data Val : List Set → List Set → Set where
  ⊥ : Val [] []
  ⟨_⟩ : F as a → Val as [ a ] 
\end{minted}
        The data type \texttt{Val as bs} is indexed by two lists \texttt{as} and 
        \texttt{bs} that assume only certain values, depending on the presence
        of a node. This definition ensures that for any value \texttt{Val as bs}, 
        the lists \texttt{as} and \texttt{bs} always accurately approximate inputs 
        and outputs regardless of the presence of a node.
	Namely an empty value will consume no input and produce nothing, hence
        both lists are empty.
        A non-empty value contains a node \texttt{F as a} which consumes 
        objects of types \texttt{as} and produces a single object of type \texttt{a}.

	The set of edit operations considered includes a no-operation, node 
	deletion, insertion and update.
\begin{minted}{agda}
data _⟿_ : Val as bs → Val cs ds → Set where
  Nop : ⊥ ⟿ ⊥
  Del : (α : F as a) → ⟨ α ⟩ ⟿ ⊥
  Ins : (α : F as a) → ⊥ ⟿ ⟨ α ⟩
  Upd : (α : F as a) (β : F bs a) → ⟨ α ⟩ ⟿ ⟨ β ⟩
\end{minted}
	Edits are indexed by two values, called respectively 
	\emph{source} and \emph{target} values. The \texttt{Nop} edit is 
	a no-operation that is used exclusively to \emph{align} edit scripts,
	therefore it maps the empty value into itself.
	The edit \texttt{Del α} deletes the node \texttt{α} from the source object, 
	thus it is mapped to \texttt{⊥}. Conversely the edit \texttt{Ins α} 
	inserts node \texttt{α} in the target object and therefore its source value 
	is 	\texttt{⊥}.
	Lastly \texttt{Upd α β} denotes the update of source node \texttt{α}
	to target node \texttt{β}, which concretely represents a 
	constructor change. 
	Note that there is no explicit copy edit: it is just a special case 
	of update, in which the source and target nodes happen to be the same.
	Edits whose source and target values are identical are 
	called \emph{identity} edits. Copy and no-operation fall into this
	category.
	
	\subsection{Edit Script}
        \label{subsec:edit-script}
	An edit script collects a finite number of edit operations, 
	while preserving type-safety. 
\begin{minted}{agda}
data ES : List Set → List Set → Set where
  [] : ES [] []
  _::_ : {v : Val as bs} {w : Val cs ds} → v ⟿ w → 
          ES (as ++ xs) (cs ++ ys) → ES (bs ++ xs) (ds ++ ys)
\end{minted}	
	An edit script of type \texttt{ES xs ys} transforms
	a \emph{source} object of type \texttt{HList xs} into
	a \emph{target} object of type \texttt{HList ys}. 
        The indexes of the edit script are used as stacks by respectively the 
        \emph{source} and \emph{target} values of each edit contained in the script.
        This encoding is type-safe because the input list of the \emph{source} and 
        \emph{target} values are present on top of respectively the input and output 
        stack of the remaining script and their output lists are 
        found on top of the stacks of the resulting script.

        \paragraph{Example}
        The following edit script encodes the differences between \texttt{[1,2,3]} 
        and \texttt{[\textcolor{blue}{0},1,2,3]}, the first row of the tables 
        from the introduction:

\begin{Verbatim}[commandchars=\\\{\}]
e : ES [List Int] [List Int]
e = [\textcolor{blue}{Ins (::)} , \textcolor{blue}{Ins 0}, Upd (::) (::), Upd 1 1 ... Upd [] []]
\end{Verbatim}

	The following function retrieves the source object from an edit 
        script:			
\begin{minted}{agda}
⟪_⟫ : ES as bs → HList as
⟪ [] ⟫ = []
⟪ Nop ∷ e ⟫ = ⟪ e ⟫
⟪ Del α ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
⟪ Ins α ∷ e ⟫ = ⟪ e ⟫
⟪ Upd α β ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
\end{minted}
	No-operations and insert edits do not affect the source object,
	because their source value is empty, therefore in these cases the source 
	function is simply called recursively.
	On the other hand delete and update edits alter a node of the
	source object by either removing it or changing it.
	In these two cases such node is output as part of the source object.
	The source function is called recursively on the rest of the edit 
	script producing a list, whose prefix correspond to the subtrees of the
	top node. Using the function \texttt{hsplit} the list is decomposed 
	accordingly in two parts, which are then assembled appropriately.
	
	Dually we define a function that retrieves the target object.
	Since it is analogous to the previous we give only its signature:
	
\begin{minted}{agda}
⟦_⟧ : ES as bs → HList bs
\end{minted}

\subsection{Diff Algorithm}
\label{subsec:diff-algo}
The \texttt{diff} algorithm detects differences between
two objects and has the the following signature:
\begin{minted}{agda}
diff : HList as → HList bs → ES as bs
\end{minted}
Our model abstracts over the specific \texttt{diff} algorithm used:
the results proved are valid for a class of diffing algorithms that
satisfy some basic requirements.

\begin{req}[\texttt{diff} specifications]
  A \texttt{diff} algorithm is correct if and only if for any list
  \texttt{x} and \texttt{y}
  \center{\texttt{e = diff x y ⇔ ⟪ e ⟫ ≡ ∧ ⟦ e ⟧ ≡ y}}
\end{req}
%
This correctness criterion demands that the edit script computed by
\texttt{diff} transform exactly the source object \texttt{x} into the
target object \texttt{y}.  (In the specifications \texttt{≡} denotes
propositional equality.)
%
The advantage of reasoning by such specification is that we are not
bound to a particular \texttt{diff} algorithm when studying the
properties of \texttt{diff3}, so that arbitrary diffing techniques can
be used.
%
The following data type serves to this purpose: \texttt{Diff x y e} is
the proof that the edit script \texttt{e} is the result of diffing the
lists \texttt{x} and \texttt{y}.
\begin{minted}{agda}
data Diff : HList xs → HList ys → ES xs ys → Set where
  End : Diff [] [] []
  Nop : Diff x y e → Diff x y (Nop ∷ e)
  Del : Diff (x₁ +++ x₂) y e → Diff (Node α x₁ ∷ x₂ ) y (Del α ∷ e)
  Ins : Diff x (y₁ +++ y₂) e → Diff x (Node β y₁ ∷ y₂) (Ins β ∷ e)
  Upd : Diff (x₁ +++ x₂) (y₁ +++ y₂) e → 
        Diff (Node α x₁ ∷ x₂) (Node β y₁ ∷ y₂) (Upd α β ∷ e)
\end{minted}
        This specification  is a safe approximation of a \texttt{diff} algorithm,
        because for any edit script the two input lists do correspond to its
        source and target object.
\begin{minted}{agda}
Diff⇒ : (e : ES xs ys) → Diff ⟪ e ⟫ ⟦ e ⟧ e
\end{minted}
        Furthermore also the converse implication holds:
\begin{minted}{agda}
Diff⇐ : Diff x y e → x ≡ ⟪ e ⟫  ×  y ≡ ⟦ e ⟧
\end{minted}

	In our implementation the \texttt{diff} algorithm employed is a 
        generalization of that proposed by Lempsink et al.\ \cite{Lemp09},
        which will be discussed in section \ref{sec:related-work}.
        
        We remark that we have proved that it 
	complies with the \texttt{Diff} specification:
\begin{minted} {agda}
diff-suff :  (x : HList xs) (y : HList ys) → Diff x y (diff x y)
\end{minted}

\section{Generic diff$_3$}
	The \texttt{diff3} algorithm takes as input three objects, the original
	version called \emph{base} and two new replicas, and it outputs an
	edit script that combines the changes between them.
	However the algorithm does not work directly on the replicas, but relies
	on a \texttt{diff} algorithm to compute two edit scripts that describe
	the changes from base to each of the new versions.
	It then merges the edits contained in the two edit scripts and produce
	an edit script, whose \emph{source} is the base object and whose 
	\emph{target} is the merged object.
	Nevertheless not all edits can be automatically reconciled.
	In these cases a conflict is detected and reported to the user, who has
	to solve it manually.
		
	The merging technique employed in the \texttt{diff3} algorithm for
	algebraic data types consists in applying the three-way merge algorithm
	at the node level. 
	Informally the algorithm compares corresponding parts 
	of two objects and of their base version.
	When two parts disagree, the base version is examined:
	if all of them are different a conflict is detected, 
        otherwise the version that changed from base is chosen.
	
	To put this strategy on a formal footing we give precise definitions
	of corresponding parts and conflicts.
	On top of these we define a sound merging semantics.

	\subsection{Alignment}
        \label{subsec:alignment}
	We call two edit operations \emph{aligned} if they share the
        same \emph{source} value.
        %
        We naturally extend the notion of alignment to edit
        scripts.
        %
        Two edit scripts are \emph{aligned} if all their edits are
        pairwise aligned. The following data type denotes aligned edit
        scripts:
\begin{minted}{agda}
data _⋎_ : ES as bs → ES as cs → Set where
  nil : [] ⋎ []
  cons : (f : u ⟿ v) (g : u ⟿ w) → e₁ ⋎ e₂ → f ∷ e₁ ⋎ g ∷ e₂ 
\end{minted}
	The definition is recursive: two edit scripts are aligned if
        either they are both empty or their heads and their tails are
        both aligned.
        %
	Note that we do not need an auxiliary data type to encode edit
        alignment since this property can be enforced directly with
        their types.
        %
	For example the \texttt{cons} constructor accepts only aligned
        edits because it requires them to have the same source value
        \texttt{u}.
	
        Intuitively two edit scripts that have the same \emph{source}
        object can be aligned, because they share the same collection
        of \emph{source} nodes.
        %
        However insert edits might break alignment because they can
        occur at different point in the scripts.

        \paragraph{Example}
        Consider the list \texttt{x = [1]}, \texttt{y = [0,1]} and \texttt{z = [1,2]}.
        The edit script \texttt{e₁} and \texttt{e₂} represent the \texttt{diff} between \texttt{x} and
        respectively \texttt{y} and \texttt{z} \footnote{In this example \texttt{Cpy α} stands for \texttt{Upd α α}}.

\begin{minted}{agda}
e₁ e₂ : ES [ List Int ] [ List Int ]
e₁ = [Ins  (::), Ins  0, Cpy (::), Cpy 1, Cpy []]
e₂ = [Cpy (::), Cpy 1, Ins  (::), Ins  2, Cpy []] 
\end{minted}       

% \begin{minted}{agda}
% e₁ e₂ : ES [ List Int ] [ List Int ]
% e₁ = [Ins (::), Ins 1, Cpy (::), Cpy 1,                 Cpy []]
% e₂ = [                Cpy (::), Cpy 1, Ins (::), Ins 2, Cpy []] 
% \end{minted}       
        The two edits are not aligned because their first edits are not aligned, since \texttt{⊥ ≢ ⟨ :: ⟩}
        where \texttt{⊥} is the source value of \texttt{Ins (::)} in \texttt{e₁} and \texttt{⟨ :: ⟩} is
        the source value of \texttt{Cpy (::)} in \texttt{e₂}.

        Interestingly alignment can be recovered by inserting no-operation edits in 
        these points. 
\begin{minted}{agda}
e₁* = [Ins (::), Ins 0, Cpy (::), Cpy 1, Nop   , Nop , Cpy []]
e₂* = [Nop   , Nop , Cpy (::), Cpy 1, Ins (::), Ins 2, Cpy []] 
\end{minted}
        The relation \texttt{e ⊴ e*} denotes that the edit script
        \texttt{e*} extends \texttt{e} with a finite number of
        \texttt{Nop} edits.

        Note that the \texttt{Nop} edit change neither the
        \emph{source} nor the \emph{target} of the edit script,
        therefore it is an harmless extension.
        
\begin{prop}[Equivalent Extension]
Let \texttt{e} and \texttt{e*} be two edit scripts such that \texttt{e ⊴ e*}, then
\texttt{⟦ e ⟧ ≡ ⟦ e* ⟧} and \texttt{ ⟪ e ⟫ ≡ ⟪ e* ⟫}
\end{prop}

No-operations are automatically aligned with inserts because they both
share the empty value \texttt{⊥} as \emph{source} and furthermore they
may not introduce spurious conflicts because they are \emph{identity}
edits.
   
        \paragraph{Weak Alignment}
        Two edit scripts are \emph{weakly aligned} \texttt{e₁ \textasciitilde\ e₂} 
        if they admit extensions that are \emph{aligned}:
\begin{minted}{agda}
data _~_ (e₁ : ES xs ys) (e₂ : ES xs zs) : Set where
  WA : e₁ ⊴ e₁* → e₂ ⊴ e₂* → e₁* ⋎ e₂* → e₁ ~ e₂
\end{minted}

        We can now weakly align two edit scripts, that share the
        same \emph{source} object. The alignment procedure examines the scripts
        and extend either of them with no-operations, whenever one inserts a 
        node and the other does not. 
\begin{minted}{agda}
align : Diff x y e₁ → Diff x z e₂ → e₁ ~ e₂
\end{minted}

	\subsection{Merge Semantics}
        \label{subsec:merge-semantics}
	Our merge semantics is defined over aligned edits.
	Two aligned edits contain at most three distinct values: 
	one common source and two, 	possibly different, targets, which 
	are treated as corresponding parts.
	A merge can either fail raising a conflict or succeed producing
	an edit that combines both.
	
	\paragraph{Merge}
	The data type \texttt{f ⊔ g ↧ h} is the proof that merging the 
	aligned edits \texttt{f} and \texttt{g} succeeds producing the edit \texttt{h}.
	
\begin{minted} {agda}
data _⊔_↧_ : (v ⟿ a) → (v ⟿ b) → (v ⟿ c) → Set where
  Id₁ : (f : v ⟿ v) (g : v ⟿ w) → f ⊔ g ↧ g
  Id₂ : (f : v ⟿ w) (g : v ⟿ v) → f ⊔ g ↧ f
  Idem : (f : v ⟿ w) → f ⊔ f ↧ f
\end{minted}

	Observe that the type of the two input edits guarantees their
        alignment.
        %
        Furthermore determines only the \emph{target} value, hence the
        third merged edit retain the the same source value \texttt{v}.

	Each constructor represents a distinct axiom that justifies why
	the merge is possible and determines the merged edit.
	The rules \texttt{Id₁} and \texttt{Id₂} apply when 
	respectively the first and the second transformation is an \emph{identity} 
        edit.
	Similarly to the three-way merge algorithm, when one version is unchanged the other
        is chosen.
	The fact that merging is an \emph{idempotent} operation motivates the 
	third rule \texttt{Idem}.
	It applies when the same edit is performed independently in both versions.
	
	Note that this definition is particularly effective because it is 
	minimal and concise, as it does not mention specific
	edits, yet it is complete, because it can encode all the true concrete 
        merges.	

	\paragraph{Conflict}
	A conflict occurs when two edits perform irreconcilable changes.
	The following data type represents the possible conflicts that may arise
	from aligned edits.
	
\begin{minted}{agda}
data Conflict : Val as bs → Val cs ds → Val es fs → Set where
  DelUpd : (α : F as a) (β : F bs a) → Conflict ⟨ α ⟩ ⊥ ⟨ β ⟩
  UpdDel : (α : F as a) (β : F bs a) → Conflict ⟨ α ⟩ ⟨ β ⟩ ⊥ 
  InsIns : (α : F as a) (β : F bs b) → Conflict ⊥ ⟨ α ⟩ ⟨ β ⟩
  UpdUpd : (α : F as a) (β : F bs a) (γ : F cs a) →
             Conflict ⟨ α ⟩ ⟨ β ⟩ ⟨ γ ⟩    
\end{minted}

	In the type \texttt{Conflict u v w} the index \texttt{u} is
        the common source value, while indexes \texttt{v} and
        \texttt{w} are the target values of the edits.
        %
        Conflicts given by \texttt{InsIns} and \texttt{UpdUpd}
        represent conflicting insertions and updates, similar
        to those detected by line-based \texttt{diff3}, which
        encodes proper updates as a deletion followed by an insertion.
        %
        Those given by \texttt{UpdDel} and \texttt{DelUpd} are
        entirely new and stem from the fact that these two edits are
        in general irreconcilable.

	The data type \texttt{f ⊔ g ↥ c} denotes that the edits
        \texttt{f} and \texttt{g} cannot be merged and raise conflict
        \texttt{c}.

\begin{minted}{agda}
data _⊔_↥_ : (u ⟿ v) → (u ⟿ w) → Conflict u v w → Set where
  Cnf : (f : u ⟿ v) (g : u ⟿ w) → u ≢ v → v ≢ w  → u ≢ w → 
        (c : Conflict u v w) → f ⊔ g ↥ c
\end{minted}

	The three inequalities guarantee that all the values involved are different
        and ensure that the edits are actually incompatible and may not be merged 
        otherwise. For example if \texttt{u ≡ v} the first edit would be an
        \emph{identity} edit, which can always be merged by
        \texttt{Id₁}. Similarly if \texttt{u ≡ w} the second edit could be merged
        by \texttt{Id₂}. Lastly if \texttt{v ≡ w} the edits \texttt{f} and \texttt{g}
        would perform the same change and could be merged applying the \texttt{Idem}
        rule.
        Given these inequalities the corresponding conflict is uniquely determined,
        i.e. for any concrete choice of \texttt{u}, \texttt{v} and \texttt{w} that
        are all different, there is only a single conflict \texttt{c} that applies.
	As a result also the semantics of conflict is minimal, but still complete
        because it can encode all the true conflicts.

	\paragraph{Merge Operator}
	The binary operator \texttt{⊔} merges 
	two aligned edits. For every pair of edits \texttt{f} and \texttt{g}, 
	it either finds a suitable edit \texttt{h} and provide
	a proof that \texttt{f ⊔ g ↧ h}, or detects a conflict \texttt{c}, 
	with a proof that \texttt{f ⊔ g ↥ c}.

\begin{minted}{agda}
_⊔_ : (f : u ⟿ v) (g : u ⟿ w) →
        (∃ λ c → f ⊔ g ↥ c) ⊎ (∃ λ h → f ⊔ g ↧ h)
\end{minted}
	This operator is outlined in table \ref{table:merge}, where we have
        omitted the obvious inequalities in conflicts.

	\begin{table*}[t]
	\centering
	\begin{tabular}{| c | c | c |}
	\hline
	\texttt{f : u \textasciitilde> v} & \texttt{g : u \textasciitilde> w} &  \texttt{f ⊔ g} 
	\\ \hline
	\texttt{Nop} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ Nop g}} 
	\\ \hline
	\texttt{Upd α α} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ (Upd α α) g}} 
	\\ \hline
	\texttt{f} & \texttt{Nop} & \textcolor{Green}{\texttt{Id₂ f Nop}} 
	\\ \hline
	\texttt{f} & \texttt{Upd α α} & \textcolor{Green}{\texttt{Id₂ f (Upd α α)}} 
	\\ \hline
	\texttt{Del α} & \texttt{Del α} & \textcolor{Green}{\texttt{Idem (Del α)}}
	\\ \hline
	\texttt{Del α} & \texttt{Upd α β} & \textcolor{Red}{\texttt{Cnf (Del α) (Upd α β) (DelUpd α β) }}
	\\ \hline
	\texttt{Upd α β} & \texttt{Del α} & \textcolor{Red}{\texttt{Cnf (Upd α β) (Del α) (UpdDel α β)}}
	\\ \hline
	\texttt{Ins α} & \texttt{Ins α} & \textcolor{Green}{\texttt{Idem (Ins α)}} 
	\\	\hline
	\texttt{Ins α} & \texttt{Ins β} & \textcolor{Red}{\texttt{Cnf (Ins α) (Ins β) (InsIns α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α β} & \textcolor{Green}{\texttt{Idem (Upd α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α γ} & \textcolor{Red}{\texttt{Cnf (Upd α β) (Upd α γ) (UpdUpd α β γ)}}
	\\ \hline
	\end{tabular}
	
	\captionsetup{singlelinecheck=false, justification=centering}

	\caption{Implementation of merge operator. \\
	 \texttt{f ⊔ g :} \textcolor{Red}{\texttt{f ⊔ g ↥ c}} \texttt{⊎} \textcolor{Green}{\texttt{f ⊔ g ↧ h}}}	 
	\label{table:merge}
	\end{table*}

	\paragraph{Merged Edit Script}
	Just like we defined a merge operator for aligned edits, we need to 
	define a similar operator for aligned edit scripts.
	However since single merges may fail this operator cannot return 
	the same well-typed edit script, that we have defined before.
	Therefore we introduce an alternative edit script, which is only partially 
	well-typed and that can include conflicts.
\begin{minted}{agda}
data ES₃ : List Set → Set where
  [] : ES₃ []
  _∷_ : {u : Val as bs} → u ⟿ v → ES₃ (as ++ xs) → ES₃ (bs ++ xs)
  _∷ᶜ_ : {u : Val as bs} → (c : Conflict u v w) → 
             ES₃ (as ++ xs) → ES₃ (bs ++ xs)
\end{minted}
	The data type is indexed only by the source type list and it is well-typed
	only with respect to it. Furthermore it provides an additional constructor
	for conflicts. 

        \subsection{Diff₃ Algorithm}
        \label{subsec:diff3-algo}

	The merge operator for edit scripts takes two aligned edit scripts and
	applies the merge operator \texttt{⊔} previously defined to
	each pair of aligned edits. It builds a merged edit script choosing a 
	suitable constructor depending on the outcome of each single merge.

\begin{minted}{agda}
merge₃ : {e₁ : ES as bs} {e₂ : ES as cs} → e₁ ⋎ e₂ → ES₃ as
merge₃ nil = []
merge₃ (cons f g p) with f ⊔ g
merge₃ (cons f g p) | inj₁ (c , _) = c ∷ᶜ merge₃ p
merge₃ (cons f g p) | inj₂ (h , _) = h ∷  merge₃ p
\end{minted}
	To improve readability we will use the following infix
        operator:
\begin{minted}{agda}
_⊔₃_ (e₁ : ES as bs) (e₂ : ES as cs) {{p : e₁ ⋎ e₂}} → ES₃ as
_⊔₃_  _ _ {{p}} = merge₃ p
\end{minted}
	The alignment proof is passed  as an instance argument, i.e. a
        special  type  of  implicit arguments  that  is  automatically
        resolved at call-sites \cite{Devriese11}.

        In order to reason about merging we encode the specifications
        of the merge operator in the \texttt{Merge₃} data type, shown
        in Fig \ref{fig:merge3}.

\begin{figure*}[t!]
\centering
\begin{minted}{agda}
data Merge₃ : ES xs ys → Es xs zs → ES₃ xs → Set where
  nil : Merge₃ [] [] []
  merge : f ⊔ g ↧ h → Merge₃ e₁ e₂ e₃ → Merge₃ (f ∷ e₁) (g ∷ e₂) (h ∷ e₃)
  conflict : f ⊔ g ↥ c → Merge₃ e₁ e₂ e₃ → Merge₃ (f ∷ e₁) (g ∷ e₂) (c ∷ᶜ e₃)
\end{minted}
\caption{Merge operator specification}
\label{fig:merge3}
\end{figure*}

        We then show that our merge operator satisify its requirements:
\begin{minted}{agda}
Merge⇒ : e₁ ⋎ e₂ → Merge₃ e₁ e₂ (e₁ ⊔₃ e₂)
\end{minted}
        The proof follows by induction on \texttt{e₁ ⋎ e₂}. Since the opposite
        proposition also holds, this data type fully describes the merge operator:
\begin{minted}{agda}
Merge⇐ : Merge₃ e₁ e₂ e₃ → e₃ ≡ e₁ ⊔₃ e₂
\end{minted}
        The proof is also by induction and requires three important
        properties of the merging and conflict semantics.
        %
        Firstly they must be mutually exlusive, i.e.\ given two
        aligned edits \texttt{f} and \texttt{g} either they can be
        merged by some edit (\texttt{f ⊔ g ↧ h}), or they trigger some
        conflict (\texttt{f ⊔ g ↥ c}). Secondly these relations must
        be deterministic, i.e.\ the third index is uniquely determined
        by the first two.
        %
        
        Now that we have shown that the merge operator is in a
        one-to-one relationship with the specification data type, we
        will use the latter to reason more conveniently about its
        properties.

	\paragraph{Diff3}
	We finally give a generic \texttt{diff₃} algorithm for
        heterogeneous lists.
        %
        We follow the conventional interface, in which the second
        argument is considered \emph{base}:
\begin{minted}{agda}
diff₃ : HList ys → HList xs → HList zs → ES₃ xs
diff₃ y x z with align (diff-suff x y) (diff-suff x z)
diff₃ y x z | WA _ _ p = merge₃ p
\end{minted}
	
	The \texttt{diff} algorithm is called implicitly by
        \texttt{diff-suf}; the edit scripts so obtained are aligned
        via extension using \texttt{align}, from which the alignment
        proof \texttt{p} is extracted and used to finally merge the
        scripts with \texttt{merge₃}.  Note that the call to
        \texttt{align} is valid because \texttt{diff-suff} is invoked
        with the same \texttt{x} as first argument.

        \paragraph{Type Checking}
	Even though merging might succeed without triggering any
        conflict the merged edit script might be invalid, i.e.\ it will
        not produce a well-typed object as \emph{target}.
        %
        The reason is that the merge operator \texttt{⊔₃} merges edits
        \emph{pointwise}, therefore the script obtained by joining two
        well-typed edit script may not be well-typed.  Consider for
        instance the following edit scripts:
\begin{minted}{agda}
e₁ e₂ : ES [] [List Int]
e₁ = [Ins [], Nop]
e₂ = [Nop, Ins []]
\end{minted}
        Merging the two edits with \texttt{e₁ ⊔₃ e₂} yields a conflict
        free, yet ill-typed edit script:
\begin{minted}{agda}
e₃ : ES₃ []
e₃ = [Ins [], Ins []]
\end{minted}
        The problem is that the first insert produces a constructor
        that does not take any arguments, yet the tail of the script
        yields another empty list as argument.
        
        The merged edit script must be type-checked to ensure that it
        actually produces a well-typed merged \emph{target} object.
        %
	The typing judgment \texttt{e ⇓ as} states that the edit
        script \texttt{e} is well typed and produces a list of type
        \texttt{HList as}.  The typing rules are straightforward:
	
	\begin{center}	
		\mbox{	
				\AxiomC{}
				\UnaryInfC{\texttt{[] ⇓ []}}			
				\DisplayProof
		}
		\mbox{
				\AxiomC{\texttt{f : v \textasciitilde> w}}
				\AxiomC{\texttt{w : F cs ds}}
				\AxiomC{\texttt{e ⇓ cs ++ ys}}
				\TrinaryInfC{\texttt{f ∷ e ⇓ (ds ++ ys)}}
				\DisplayProof
		}
	\end{center}
	
	A trivial inference algorithm can be easily deduced from the typing rules.
	Moreover note that the conflict cons constructor (\texttt{∷ᶜ}) is not 
	mentioned in the typing rules, therefore edit scripts containing
	conflicts are ill-typed.		
	Edit scripts of type \texttt{ES₃} can be converted to \texttt{ES}, if they
	are well typed:
\begin{minted}{agda}
⌜_⌝  : (e : ES₃ xs) → {{q : e ⇓ ys}} → ES xs ys
\end{minted}

% I don't think that it is very useful to introduce this.
%         Some of the properties we will present apply only to \emph{successful} 
%         merges, i.e.\ those that did not trigger any conflict and that are 
%         well-typed. When necessary we will use the following data type to restrict
%         to those cases.

% \todo{Better name? I don't have good alternatives SMerge₃ , WT-Merge₃}
% \begin{minted}{agda}
% data Merged₃ : ES xs ys → ES xs zs → ES xs ws → Set where  
%   nil : Merged₃ [] [] []
%   cons : f ⊔ g ↧ h → Merged₃ e₁ e₂ e₃ → Merged₃ (f ∷ e₁) (g ∷ e₂) (h ∷ e₃)
% \end{minted}
%         Note that the third index is a well-typed edit script.
%         The following lemma ties the connection between \texttt{Merge₃} and 
%         \texttt{Merged₃}:
% \begin{minted}{agda}
%          Merge₃ e₁ e₂ e₃  ,  e₃ ⇓ ws   ⇒   Merged₃ e₁ e₂ ⌜ e₃ ⌝
% \end{minted}

\section{Properties}
\label{sec:properties}
In this section we present several properties of our merge algorithm,
all of which have been verified in Agda using the model presented in
this paper.  
%
In the following we will write \texttt{f ∈ e} to denote that edit
\texttt{f} occurs in script \texttt{e}.
%
Furthermore We generalize membership to conflicts \texttt{c ∈ e} and
to nodes in heterogeneous lists \texttt{α ∈ hs}.
  
    \subsection{Conflict}  
    In order to reason about complex merge operations we have studied
    what are the minimal conditions that will trigger a conflict.
    %
    Merging two scripts will result in a conflict if they contain at
    least a pair of aligned edits that may not be merged.  
    %
    The type \texttt{e₁ ⊔₃ e₂ ↥ c} denotes that aligned edit scripts
    \texttt{e₁} and \texttt{e₂} will raise conflict \texttt{c} if
    merged and precisely captures these circumstances.

\begin{minted}{agda}
data _⊔₃_↥_ : ES xs ys -> ES xs zs -> Conflict u v w -> Set where
  here :  f ⊔ g ↥ c -> (f ∷ e₁) ⊔₃ (g ∷ e₂) ↥ c
  there : e₁ ⊔₃ e₂ ↥ c -> (f ∷ e₁) ⊔₃ (g ∷ e₂) ↥ c
\end{minted}

    % In order to show that these are truly the minimal conditions to get a conflict,
    % we define a data type that denotes that a merged edit script contains a 
    % conflict. 

% \begin{minted}{agda}
% data _∈ᶜ_ (c : Conflict u v w) : ES₃ xs -> Set where
%   here : c ∈ᶜ (c ∷ᶜ e)
%   there : c ∈ᶜ e -> c ∈ᶜ f ∷ e
%   thereᶜ : c ∈ᶜ e -> c ∈ᶜ (c' ∷ᶜ e)
% \end{minted}

    The following theorem shows that a conflict occurs in a merged script
    if and only if there are two aligned conflicting edits in the input scripts.
    
\begin{thm}[Conflict Conditions]
  Let \texttt{e₁} and \texttt{e₂} be two aligned edit scripts
  and let \texttt{e₃ = e₁ ⊔₃ e₂}, then \texttt{c ∈ e₃} if and only if
  \texttt{e₁ ⊔₃ e₂ ↥ c}.
\end{thm}

    % the presence of a conflict in a merged
    % edit script can be explained by the condition \texttt{e₁ ⊔₃ e₂ ↥ c}, i.e.\
    % that \texttt{e₁} and \texttt{e₂} contain two conflicting edits.


% \begin{minted}{agda}
%     Merge₃ e₁ e₂ e₃    ∧    c ∈ᶜ e₃    ⇒    e₁ , e₂ ↥ c
% \end{minted}
%     The proof follows immediately by induction.
%     Conversely we show that \texttt{e₁ , e₂ ↥ c} implies the presence
%     of a conflict in their merged edit script.
% \begin{minted}{agda}
%     Merge₃ e₁ e₂ e₃    ∧    e₁ , e₂ ↥ c     ⇒    c ∈ᶜ e₃
% \end{minted}
%     The proof also follow from induction. Note that we can discharge the paradoxical
%     base case in which the same edits are merged (\texttt{f ⊔ g ↧ h}) in 
%     \texttt{Merge₃ e₁ e₂ e₃} and not (\texttt{f ⊔ g ↥ c}) in \texttt{e₁ , e₂ ↥ c},
%     because these two cases are mutually exclusive.    

    \subsection{Safety}
    The safety properties discussed in this section act as a sanity
    check, ensuring that \texttt{diff} and \texttt{diff3} behave
    properly.
    %
    Firstly, we show \emph{data origin}, which ensures that every source
    and target node found in an edit script belong respectively to the
    source and target object diffed.  
    %
    Secondly, we show the converse property \emph{data retention}, which 
    guarantees that every node found in source and target object is
    processed in the diff and mapped in the edit script.
    %
    We start with some auxiliary definitions and lemmas.
    % Firstly we give some auxiliary definitions that will be used to state and prove
    % this properties.
%     \paragraph{Membership}
%     The type \texttt{α ∈ hs} denotes that the node \texttt{α} is present
%     in the list of trees \texttt{hs}.

% \begin{minted}{agda}
% data _∈_ : F xs a → HList ys → Set where
%   here : (α : F as a) → α ∈ Node α hs₁ ∷ hs₂
%   there : α ∈ (hs₁ +++ hs₂) → α ∈ Node β hs₁ ∷ hs₂
% \end{minted}

%     A similar data type denotes the presence of an edit in a script.

% \begin{minted}{agda}
% data _∈ₑ_ : v ⟿ w → ES xs ys → Set where
%   here : (f : v ⟿ w) → f ∈ₑ f ∷ e
%   there : f ∈ₑ e → f ∈ₑ g ∷ e
% \end{minted}

    % Lastly the judgment \texttt{e ⊢ₑ u ⟿ v} denotes that
    % the script \texttt{e} contains some edit of type \texttt{u ⟿ v}.
\begin{definition}[Edit Mapping]
An edit script \texttt{e} maps source value \texttt{u} into
target value \texttt{v}, written \texttt{e ⊢ u ⟿ v}, if and
only if there is an edit \texttt{f : u ⟿ v} such that \texttt{f ∈ e}.
\end{definition}

% I think I will skip this one and directly state the more interesting one
% \begin{minted}{agda}
%    ∀   f : ⟨ α ⟩ ⟿ v  .  f ∈ₑ e   ⇒   α ∈ ⟪ e ⟫
%    ∀   f : v ⟿ ⟨ α ⟩  .  f ∈ₑ e   ⇒   α ∈ ⟦ e ⟧
% \end{minted}

The following property shows that in an edit script a source (target)
node is correctly part of the source (target) object.
%
In other words the source function \texttt{⟪\_⟫} and target function
\texttt{⟦\_⟧} do not forget any node.
\begin{prop}[Source and Target Composition]
\label{prop:source-target-cmp}
Given an edit script \texttt{e} and a node \texttt{α} then.
If \texttt{e ⊢ₑ ⟨ α ⟩ ⟿ v} then \texttt{α ∈ ⟪ e ⟫}.
Similarly if \texttt{e ⊢ₑ v ⟿ ⟨ α ⟩} then \texttt{α ∈ ⟦ e ⟧}.
\end{prop}

We now formally state the \emph{data origin} property.
\todo{Here I am assuming a diff that satisfies our specification. Is it clear?}
\begin{cor}[Data Origin]
Let \texttt{x} and \texttt{y} be two heterogeneous lists, let \texttt{e = diff x y}
and let \texttt{α} be a node.
If \texttt{e ⊢ₑ ⟨ α ⟩ ⟿ v} then \texttt{α ∈ x}. Similarly if \texttt{e ⊢ₑ v ⟿ ⟨ α ⟩}
then \texttt{α ∈ y}.
\end{cor}    
\begin{proof}
  It follows directly from the specification of \texttt{diff}
  (\texttt{Diff⇐} and \texttt{Diff⇒}) and Proposition \ref{prop:source-target-cmp}.
\end{proof}

We now formally state the \emph{data retention} property.
\begin{prop}[Data Retention]
\label{prop:data-retention}
  Let \texttt{x} and \texttt{y} be two heterogeneous lists, let
  \texttt{e = diff x y} and let \texttt{α} be a node.
%
  If \texttt{α ∈ x} then there is a target value \texttt{v} such that
  \texttt{e ⊢ₑ ⟨ α ⟩ ⟿ v}.
%
  Similarly if \texttt{α ∈ y} then there is a source value \texttt{v} such that
  \texttt{e ⊢ₑ v ⟿ ⟨ α ⟩}.
\end{prop}
\begin{proof}
  It follows from the specifications of \texttt{diff} (\texttt{Diff⇐}
  and \texttt{Diff⇒}) and by induction on \texttt{α ∈ x}.
\end{proof}
 
  We give now similar safety properties for our \texttt{diff₃} algorithm.
  We firstly discuss \emph{edit origin}, a generalization of \emph{data origin}
  that ensures that every edit present in the merged script comes from either 
  of the input scripts. We then conclude with  \emph{persistence}, an important 
  theorem that guarantees that no changes of either version are ignored when
  the scripts are merged.

\begin{prop}[Edit Origin]
Let \texttt{e₁}, \texttt{e₂}, \texttt{e₃} be scripts such that
\texttt{e₁ ⋎ e₂} and \texttt{e₃ = e₁ ⊔₃ e₂}. Let \texttt{f} be an edit.
If \texttt{f ∈ e₃} then either \texttt{f ∈ e₁} or \texttt{f ∈ e₂}.
\end{prop}
\begin{proof}
  It follows directly from the specifications of \texttt{⊔₃}
  (\texttt{Merge⇒}) and by induction.
\end{proof}

  We now formally state and prove that our merge algorithm is \emph{persistent}.
  This property is very important because conflicts are triggered by changes,
  hence a non-persistent algorithm could back-out changes to avoid raising
  conflicts.

    % \paragraph{Persistence}
    % The converse property asserts that an edit present in one of the input
    % edit scripts will be found in the merged edit script, given that it does
    % perform a change and that the output script does not contain conflicts.
    % The first hypothesis is needed because identity edits can be silently 
    % ignored in the merge semantics by either \texttt{Id₁} or
    % \texttt{Id₂}.
    % On the other hand the second prerequisite is essential, because 
    % our algorithm is \emph{persistent}, i.e.\ it refuses to back out changes 
    % made by incompatible edits, but triggers an appropriate conflict instead.

    % Firstly an edit does perform a change if it is not an identity edit, or, in 
    % other words if the source and the target values are different.
				
\begin{thm}[Persistence]
Let \texttt{e₁}, \texttt{e₂}, \texttt{e₃} be scripts such that
\texttt{e₁ ⋎ e₂} and \texttt{e₃ = e₁ ⊔₃ e₂}. Let \texttt{f} be an edit
of type \texttt{u ⟿ v} such that \texttt{u ≢ v} and \texttt{f ∈ e₁}.
Then either \texttt{f ∈ e₃} or there is a conflict \texttt{c} such that
\texttt{e₁ ⊔₃ e₂ ↑ c}.
\end{thm}
\begin{proof}
    The proof is by induction on \texttt{Merge₃ e₁ e₂ e₃} (from
    \texttt{Merge⇒}) and \texttt{f ∈ₑ e₁}.  In the base case edit
    \texttt{f} is merged with some other edit \texttt{g}, then either
    \texttt{f ⊔ g ↥ c} or \texttt{f ⊔ g ↧ h}.
    %
    In the former case we are done because \texttt{f} raises a
    conflict.  In the latter case we proceed by case analysis on
    \texttt{f ⊔ g ↧ h}.
    %
    The merged edit \texttt{h} is either \texttt{f} (case \texttt{Id₂}
    or \texttt{Idem}), or \texttt{g} (\texttt{Id₁}). In the first case
    we are done, because \texttt{f} occurs in the merged script.
    %
    The second case is contradictory because we assumed \texttt{u ≢
      v}.
\end{proof}        

    The theorem holds also when the edit belongs to the other script and
    the proof is entirely symmetrical.
   		
    \subsection{Maximality}
    Another interesting property of our merge algorithm is
    \emph{maximality}, which guarantees that whenever it is possible
    to reconcile two edits from the input scripts, then the merged
    edit must be included in the merged script.
    %
    Theorem \ref{thm:max} shows that every successful merge is
    \emph{maximal}.

    \paragraph{Example} 
    Consider scripts \texttt{e₁*} and \texttt{e₂*} from section
    \ref{subsec:alignment}.
    %
    The merged edit \texttt{e₁* ⊔₃ e₂* = [Ins (::), Ins 0, Cpy (::),
      Cpy 1, Ins (::), Ins 2 , Cpy []]}, is maximal because it
    contains all the edits obtained by merging them pairwise.
    %
    \begin{thm}[Maximality]
      \label{thm:max}
      Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts
      such that \texttt{e₁ ⋎ e₂}, \texttt{e₃ = e₁ ⊔₃ e₂} and
      \texttt{e₃} does not contain any conflict. Then \texttt{e₃} is
      maximal with respect to \texttt{e₁} and \texttt{e₂}.
    \end{thm}

    \subsection{Structural  Invariants}
    An edit script describes how to transform the source object into
    the target object, by traversing it in \emph{depth-first order}
    and mapping source nodes into target nodes.
    %
    Interestingly the embedding preserves the depth-first order: if a
    source node comes before another then the mapping of the first
    will come before the mapping of the second.    
    %
    However nodes are not only mapped (updated) from the source to the
    target, but they may also be inserted and removed, therefore the
    structural invariant must be adjusted to take these edits into
    account.
    %
    Intuitively the order is preserved because nodes that 
    are mapped first in a script precede those that are mapped later.
    %
    We start by generalizing depth-first ordering to list of trees and
    giving a basic ordering to edits in a script.
    %
    % The structural invariant property relies on 
    % by showing how the former implies the latter we deduce
    % the structural invariant.
    

    \paragraph{Depth-First Order}
    A pre-order depth-first traversal consists of firstly visiting the current node 
    and then traversing recursively its subtrees from the leftmost to the rightmost.
    The traversal induces an ordering on the nodes, so that those that
    are visited sooner come before those that are processed later.
    Since edit scripts work with list of trees, we have not to generalize the order accordingly.
    
    The type \texttt{hs ⊢ α ⊏ β} denotes that, in the list of trees \texttt{hs}, 
    the node \texttt{α} comes before the node \texttt{β}, according to the
    depth first traversal.

\begin{minted}{agda}
data _⊢_⊏_ : Hist xs → F as a → F bs b → Set where
  here : β ∈ (hs₁ +++ hs₂) → Node α hs₁ ∷ hs₂ ⊢ α ⊏ β
  there : (hs₁ +++ hs₂) ⊢ α ⊏ β → Node γ hs₁ ∷ hs₂ ⊢ α ⊏ β
\end{minted}

    Intuitively the list is used as a stack, so that after visiting
    each node its children, yet to be traversed, are pushed on the stuck.
    Note that those trees will be visited before those already on the stuck,
    hence following correctly the depth-first traversal.

    \paragraph{Edit Order}
    Since edit scripts are a flat list-like data structure, we simply
    order edits according to their position in the script.

\begin{definition}[Edit Order]
Given an edit script \texttt{e} and two edits \texttt{f} and \texttt{g}, we write
\texttt{e ⊢ₑ f ⊏ g} if and only if \texttt{f} precedes \texttt{g} in \texttt{e}.
\end{definition}

\paragraph{Order Invariant}
Before stating the main theorem relies on two fundamental properties:
that the target (source) function and \texttt{diff} are
\emph{order-preserving} (OP).
%
Property \ref{prop:order-preserving-target-fun} guarantees that the
relative order of edits in a script corresponds to the depth-first
order of their target (source) nodes in the target (source) objects.
%
Property \ref{prop:order-preserving-embedding} ensures that if in the
target (source) object a node precedes another, then in the diff
script the first node is produced by an edit that comes before the
edit that produces the second.

\begin{prop}[\texttt{⟦\_⟧} is OP]
\label{prop:order-preserving-target-fun}
Let \texttt{e} be an edit script and \texttt{f} and \texttt{g} edits
of type \texttt{v ⟿ ⟨ α ⟩} and \texttt{w ⟿ ⟨ β ⟩}, such that
\texttt{e ⊢ f ⊏ g}, then \texttt{⟦ e ⟧ ⊢ α ⊏ β}.
\end{prop}
  We omit the symmetrical property for \emph{source} nodes and objects.

\begin{prop}[Embedding is OP]
\label{prop:order-preserving-embedding}
Let \texttt{x} and \texttt{y} be heterogeneous lists and let 
\texttt{e} be an edit script such that \texttt{e = diff x y}.
Let also \texttt{α} and \texttt{β} be nodes such that \texttt{y ⊢ α ⊏ β}.
Then there are edits \texttt{f : u ⟿ ⟨ α ⟩} and \texttt{g : v ⟿ ⟨ β ⟩}
such that \texttt{e ⊢ f ⊏ g}.
\end{prop}
\begin{proof}
  The proof relies on the specification of \texttt{diff} (Diff⇒).
  By induction on \texttt{y ⊢ α ⊏ β} we locate \texttt{f : u ⟿ ⟨ α ⟩}
  in \texttt{e}. By Proposition \ref{prop:data-retention} it follows that
  there exists \texttt{g : v ⟿ ⟨ β ⟩} in the tail of \texttt{e}.
\end{proof}
We again omit the corresponding property for \emph{source} nodes and object.

    % We now have all the lemmas to prove the \emph{order invariant}
    % theorem, which ensures that the edit script data type preserves
    % the depth-first order of the source (target) objects.
    %
We now prove our main theorem, which ensures that
\texttt{diff} preserves the relative order of nodes in the
source (target) objects.
%
Since nodes may also be deleted the property sees also these cases,
namely if node \texttt{α} precedes \texttt{β} in the source object of
script \texttt{e}, then one of the following holds:
    \begin{itemize}
    \item Node \texttt{α} is deleted in \texttt{e};
    \item Node \texttt{β} is deleted in \texttt{e};
    \item Node \texttt{α} is mapped to some node \texttt{γ} and node
      \texttt{β} is mapped to some node \texttt{φ}, such that node
      \texttt{γ} comes before node \texttt{φ} in the target object.
    \end{itemize}
%
    We show only the theorem about the \emph{source} object, because
    the other is symmetrical.
\begin{thm}[\texttt{diff} is OP]
  Let \texttt{x} and \texttt{y} be heterogeneous lists and \texttt{e}
  an edit script, such that \texttt{e = diff x y}. Let also \texttt{α}
  and \texttt{β} be nodes such that \texttt{x ⊢ α ⊏ β} then either
  \texttt{e ⊢ ⟨ α ⟩ ⟿ ⊥} or \texttt{e ⊢ ⟨ β ⟩ ⟿ ⊥} or there exists nodes
  \texttt{γ} and \texttt{φ} such that \texttt{e ⊢ ⟨ α ⟩ ⟿ ⟨ γ ⟩},
  \texttt{e ⊢ ⟨ β ⟩ ⟿ ⟨ φ ⟩} and \texttt{y ⊢ γ ⊏ φ}.
\end{thm}
\begin{proof}
  By Proposition \ref{prop:order-preserving-embedding} there are edits
  \texttt{f : ⟨ α ⟩ ⟿ u} and \texttt{g : ⟨ β ⟩ ⟿ v}, such that
  \texttt{e ⊢ f ⊏ g}.
  %
  By case analysis either \texttt{u = ⊥} or \texttt{v = ⊥} or \texttt{u = ⟨ γ ⟩}
  and \texttt{v = ⟨ Φ ⟩}. In the first (second) case \texttt{α} (\texttt{β}) is deleted and we are done.
  In the third case they are both updated, i.e.\ \texttt{e ⊢ ⟨ α ⟩ ⟿ ⟨ γ ⟩} and
  \texttt{e ⊢ ⟨ β ⟩ ⟿ ⟨ φ ⟩}.
  %
  By Proposition \ref{prop:order-preserving-target-fun} we deduce that
  \texttt{⟦ e ⟧ ⊢ γ ⊏ Φ} and by the specification of \texttt{diff}
  (\texttt{Diff⇐}) it follows that \texttt{y ⊢ γ ⊏ Φ}.
\end{proof}

We now generalize the \emph{order invariant} property to
\texttt{diff₃}, which guarantees that the relative order of edits in
each input script is preserved in the merged script.
%
Note that the property is restricted only to successful merges and
furthermore only to \emph{non-identity} edits, since they could 
ne be excluded in favor of proper changing edits otherwise.
%
The property holds intuitively because the merge algorithm does not
rearrange the input edits, but rather merge them pointwise, retaining
the original order in the merged script.
%
\begin{thm}[\texttt{diff₃} is OP]
  Let \texttt{e₁}, \texttt{e₂} and \texttt{e₃} be edit scripts such
  that \texttt{e₁ ⋎ e₂}, \texttt{e₃ = e₁ ⊔₃ e₂} and \texttt{e₃} does not
  contain conflicts.
%
  Let \texttt{f} and \texttt{g} be edits of type \texttt{u ⟿ v} and
  \texttt{w ⟿ z} such that \texttt{u ≢ v}, \texttt{w ≢ z} and
  \texttt{e₁ ⊢ f ⊏ g}, then \texttt{e₃ ⊢ₑ f ⊏ g}.
\end{thm}
  The theorem holds also with respect to the edits contained in \texttt{e₂}.

\section{Discussion and Related Work}
\label{sec:related-work}

\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}

\listoftodos

\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices


%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex -shell-escape
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End: 

