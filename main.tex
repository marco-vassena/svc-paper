
%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}

\usepackage{minted} % Code listing with reasonable good highlighting
\usepackage{bussproofs}   % For typing judgments
\usepackage[no-math]{fontspec}
\setmonofont[Scale=MatchLowercase]{Apple Symbols} % Unicode mono font

\usepackage[dvipsnames]{xcolor}  		% Color package
\definecolor{dgreen}{rgb}{0.,0.6,0.}    % Deep green
\usepackage{caption}      
\usepackage{todonotes}								% todos

% Definitions for unicode characters not included
\usepackage{newunicodechar}                   
\newunicodechar{ᶜ}{$^c$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ₑ}{$_e$}
\newunicodechar{ᵗ}{$^t$}
\newunicodechar{ˢ}{$^s$}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusiveo license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Generic diff3 for algebraic datatypes}
\subtitle{Subtitle Text, if any}

\authorinfo{Marco Vassena}
           {Chalmers University}
           {vassena@chalmers.se}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}

\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

\section{Universe}
In order to implement data type generic algorithms we need a generic representation of algebraic data types.
The universe used in this paper consists of typed heterogeneous rose trees,
a combination of mutually recursive heterogeneous lists and trees
whose nodes correspond to data type constructors and their subtrees
to their fields.
\begin{minted}{agda}
  data HTree : Set → Set where
    Node : F as a → HList as → HTree a

  data HList : List Set → Set where
    [] : HList []
   _∷_ : HTree a → HList as → HList (a ∷ as)
\end{minted}
	The type \texttt{F as a} denotes the constructor of an algebraic data
	type of type \texttt{a} that takes arguments of types determined by the list 
	\texttt{as}. This representation is type-safe because the constructor
	\texttt{Node} requires the same types \texttt{as} in the fields types and in 
	the list of subtrees, hence denoting a 	well-typed application of a 
	constructor to its arguments.
	Its definition is unimportant for the moment, therefore we will leave it
	abstract using a postulate. Furthermore a basic comparison
	function is assumed.
\begin{minted}{agda}
  postulate F : List Set → Set → Set 
  postulate _=?=_ : (α : F as a) (β : F bs b) → Dec (α ≡ β)
\end{minted}	
	The data type \texttt{Dec (α ≡ β)} denotes decidable equality between
	two nodes, which either contains a proof of the actual equality
	or a counter example.
\begin{minted}{agda}
data Dec (P : Set) : Set where
  yes : P → Dec P
  no  : ¬ P → Dec P
\end{minted}
	Negation of statements such as \texttt{¬ P} are encoded in type theory as
	a function \texttt{P → ⊥}, where \texttt{⊥} is
	the constructorless data type, which corresponds to falsity 
	under the Curry-Howard isomorphism \cite{PropositionAsTypes}.
	The equality definition used is a a variant of heterogeneous equality
	tailored on nodes, whose only axiom is reflexivity:
\begin{minted}{agda}
data _≡_ : F as a → F bs b → Set where
  refl : {α : View as a} → α ≡ α
\end{minted}

	In section \ref{Haskell} we show how it is possible to implement these 
	features in a strongly typed functional language like Haskell.
	
	In the following we will use two auxiliary functions to append and split 
	heterogeneous lists:
\begin{minted}{agda}
_+++_ : HList as → HList bs → HList (as ++ bs)
hsplit : HList (as ++ bs) → HList as × HList bs
\end{minted}
	
\section{Generic diff}
	Our \texttt{diff3} algorithm relies on a \texttt{diff} algorithm used 
        as a subroutine to quickly compare the input objects and merge them.
	The algorithm finds the differences between two heterogeneous lists given 
	as input producing an edit script, whose edit operations progressively 
	transform one into the other.

	\subsection{Edit Operations}
	Single edits are defined over values, which denote either the presence or 
	the absence of a node.
\begin{minted}{agda}
data Val : List Set → List Set → Set where
  ⊥ : Val [] []
  ⟨_⟩ : F as a → Val as [ a ] 
\end{minted}
	Values are indexed by two lists that are used to stack edits in a type 
	safe fashion and that contain respectively the types of the fields of a node 
	and its resulting type.
	Since empty values do not store any node their lists are both empty.

	The set of edit operations considered includes a no-operation, node 
	deletion, insertion and update.
\begin{minted}{agda}
data _~>_ : Val as bs → Val cs ds → Set where
  Nop : ⊥ ~> ⊥
  Del : (α : F as a) → ⟨ α ⟩ ~> ⊥
  Ins : (α : F as a) → ⊥ ~> ⟨ α ⟩
  Upd : (α : F as a) (β : F bs a) → ⟨ α ⟩ ~> ⟨ β ⟩
\end{minted}
	Edits are indexed by two values, called respectively 
	\emph{source} and \emph{target} values. The \texttt{Nop} edit is 
	a no-operation that is used exclusively to \emph{align} edit scripts,
	therefore it maps the empty value into itself.
	The edit \texttt{Del α} deletes the node \texttt{α} from the source object, 
	thus it is mapped into \texttt{⊥}. Conversely the edit \texttt{Ins α} 
	inserts the node \texttt{α} in the target object and therefore its source value 
	is 	\texttt{⊥}.
	Lastly \texttt{Upd α β} denotes the update of the source node \texttt{α}
	to the target node \texttt{β}, which concretely represents a 
	constructor change. 
	Note that there is not a distinct copy edit, which is instead encoded as a 
	special	update, in which the source and target nodes are the same.
	Edits whose source and target values are identical are 
	called \emph{identity} edits. Copies and no-operations fall into this
	category.
	
	\subsection{Edit Script}
	An edit script collects a finite number of edit operations, 
	while preserving type-safety. 
\begin{minted}{agda}
data ES : List Set → List Set → Set where
  [] : ES [] []
  _::_ : {v : Val as bs} {w : Val cs ds} → v ~> w → 
          ES (as ++ xs) (cs ++ ys) → ES (bs ++ xs) (ds ++ ys)
\end{minted}	
	An edit script of type \texttt{ES xs ys} transforms
	a \emph{source} object of type \texttt{HList xs} into
	a \emph{target} object of type \texttt{HList ys}. 
	The following function retrieves the source object from an edit script:			
\begin{minted}{agda}
⟪_⟫ : ES as bs → HList as
⟪ [] ⟫ = []
⟪ Nop ∷ e ⟫ = ⟪ e ⟫
⟪ Del α ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
⟪ Ins α ∷ e ⟫ = ⟪ e ⟫
⟪ Upd α β ∷ e ⟫ with hsplit ⟪ e ⟫
... | hs₁ , hs₂ = Node α hs₁ ∷ hs₂
\end{minted}
	No-operations and insert edits do not affect the source object,
	because their source value is empty, therefore in these cases the source 
	function is simply called recursively.
	On the other hand delete and update edits alter a node of the
	source object by either removing it or changing it.
	In these two cases such node is output as part of the source object.
	The source function is called recursively on the rest of the edit 
	script producing a list, whose prefix correspond to the subtrees of the
	top node. Using the function \texttt{hsplit} the list is decomposed 
	accordingly in two parts, which are then assembled appropriately.
	
	Dually we define a function that retrieves the target object.
	Since it is analogous to the previous we give only its signature:
	
\begin{minted}{agda}
⟦_⟧ : ES as bs → HList bs
\end{minted}

	\subsection{Diff algorithm}
	The \texttt{diff3} algorithm employs a \texttt{diff} algorithm that has the 
	following	signature:
\begin{minted}{agda}
diff : HList as → HList bs → ES as bs
\end{minted}
        Nevertheless our formalization abstracts over the concrete diffing algorithm
        used. Any \texttt{diff} algorithm that satisfy the following specifications
        can be employed in \texttt{diff3}:
\[ \texttt{e = diff x y} \qquad \Leftrightarrow \qquad \texttt{⟪ e ⟫ ≡ x} \quad \land \quad  \texttt{⟦ e ⟧ ≡ y} \]
	This basic requirement demands that the edit script computed by 
	\texttt{diff} precisely encodes a transformation from the source object 
	\texttt{x} to the target object \texttt{y}.
	The advantage of reasoning by such specification is that we are not bound
	to a particular \texttt{diff} algorithm when studying the properties of 
	\texttt{diff3}, so that arbitrary diffing techniques can be used.
        The following data type serves to this purpose: \texttt{Diff x y e} is the 
        proof that the edit script \texttt{e} is the result of diffing the lists 
        \texttt{x} and \texttt{y}.
\begin{minted}{agda}
data Diff : HList xs → HList ys → ES xs ys → Set₁ where
  End : Diff [] [] []
  Nop : Diff x y e → Diff x y (Nop ∷ e)
  Del : Diff (x₁ +++ x₂) y e → Diff (Node α x₁ ∷ x₂ ) y (Del α ∷ e)
  Ins : Diff x (y₁ +++ y₂) e → Diff x (Node β y₁ ∷ y₂) (Ins β ∷ e)
  Upd : Diff (x₁ +++ x₂) (y₁ +++ y₂) e → 
        Diff (Node α x₁ ∷ x₂) (Node β y₁ ∷ y₂) (Upd α β ∷ e)
\end{minted}
        This specification  is a safe approximation of a \texttt{diff} algorithm,
        because for any edit script the two input lists do correspond to its
        source and target object.
\begin{minted}{agda}
Diff⇐ : (e : ES xs ys) → Diff ⟪ e ⟫ ⟦ e ⟧ e
\end{minted}
        Furthermore also the converse implication holds:
\begin{minted}{agda}
Diff⇒ : Diff x y e → x ≡ ⟪ e ⟫  ×  y ≡ ⟦ e ⟧
\end{minted}


	In our implementation the \texttt{diff} algorithm employed is a 
        generalization of that proposed by Lempsink et al.\ \cite{Lemp09} and 
        therefore we will not discuss it any further. 
        We only remark that in our model we have proved that it 
	complies with the \texttt{Diff} specification:
\begin{minted} {agda}
diff-suff :  (x : HList xs) (y : HList ys) → Diff x y (diff x y)
\end{minted}

\section{Generic diff3}
	The \texttt{diff3} algorithm takes as input three objects, the original
	version called \emph{base} and two new replicas, and it outputs an
	edit script that combines the changes between them.
	However the algorithm does not work directly on the replicas, but relies
	on a \texttt{diff} algorithm to compute two edit scripts that describe
	the changes from base to each of the new versions.
	It then merges the edits contained in the two edit scripts and produce
	an edit script, whose \emph{source} is the base object and whose 
	\emph{target} is the merged object.
	Nevertheless not all edits can be automatically reconciled.
	In these cases a conflict is detected and reported to the user, who has
	to manually solve it.
		
	The merging technique employed in the \texttt{diff3} algorithm for
	algebraic data types consists in applying the three-way merge algorithm
	at the node level. 
	Informally the algorithm compares correspondent parts 
	of two objects and of their base version.
	When two parts disagree, the base version is examined:
	if all of them are different a conflict is detected, 
        otherwise the version that changed from base is chosen.
	
	To put this strategy on a formal footing we give precise definitions
	of corresponding parts and conflicts.
	On top of these we define a sound merging semantics.

	\subsection{Alignment}
	Two edit operations are \emph{aligned} if they share the same 
	\emph{source} value. We naturally extend the definition of alignment to edit 
	scripts.	Two edit scripts are \emph{aligned} if all their edits are pairwise 
	aligned. The following data type denotes aligned edit scripts:	
\begin{minted}{agda}
data _⋎_ : ES as bs → ES as cs → Set where
  nil : [] ⋎ []
  cons : (f : u ~> v) (g : u ~> w) → e₁ ⋎ e₂ → f ∷ e₁ ⋎ g ∷ e₂ 
\end{minted}
	The definition is recursive: two edit scripts are aligned either if they are
	both empty or they contain two aligned edits and their tails are aligned.
	Note that we do not need an auxiliary data type to encode edit 
	alignment since this property can be expressed directly in signatures.
	For example the \texttt{cons} constructor accepts only aligned edits
	because it requires them to have the same source value \texttt{u}.
	
        Intuitively two edit scripts that have the same \emph{source} object
        can be aligned, because they share the same set of \emph{source} nodes.
        However the scripts may get diasligned because of insert edits occuring
        at different points. 
        \todo{example!}
        Interestingly alignment can be recovered by inserting no-operation edits in 
        these points. 
        The relation \texttt{e₁ ⊴ e₂} denotes that the edit script \texttt{e₂}
        extends \texttt{e₁} with a finite number of \texttt{Nop} edits.
        Note that the \texttt{Nop} edit change neither the \emph{source} nor 
        the \emph{target} of the edit script, therefore it is an harmless 
        extension.
        
\begin{minted}{agda}
      e₁ ⊴ e₂     ⇒     ⟦ e₁ ⟧ ≡ ⟦ e₂ ⟧    ×    ⟪ e₁ ⟫ ≡ ⟪ e₂ ⟫ 
\end{minted}

        No-operations are automatically aligned with inserts because
        they both share the empty value \texttt{⊥} as \emph{source} and furthermore
        they may not introduce spurious conflicts because they are \emph{identity}
        edits.
   
        \paragraph{Weak Alignment}
        Two edit scripts are \emph{weakly aligned} \texttt{e₁ \textasciitilde\ e₂} 
        if they admit extensions that are \emph{aligned}:
\begin{minted}{agda}
data _~_ (e₁ : ES xs ys) (e₂ : ES xs zs) : Set where
  WA : e₁ ⊴ e₁' → e₂ ⊴ e₂' → e₁' ⋎ e₂' → e₁ ~ e₂
\end{minted}

        We can now weakly align two edit scripts, that share the
        same \emph{source} object. The alignment procedure examines the scripts
        and extend either of them with no-operations, whenever one inserts a 
        node and the other does not. 
\begin{minted}{agda}
align : Diff x y e₁ → Diff x z e₂ → e₁ ~ e₂
\end{minted}

	\subsection{Merge Semantics}
	Our merge semantics is defined over aligned edits.
	Two aligned edits contain at most three distinct values: 
	one common source and two, 	possibly different, targets, which 
	are treated as corresponding parts.
	A merge can either fail raising a conflict or succeed producing
	an edit that combines both.
	
	\paragraph{Merge}
	The data type \texttt{f ⊔ g ↧ h} the proof that merging the 
	aligned edits \texttt{f} and \texttt{g} succeeds producing the edit \texttt{h}.
	
\begin{minted} {agda}
data _⊔_↧_ : (v ~> a) → (v ~> b) → (v ~> c) → Set where
  Id₁ : (f : v ~> v) (g : v ~> w) → f ⊔ g ↧ g
  Id₂ : (f : v ~> w) (g : v ~> v) → f ⊔ g ↧ f
  Idem : (f : v ~> w) → f ⊔ f ↧ f
\end{minted}

	Note that the data type definition already constraints the input edits to
	be aligned, because both have the same source \texttt{v}.
	Furthermore merging determines only the \emph{target} value,
	hence also the merged edit share the same source value.

	Each constructor represents a distinct axiom that explains why
	the merge is possible and determines the merged edit.
	The rules \texttt{Id₁} and \texttt{Id₂} apply when 
	respectively the first and the second transformation is an \emph{identity} 
        edit.
	Accordingly to the three-way merge algorithm, when the source node
	is unchanged in one edit, the other edit is chosen.
	The fact that merging is an \emph{idempotent} operation motivates the 
	third rule \texttt{Idem}.
	It accounts especially for false-positive conflicts and applies 
	when the same edit is performed independently.
	
	Note that this definition is particularly effective because it is 
	minimal and concise, as it does not mention specific
	edits, yet it is complete, because it can encode all the true concrete 
        merges.	

	\paragraph{Conflict}
	A conflict occurs when two edits perform irreconcilable changes.
	The following data type denotes the set of conflicts that may arise
	from aligned edits.
	
\begin{minted}{agda}
data Conflict : Val as bs → Val cs ds → Val es fs → Set where
  DelUpd : (α : F as a) (β : F bs a) → Conflict ⟨ α ⟩ ⊥ ⟨ β ⟩
  UpdDel : (α : F as a) (β : F bs a) → Conflict ⟨ α ⟩ ⟨ β ⟩ ⊥ 
  InsIns : (α : F as a) (β : F bs b) → Conflict ⊥ ⟨ α ⟩ ⟨ β ⟩
  UpdUpd : (α : F as a) (β : F bs a) (γ : F cs a) →
             Conflict ⟨ α ⟩ ⟨ β ⟩ ⟨ γ ⟩    
\end{minted}

	The data type is indexed by three values which represents respectively
	the common source value and the target value of the first and second
	edit.	Conflicts given by \texttt{InsIns} and \texttt{UpdUpd}	 correspond to 
	conflicting insertions and updates which resemble to some extent the
	conflicts in the original GNU \texttt{diff3}. Those given by \texttt{UpdDel} 
	and \texttt{DelUpd} are entirely new and stem from the fact that these two
	edits are in general irreconcilable.

	A conflict is the result of an unsuccessful merge, which is denoted
	by the data type \texttt{f ⊔ g ↥ c}.

\begin{minted}{agda}
data _⊔_↥_ : (u ~> v) → (u ~> w) → Conflict u v w → Set where
\end{minted}
	 The definition of this data type is outlined in the following table: 
\begin{table}[h]
\centering
\begin{tabular}{| c | c | c | c |}
\hline
\texttt{f : u \textasciitilde> v} & \texttt{g : u \textasciitilde> w} & \texttt{Check} & \texttt{c : Conflict u v w} \\ \hline
\texttt{Ins α} & \texttt{Ins β} & \texttt{α≠β} & \texttt{InsIns α β} \\ \hline
\texttt{Del α} & \texttt{Upd α β} & \texttt{α≠β} & \texttt{DelUpd α β} \\ \hline
\texttt{Upd α β} & \texttt{Del α} & \texttt{α≠β} & \texttt{UpdDel α β} \\ \hline
\texttt{Upd α β} & \texttt{Upd α γ} & \texttt{α≠β}, \texttt{α≠γ}, \texttt{β≠γ} & \texttt{UpdUpd α β γ} \\ \hline
\end{tabular}
\end{table}

% TODO is this table better?
%	\begin{table}[h]
%	\centering
%		\begin{tabular}{| c | c | c | c |}
%		\hline
%		\texttt{Constructor} & \texttt{Edit₁} & \texttt{Edit₂} & \texttt{Constraint} \\ \hline
%		\texttt{InsIns} & \texttt{⊥ \textasciitilde> ⟨ α ⟩} & \texttt{⊥ \textasciitilde> ⟨ β ⟩} & \texttt{α≠β} \\ \hline
%		\texttt{DelUpd} & \texttt{⟨ α ⟩ \textasciitilde> ⊥} & \texttt{⟨ α ⟩ \textasciitilde> ⟨ β ⟩} & \texttt{α≠β}  \\ \hline
%		\texttt{UpdDel} & \texttt{⟨ α ⟩ \textasciitilde> ⟨ β ⟩} & \texttt{⟨ α ⟩ \textasciitilde> ⊥} & \texttt{α≠β} \\ \hline
%		\texttt{UpdUpd} & \texttt{⟨ α ⟩ \textasciitilde> ⟨ β ⟩} & \texttt{⟨ α ⟩ \textasciitilde> ⟨ γ ⟩} & \texttt{α≠β}, \texttt{α≠γ}, \texttt{β≠γ} \\ \hline
%		\end{tabular}
%	\end{table}

	The inequalities demanded by each constructor are very important 
	because they ensure that the changes made are actually incompatible and 
	therefore correctly produce the corresponding conflict.
	For example in the first case, if the nodes \texttt{α} and \texttt{β} were 
	actually the same, the two edits would be two identical inserts, that 
	could be merged 	by \texttt{Idem}. Similarly in the second and third case, if 
	the nodes	 \texttt{α} and \texttt{β} were the same, the update would be a 
	mere copy and the two edits could be merged by \texttt{Id₁} or \texttt{Id₂}. 
	Lastly in a double update all nodes must be different, otherwise
	either \texttt{Id₁}, \texttt{Id₂} or \texttt{Idem} would apply.
	
	\paragraph{Merge Operator}
	The binary operator \texttt{⊔} merges 
	two aligned edits. For every pair of edits \texttt{f} and \texttt{g}, 
	it either finds a suitable edit \texttt{h} and provide
	a proof that \texttt{f ⊔ g ↧ h}, or detects a conflict \texttt{c}, 
	with a proof that \texttt{f ⊔ g ↥ c}.

\begin{minted}{agda}
_⊔_ : (f : u ~> v) (g : u ~> w) →
        (∃ λ c → f ⊔ g ↥ c) ⊎ (∃ λ h → f ⊔ g ↧ h)
\end{minted}
	This operator is outlined in table \ref{table:merge}.			

	\begin{table*}[t]
	\centering
	\begin{tabular}{| c | c | c |}
	\hline
	\texttt{f : u \textasciitilde> v} & \texttt{g : u \textasciitilde> w} &  \texttt{f ⊔ g} 
	\\ \hline
	\texttt{Nop} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ Nop g}} 
	\\ \hline
	\texttt{Upd α α} & \texttt{g} & \textcolor{Green}{\texttt{Id₁ (Upd α α) g}} 
	\\ \hline
	\texttt{f} & \texttt{Nop} & \textcolor{Green}{\texttt{Id₂ f Nop}} 
	\\ \hline
	\texttt{f} & \texttt{Upd α α} & \textcolor{Green}{\texttt{Id₂ f (Upd α α)}} 
	\\ \hline
	\texttt{Del α} & \texttt{Del α} & \textcolor{Green}{\texttt{Idem (Del α)}}
	\\ \hline
	\texttt{Del α} & \texttt{Upd α β} & \textcolor{Red}{\texttt{DelUpd (Del α) (Upd α β) α≠β}}
	\\ \hline
	\texttt{Upd α β} & \texttt{Del α} & \textcolor{Red}{\texttt{UpdDel (Upd α β) (Del α) α≠β}}
	\\ \hline
	\texttt{Ins α} & \texttt{Ins α} & \textcolor{Green}{\texttt{Idem (Ins α)}} 
	\\	\hline
	\texttt{Ins α} & \texttt{Ins β} & \textcolor{Red}{\texttt{InsIns (Ins α) (Ins β) α≠β}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α β} & \textcolor{Green}{\texttt{Idem (Upd α β)}}
	\\	\hline
	\texttt{Upd α β} & \texttt{Upd α γ} & \textcolor{Red}{\texttt{UpdUpd (Upd α β) (Upd α γ) α≠β α≠γ β≠γ}}
	\\ \hline
	\end{tabular}
	
	\captionsetup{singlelinecheck=false, justification=centering}

	\caption{Implementation of merge operator. \\
	 \texttt{f ⊔ g :} \textcolor{Red}{\texttt{f ⊔ g ↥ c}} \texttt{⊎} \textcolor{Green}{\texttt{f ⊔ g ↧ h}}}	 
	\label{table:merge}
	\end{table*}

	\paragraph{Merged Edit Script}
	Just like we defined a merge operator for aligned edits, we need to 
	define a similar operator for aligned edit scripts.
	However since single merges may fail this operator cannot return 
	the same well-typed edit script, that we have defined before.
	Therefore we introduce an alternative edit script, which is only partially 
	well-typed and that can include conflicts.
\begin{minted}{agda}
data ES₃ : List Set → Set where
  [] : ES₃ []
  _∷_ : {u : Val as bs} → u ~> v → ES₃ (as ++ xs) → ES₃ (bs ++ xs)
  _∷ᶜ_ : {u : Val as bs} → (c : Conflict u v w) → 
             ES₃ (as ++ xs) → ES₃ (bs ++ xs)
\end{minted}
	The data type is indexed only by the source type list and it is well-typed
	only with respect to it. Furthermore it provides an additional constructor
	for conflicts. 

	The merge operator for edit scripts takes two aligned edit scripts and
	applies the merge operator \texttt{⊔} previously defined to
	each pair of aligned edits. It builds a merged edit script choosing a 
	suitable constructor depending on the outcome of each single merge.

\begin{minted}{agda}
merge₃ : {e₁ : ES as bs} {e₂ : ES as cs} → e₁ ⋎ e₂ → ES₃ as
merge₃ nil = []
merge₃ (cons f g p) with f ⊔ g
merge₃ (cons f g p) | inj₁ (c , _) = c ∷ᶜ merge₃ p
merge₃ (cons f g p) | inj₂ (h , _) = h ∷  merge₃ p
\end{minted}
	To improve readability the following entry point is defined:
\begin{minted}{agda}
_⊔₃_ (e₁ : ES as bs) (e₂ : ES as cs) {{p : e₁ ⋎ e₂} → ES₃ as
_⊔₃_  _ _ {{p}} = merge₃ p
\end{minted}
	The alignment proof is passed as an instance argument, i.e. a special type 
	of implicit arguments that is automatically resolved at call-sites 
	\cite{Devriese11}.

        In order to reason about merging we encode the specifications of
        the merge operator in the following data type:
\todo{This was called Diff3 in the thesis, but I think Merge3 is more appropriate
because it is a reification of the function merge3}
\begin{minted}{agda}
data Merge₃ : ES xs ys → Es xs zs → ES₃ xs → Set where
 nil : Merge₃ [] [] []
 merge : f ⊔ g ↧ h → Merge₃ e₁ e₂ e₃ → Merge₃ (f ∷ e₁) (g ∷ e₂) (h ∷ e₃)
 conflict : f ⊔ g ↥ c → Merge₃ e₁ e₂ e₃ → Merge₃ (f ∷ e₁) (g ∷ e₂) (c ∷ᶜ e₃)
\end{minted}
        We then show that our merge operator satisify its requirements:
\begin{minted}{agda}
            e₁ ⋎ e₂  ⇒  Merge₃ e₁ e₂ (e₁ ⊔₃ e₂)
\end{minted}
        The proof follows by induction on \texttt{e₁ ⋎ e₂}.

        Also the converse proposition holds
\begin{minted}{agda}
           Merge₃ e₁ e₂ e₃   ⇒   e₃ ≡ e₁ ⊔₃ e₂
\end{minted}
        The proof is also by induction and requires three important properties of
        the merging and conflict semantics.
        Firstly they must be mutually exlusive, i.e\ given
        two aligned edits \texttt{f} and \texttt{g} either they can be merged by
        some edit \texttt{h} (\texttt{f ⊔ g ↧ h}), or they trigger some conflict
        \texttt{c} (f ⊔ g ↥ c). Secondly these relations must be deterministic, i.e.\
        the third index is uniquely determined by the first two.
        
        Now that we have shown that the merge operator is in a one-to-one 
        relationship with the specification data type, we will use the latter
        to reason more conveniently about its properties.

	\paragraph{Diff3}
	Now it is possible to provide the conventional \texttt{diff₃} interface, in
	which the second object is considered the old common version:
\begin{minted}{agda}
diff₃ : HList ys → HList xs → HList zs → ES₃ xs
diff₃ y x z with align (diff-suff x y) (diff-suff x z)
diff₃ y x z | WA _ _ p = merge₃ p
\end{minted}
	
	The \texttt{diff} algorithm is called implicitly by \texttt{diff-suf}; the
	edit scripts so obtained are aligned via extension using 
	\texttt{align}, from which the alignment proof \texttt{p} is extracted
	and used to finally merge the scripts with \texttt{merge₃}.
	Note that the call to \texttt{align} is valid because \texttt{diff-suff}
	is invoked with the same \texttt{x} as first argument.

        \paragraph{Type Checking}
	Even though merging might succeed without triggering any conflic the
        merged edit script might be invalid, i.e. it will not produce a well-typed
        object as \emph{target}. The reason is that the merge operator \texttt{⊔₃} 
        merges edits only mechanically and the edit script obtained by joining two
        well-typed edit script may not be well-typed.
        \todo{Example?}
        
        As a result the merged edit script must be first type-checked in order to
        retrieve the merged \emph{target} object.
	The typing judgment \texttt{e ⇒ as} states that the edit script \texttt{e} 
	is well typed and produces a list of type \texttt{HList as}.
	The typing rules are straightforward:
	
	\begin{center}	
		\mbox{	
				\AxiomC{}
				\UnaryInfC{\texttt{[] ⇓ []}}			
				\DisplayProof
		}
		\mbox{
				\AxiomC{\texttt{f : v \textasciitilde> w}}
				\AxiomC{\texttt{w : F cs ds}}
				\AxiomC{\texttt{e ⇓ cs ++ ys}}
				\TrinaryInfC{\texttt{f ∷ e ⇓ (ds ++ ys)}}
				\DisplayProof
		}
	\end{center}
	
	A trivial inference algorithm can be easily deduced from the typing rules.
	Moreover note that the conflict cons constructor (\texttt{∷ᶜ}) is not 
	mentioned in the typing rules, therefore edit scripts containing
	conflicts are ill-typed.		
	Edit scripts of type \texttt{ES₃} can be converted to \texttt{ES}, if they
	are well typed:
\begin{minted}{agda}
⌜_⌝  : (e : ES₃ xs) → {{q : e ⇓ ys}} → ES xs ys
\end{minted}

        Some of the properties we will present apply only to \emph{successful} 
        merges, i.e.\ those that did not trigger any conflict and that are 
        well-typed. When necessary we will use the following data type to restrict
        to those cases.

\todo{Better name? I don't have good alternatives SMerge₃ , WT-Merge₃}
\begin{minted}{agda}
data Merged₃ : ES xs ys → ES xs zs → ES xs ws → Set where  
  nil : Merged₃ [] [] []
  cons : f ⊔ g ↧ h → Merged₃ e₁ e₂ e₃ → Merged₃ (f ∷ e₁) (g ∷ e₂) (h ∷ e₃)
\end{minted}
        Note that the third index is a well-typed edit script.
        The following lemma ties the connection between \texttt{Merge₃} and 
        \texttt{Merged₃}:
\begin{minted}{agda}
         Merge₃ e₁ e₂ e₃  ,  e₃ ⇓ ws   ⇒   Merged₃ e₁ e₂ ⌜ e₃ ⌝
\end{minted}

\section{Properties}
In this section we present several properties of our merge algorithm 
that have been formally studied using the model presented in this paper.

    \subsection{Conflict}  
    In order to reason about complex merge operations we have studied what are the 
    minimal conditions that will trigger a conflict.

    \subsection{Safety}
    The safety properties act as a sanity check and ensure that the \texttt{diff} 
    and consequently the  \texttt{diff3} algorithm will not make up nor forget any 
    piece of data.

    Firstly we give some auxiliary definitions that will be used to state and prove
    this properties.

    \paragraph{Membership}
    The type \texttt{α ∈ hs} denotes that the node \texttt{α} is present
    in the list of trees \texttt{hs}.

\begin{minted}{agda}
data _∈_ : F xs a → HList ys → Set where
  here : (α : F as a) → α ∈ Node α hs₁ ∷ hs₂
  there : α ∈ hs₁ +++ hs₂ → α ∈ Node β hs₁ ∷ hs₂
\end{minted}

    A similar data type denotes the presence of an edit in a script.

\begin{minted}{agda}
data _∈ₑ_ : v ~> w → ES xs ys → Set where
  here : (f : v ~> w) → f ∈ₑ f ∷ e
  there : f ∈ₑ e → f ∈ₑ g ∷ e
\end{minted}
    Lastly the judgment \texttt{e ⊢ₑ u \textasciitilde> v} denotes that
    the script \texttt{e} contains some edit of type \texttt{u \textasciitilde> v}.
\begin{minted}{agda}
data _⊢ₑ_~>_  (e : ES xs ys) : Val as bs → Val cs ds → Set where
  Nop : Nop ∈ₑ e → e ⊢ₑ ⊥ ~> ⊥
  Del : Del α ∈ₑ e → e ⊢ₑ ⟨ α ⟩ ~> ⊥
  Ins : Ins α ∈ₑ e → e ⊢ₑ ⊥ ~> ⟨ α ⟩
  Upd : Upd α β ∈ₑ e → e ⊢ₑ ⟨ α ⟩ ~> ⟨ β ⟩ 
\end{minted}
    Two fundamental properties of the edit script data type guarantee that
    the source node of an edit will be part of the \emph{source} of the script and
    similarly the target node of an edit will show up in its \emph{target}.
% I think I will skip this one and directly state the more interesting one
% \begin{minted}{agda}
%    ∀   f : ⟨ α ⟩ ~> v  .  f ∈ₑ e   ⇒   α ∈ ⟪ e ⟫
%    ∀   f : v ~> ⟨ α ⟩  .  f ∈ₑ e   ⇒   α ∈ ⟦ e ⟧
% \end{minted}
\begin{minted}{agda}
    e ⊢ₑ ⟨ α ⟩ ~> v   ⇒   α ∈ ⟪ e ⟫
    e ⊢ₑ v ~> ⟨ α ⟩   ⇒   α ∈ ⟦ e ⟧
\end{minted}

    \paragraph{Data Origin}

    It immediately follows from this property and the \texttt{Diff} specifications 
    that any node mentioned in an edit script comes from either the \emph{source}
    or the \emph{target} object.
\begin{minted}{agda}
    e ⊢ₑ ⟨ α ⟩ ~> v   ,   Diff x y e   ⇒   α ∈ x 
    e ⊢ₑ v ~> ⟨ α ⟩   ,   Diff x y e   ⇒   α ∈ y 
\end{minted}

    \paragraph{Data Retention}
    Conversely we show that every node present in either the \emph{source} or
    \emph{target} object is not ignored in the diff, but it is 
    actually processed by some edit in the script.

\begin{minted}{agda}
    Diff x y e   ,   α ∈ x   ⇒   ∃ v . e ⊢ₑ ⟨ α ⟩ ~> v
    Diff x y e   ,   α ∈ y   ⇒   ∃ v . e ⊢ₑ v ~> ⟨ α ⟩
\end{minted}
 
    \paragraph{Edit Origin}
    The safety properties just discussed extend naturally to edits in the 
    \texttt{Merged₃} data type.
    The first one states that any edit found in the merged script,
    comes from either of the input scripts.
\begin{minted}{agda}
        f ∈ e₃   ,   Merged₃ e₁ e₂ e₃    ⇒    f ∈ₑ e₁   ∨   f ∈ₑ e₂
\end{minted}
    
    \paragraph{Persistence}
    The converse property asserts that an edit present in one of the input
    edit scripts will be found in the merged edit script, given that it does
    perform a change and that the output script does not contain conflicts.
    The first hypothesis is needed because identity edits can be silently 
    ignored in the merge semantics given by \texttt{f ⊔ g ↧ h} (\texttt{Id₁}, 
    \texttt{Id₂}).
    On the other hand the second prerequisite is essential, because 
    our algorithm is \emph{persistent}, i.e.\ it refuses to back out changes 
    made by incompatible edits, but triggers an appropriate conflict instead.

    Firstly an edit does perform a change if it is not an identity edit, or, in 
    other words if the source and the target values are different.
				
\begin{minted}{agda}
    f : u ~> v   ∧   u ≠ v   ∧   f ∈ₑ e₁
             Merge₃ e₁ e₂ e₃                   ⇒        f ∈ₑ e₃
             NoConflict e₃ 
\end{minted}
    \paragraph{Proof Sketch}
    The proof is by induction on \texttt{Merge₃ e₁ e₂ e₃} and \texttt{f ∈ₑ e₁}.
    In the base case the edit \texttt{f} is merged with some other edit \texttt{g},
    \texttt{f ⊔ g ↧ h}. Note that \texttt{f ⊔ g ↥ c} cannot occur because of
    the \texttt{NoConflict e₃} hypothesis. By case analysis on \texttt{f ⊔ g ↧ h},
    \texttt{h} may be either \texttt{f} (\texttt{Id₂} or \texttt{Idem}), or 
    \texttt{g} (\texttt{Id₁}. However this case is contradictory because we
    assumed \texttt{f} not to be an identity edit.
    
    The same property holds for edits that belong to the second edit, given
    that the \texttt{Diff₃} relation is symmetric in absence of conflicts.	
    Note that this is not the case, when \texttt{e₃} does contain some conflicts,
    because the \texttt{Conflict} data type is asymmetric.
    The \texttt{NoConflict e₃} hypothesis is obviously redundant when
    considering successful merges.
    
		
    \subsection{Maximality}

    \subsection{Structural  Invariants}
    An edit script transforms lists of trees, traversing and processing 
    their nodes in depth-first order.
    It represents a mapping from the source to the target, in which 
    nodes of the source are embedded in nodes of the target.
    A central property ensured by edit scripts is that the 
    embedding preserves the depth-first ordering of source and target nodes.
    However nodes are not only mapped (updated) from the source to the 
    target, but they may also be inserted and removed. 
    Therefore the embedding-preserving property has to be adjusted to
    take these transformations into account.

    Firstly we formally define depth-first ordering on trees, secondly
    we give a similar relation for edits contained in edit scripts, 
    lastly, by showing how the former implies the latter we deduce
    the structural invariant.
    

    \paragraph{Depth-First Order}
    A pre-order depth-first traversal consists of firstly visiting the current node 
    and then traversing recursively its subtrees from the leftmost to the rightmost.
    The traversal induces an ordering on the nodes, so that those that
    are visited sooner come before those that are processed later.
    Since the edit scripts manipulate list of trees, instead of single trees,
    also the definitions about ordering relations will be adjusted accordingly.

    The type \texttt{hs ⊢ α ⊏ β} denotes that, in the list of trees \texttt{hs}, 
    the node \texttt{α} comes before the node \texttt{β}, according to the
    depth first traversal.

\begin{minted}{agda}
data _⊢_⊏_ : Hist xs → F as a → F bs b → Set where
  here : β ∈ (hs₁ +++ hs₂) → Node α hs₁ ∷ hs₂ ⊢ α ⊏ β
  there : hs₁ +++ hs₂ ⊢ α ⊏ β → Node γ hs₁ ∷ hs₂ ⊢ α ⊏ β
\end{minted}

    The list is used as a stack of trees containing the nodes to be visited.
    In the base constructor \texttt{here}, the node \texttt{α} is pushed on the 
    stack and thus comes before any node \texttt{β}, that belongs to the
    stack of nodes yet to be processed.
    The recursive constructor \texttt{there} adds a node \texttt{γ} to a list of 
    trees, in which \texttt{α} already comes before \texttt{β}.
    Note that the top elements of the stack (\texttt{hs₁}) are popped 
    and combined to construct a new tree, rooted respectively 
    in \texttt{α} and \texttt{γ}, which is then pushed on the stack. 
    In this way it is possible to extend the stack node by node, 
    retaining type-safety. 

    \paragraph{Edits Order}
    The next data type defines a similar relation for edit scripts.
    The type \texttt{e ⊢ₑ f ⊏ g} denotes that in the script \texttt{e}, the edit
    \texttt{f} precedes the edit \texttt{g}.

\begin{minted}{agda}
data _⊢ₑ_⊏_ : ES xs ys → u ~> v → w ~> z → Set where
  here : (f : w ~> z) → g ∈ₑ e → f ∷ e ⊢ₑ f ⊏ g 
  there : (h : s ~> t) → e ⊢ₑ f ⊏ g → h ∷ e ⊢ₑ f ⊏ g 
\end{minted}

    The following basic properties ensure that the order of two edits 
    is reflected by the order of their source nodes in the \emph{source} object.
\begin{minted}{agda}
        f : ⟨ α ⟩ ~> v 
        g : ⟨ β ⟩ ~> w       ⇒       ⟪ e ⟫ ⊢ α ⊏ β
        e ⊢ₑ f ⊏ g 
\end{minted}
    Similarly the order of the target nodes is preserved in the \emph{target} 
    object.    

\begin{minted}{agda}
        f : v ~> ⟨ α ⟩
        g : w ~> ⟨ β ⟩       ⇒      ⟦ e ⟧ ⊢ α ⊏ β
        e ⊢ₑ f ⊏ g
\end{minted}

    Conversely we show that if in the \emph{source} (\emph{target}) 
    object one node precedes another, then the corresponding edits in their diff 
    will share the same order.
\begin{minted}{agda}
Diff x y e  ,  x ⊢ α ⊏ β    ⇒    ∃  f : ⟨ α ⟩ ~> u , g : ⟨ β ⟩ ~> v . 
                                                e ⊢ₑ f ⊏ g

Diff x y e  ,  y ⊢ α ⊏ β    ⇒    ∃  f : u ~> ⟨ α ⟩ , g : v ~> ⟨ β ⟩ . 
                                                e ⊢ₑ f ⊏ g
\end{minted}

    \paragraph{Order-preserving Embedding}
    We now have all the lemmas to prove the main theorem, 
    which states that the edit script data type preserves the depth-first order of
    the source and target objects.
    The theorem is split in two parts, the first one considers 
    the ordering of the source object, and the second of the target.
    The first one states that, given an edit script \texttt{e}, 
    if in its source object a node \texttt{α} comes before
    some node \texttt{β}, then one of the following holds:
    \begin{itemize}
    \item \texttt{α} is deleted in \texttt{e};
    \item \texttt{β} is deleted in \texttt{e};
    \item There are two nodes \texttt{γ} and \texttt{φ}, such that the node 
    \texttt{α} is 	mapped to \texttt{γ}, the node \texttt{β} is mapped to 
    \texttt{φ} in \texttt{e} and 
    in the target	object, the node \texttt{γ} comes before \texttt{φ}
    \end{itemize}

    The theorem can be formally stated as follows:
\begin{minted}{agda}
        Diff x y e   ,   x ⊢ α ⊏ β      ⇒      e ↦ α ⊏ β
\end{minted}

    Where the type \texttt{e ↦ α ⊏ β} denotes that \texttt{e} is a (source) 
    order-preserving embedding:
\begin{minted}{agda}
data _↦_⊏_ (e : ES xs ys) (α : F as a) (β : F bs b) : Set where
  Del₁ : e ⊢ₑ ⟨ α ⟩ ~> ⊥ → e ↦ α ⊏ β
  Del₂ : e ⊢ₑ ⟨ β ⟩ ~> ⊥ → e ↦ α ⊏ β
  Map₂ : e ⊢ₑ ⟨ α ⟩ ~> ⟨ γ ⟩ → e ⊢ₑ ⟨ β ⟩ ~> ⟨ φ ⟩ → 
         ⟦ e ⟧ ⊢ γ ⊏ φ → e ↦ α ⊏ β
\end{minted}

    \paragraph{Proof Sketch} By the edit order properties discussed in the previous
    paragraph we know that \texttt{e} contains two edits \texttt{f} and \texttt{g}
    that map respectively \texttt{α} to some value \texttt{u} and \texttt{β} to
    \texttt{v}, such that \texttt{e ⊢ₑ f ⊏ g}. 
    By inspection either \texttt{u} is empty (\texttt{⊥}), or \texttt{v}
    is empty, or they both wrap two nodes \texttt{γ} and \texttt{Φ}.
    In the first two cases it follows that either \texttt{f} or \texttt{g} is
    a delete and the theorem holds (\texttt{Del₁} and \texttt{Del₂}).
    In the last case \texttt{f} and \texttt{g} are both updates then 
    \texttt{e ⊢ₑ ⟨ α ⟩ ~> ⟨ γ ⟩} and \texttt{e ⊢ₑ ⟨ β ⟩ ~> ⟨ Φ ⟩}.
    Since \texttt{e ⊢ₑ f ⊏ g} we can apply the first edit-order property from
    which follows that \texttt{⟦ e ⟧ ⊢ γ ⊏ Φ} and the theorem holds (\texttt{Map₂}).

    The second theorem is symmetrical to the first and thus we will 
    briefly outline it.
    It states that, given an edit script \texttt{e}, if in its
    target object a node \texttt{α} comes before
    some node \texttt{β}, then one of the following holds:
    \begin{itemize}
            \item \texttt{α} is inserted in \texttt{e};
            \item \texttt{β} is inserted in \texttt{e};
            \item There are two nodes \texttt{γ} and \texttt{φ}, such that the node 
            \texttt{γ} is mapped to \texttt{α}, the node \texttt{φ} is mapped to 
            \texttt{β} in 	\texttt{e} and in the source object, 
            the node \texttt{γ} comes before \texttt{φ}
    \end{itemize}

    More formally:
\begin{minted}{agda}
        Diff x y e   ,   y ⊢ α ⊏ β      ⇒      e ↤ α ⊏ β
\end{minted}

    The type \texttt{e ↤ α ⊏ β} denotes that \texttt{e} is a (target) 
    order-preserving embedding:

\begin{minted}{agda}
data _↤_⊏_ (e : ES xs ys) (α : F as a) (β : F bs b) : Set where
  Ins₁ : e ⊢ₑ ⊥ ~> ⟨ α ⟩ → e ↤ α ⊏ β
  Ins₂ : e ⊢ₑ ⊥ ~> ⟨ β ⟩ → e ↤ α ⊏ β
  Map₂ : e ⊢ₑ ⟨ γ ⟩ ~> ⟨ α ⟩ → e ⊢ₑ ⟨ φ ⟩ ~> ⟨ β ⟩ → 
       ⟪ e ⟫ ⊢ γ ⊏ φ → e ↤ α ⊏ β
\end{minted}

    The proof is symmetrical to the first one and will not be discussed any further.

    \paragraph{Merged$_3$}
    Also successful merges retain the order-preserving property, i.e.\
    the order of the edits in the input scripts is preserved.
    The property holds intuitively because the merge algorithm
    does not rearrange the input edits, 
    but rather merge them pointwise, retaining the original order in the merged 
    script.
    Nevertheless identity edits might be dropped in the merged script in favour,
    according to the semantics of \texttt{f ⊔ g ↧ h}, hence
    the theorem applies only to \emph{non-identity} edits.
    Note also that successful merges do not trigger any conflict, which
    would also break this property.

\begin{minted}{agda}
    Merged e₁ e₂ e₃
    e₁ ⊢ₑ f ⊏ g                  ⇒              e₃ ⊢ₑ f ⊏ g
    f : u ~> v  , g : w ~> z  
    u ≠ v , w ≠ z
\end{minted}
    Since \texttt{Merged₃ e₁ e₂ e₃} is a symmetric relation, the property holds 
    for edits of the second script. 

\section{Discussion and Related Work}

\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices


%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex -shell-escape
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End: 

